diff -X exclude -ruN daisyMoon/alloyConstants.lua moddedDaisyMoon/alloyConstants.lua
--- daisyMoon/alloyConstants.lua	1970-01-01 01:00:00.000000000 +0100
+++ moddedDaisyMoon/alloyConstants.lua	2023-12-06 20:40:43.492099601 +0100
@@ -0,0 +1,78 @@
+ALLOY_KEY_CODES = {
+
+  backspace = 8,
+  tab = 9,
+
+  enter = 13,
+
+  shift = 16,
+  ctrl = 17,
+
+  caps_lock = 20,
+
+  escape = 27,
+
+  pageup = 33,
+  pagedown = 34,
+  kend = 35,
+  home = 36,
+  arrowleft = 37,
+  arrowup = 38,
+  arrowright = 39,
+  arrowdown = 40,
+
+  insert = 45,
+  delete = 46,
+
+  k0 = 48,
+  k1 = 49,
+  k2 = 50,
+  k3 = 51,
+  k4 = 52,
+  k5 = 53,
+  k6 = 54,
+  k7 = 55,
+  k8 = 56,
+  k9 = 57,
+
+  a = 65,
+  b = 66,
+  c = 67,
+  d = 68,
+  e = 69,
+  f = 70,
+  g = 71,
+  h = 72,
+  i = 73,
+  j = 74,
+  k = 75,
+  l = 76,
+  m = 77,
+  n = 78,
+  o = 79,
+  p = 80,
+  q = 81,
+  r = 82,
+  s = 83,
+  t = 84,
+  u = 85,
+  v = 86,
+  w = 87,
+  x = 88,
+  y = 89,
+  z = 90,
+  super = 91,
+
+  f1 = 112,
+  f2 = 113,
+  f3 = 114,
+  f4 = 115,
+  f5 = 116,
+  f6 = 117,
+  f7 = 118,
+  f8 = 119,
+  f9 = 120,
+
+  f11 = 122,
+  f12 = 123,
+}
diff -X exclude -ruN daisyMoon/alloyDependencies.lua moddedDaisyMoon/alloyDependencies.lua
--- daisyMoon/alloyDependencies.lua	1970-01-01 01:00:00.000000000 +0100
+++ moddedDaisyMoon/alloyDependencies.lua	2023-12-06 20:40:43.492099601 +0100
@@ -0,0 +1,187 @@
+ALLOY_ITEMS_CLONE = table.copy(ITEMS)
+ALLOY_ITEM_ATTRIBUTES = {}
+ALLOY_ITEM_NAMES = {}
+
+function AlloyGetValue(str)
+  local value = _G
+  for index in string.gmatch(str, "([^.]+)") do
+    if value[index] then
+      value = value[index]
+    else
+      print("Attempting to index into a nil value!  index attempt: " .. str)
+      return nil
+    end
+  end
+  return value
+end
+
+function AlloyPreInitItems()
+  DEFS.items.pre_init(ITEMS)
+  print("Items pre init done!")
+  DEFS.objects.generate_items()
+  print("Item Object generation done!")
+  --AlloyCustomTest()
+end
+
+function AlloyInit()
+  DEFS.items.init(ITEMS)
+  math.initRandom()
+  print("Items init done!")
+  DEFS.objects.init()
+  print("Objects init done!")
+end
+
+function AlloyCustomTest()
+  print("---OBJECTS---")
+  if OBJECTS["gyrojetGun"] then
+    for _, line in pairs(AlloyParseTable(OBJECTS["gyrojetGun"])) do print(line) end
+  else
+    print(nil)
+  end
+  print("---ITEMS---")
+  if ITEMS["gyrojetGun"] then
+    for _, line in pairs(AlloyParseTable(ITEMS["gyrojetGun"])) do print(line) end
+  else
+    print(nil)
+  end
+  print("---CUSTOM-OBJECTS---")
+  if OBJECTS["gyrojetBigGun"] then
+    for _, line in pairs(AlloyParseTable(OBJECTS["gyrojetBigGun"])) do print(line) end
+  else
+    print(nil)
+  end
+  print("---CUSTOM-ITEMS---")
+  if ITEMS["gyrojetBigGun"] then
+    for _, line in pairs(AlloyParseTable(ITEMS["gyrojetBigGun"])) do print(line) end
+  else
+    print(nil)
+  end
+end
+
+--local ALLOY_INPUT_DEBUG = {enabled = true, lastKey = -1}
+
+--function ToggleAlloyInputDebug()
+--  ALLOY_INPUT_DEBUG.enabled = not ALLOY_INPUT_DEBUG.enabled
+--end
+
+local ALLOY_ITEM_EXPLORERS = {}
+
+function RegisterAlloyItemExplorer(explorer)
+  ALLOY_ITEM_EXPLORERS[#ALLOY_ITEM_EXPLORERS + 1] = explorer
+end
+
+hook.add("frameRender", function()
+  --if ALLOY_INPUT_DEBUG.enabled then
+  --  for i = 0, 255 do
+  --    if daisy.isKeyPressed(i) then
+  --      ALLOY_INPUT_DEBUG.lastKey = i
+  --    end
+  --  end
+  --  if ALLOY_INPUT_DEBUG.lastKey ~= -1 then
+  --    video.renderShadowedTextSprites("key " .. ALLOY_INPUT_DEBUG.lastKey, 50, 100, 1, "small", 255, 255, 255, 255, nil, 0.75)
+  --  end
+  --end
+
+  for key, value in pairs(ALLOY_ITEM_EXPLORERS) do
+    if value:isVisible() then
+      if value.renderItem then
+        value:renderItem()
+      end
+    else
+      ALLOY_ITEM_EXPLORERS[key] = nil
+    end
+  end
+end)
+
+function UpdateAlloyItemData()
+  ALLOY_ITEM_ATTRIBUTES = {}
+  ALLOY_ITEM_NAMES = {}
+  local item_amount = 0
+  local key_amount = 0
+  for item_name, item_value in pairs(ALLOY_ITEMS_CLONE) do
+    if item_name then
+      ALLOY_ITEM_NAMES[#ALLOY_ITEM_NAMES + 1] = item_name
+      if item_value then
+        for key, value in pairs(item_value) do
+          if value ~= nil or value ~= '' then
+            if ALLOY_ITEM_ATTRIBUTES[key] == nil then
+              ALLOY_ITEM_ATTRIBUTES[key] = { value = 1 }
+              key_amount = key_amount + 1
+            elseif ALLOY_ITEM_ATTRIBUTES[key][value] == nil then
+              ALLOY_ITEM_ATTRIBUTES[key][value] = 1
+            else
+              ALLOY_ITEM_ATTRIBUTES[key][value] = ALLOY_ITEM_ATTRIBUTES[key][value] + 1
+            end
+          end
+        end
+      end
+      item_amount = item_amount + 1
+    end
+  end
+  print("Indexed " .. item_amount .. " items and " .. key_amount .. " attributes!")
+end
+
+function AlloyGetDebugFunction(func, max)
+  if type(func) ~= "function" then
+    return nil
+  end
+  local output = {}
+  local t = debug.getinfo(func)
+  local name = t.source:gsub("^@", "")
+  local i = 0
+  for line in io.lines(name) do
+    i = i + 1
+    if i >= t.linedefined then
+      if string.len(line) > max then
+        print(line .. "   is too long")
+      end
+      output[#output + 1] = line
+    end
+    if i >= t.lastlinedefined then
+      break
+    end
+  end
+  return output
+end
+
+function AlloyParseTable(table)
+  if type(table) ~= "table" then
+    return nil
+  end
+  local output = {}
+  local index = 1
+  for key, value in pairs(table) do
+    local line = key .. " = "
+    local type = type(value)
+    if type == "nil" then
+      line = line .. "nil"
+    elseif type == "number" then
+      line = line .. value
+    elseif type == "string" then
+      line = line .. '"' .. value .. '"'
+    elseif type == "boolean" then
+      if value then
+        line = line .. "True"
+      else
+        line = line .. "False"
+      end
+    elseif type == "table" then
+      line = line .. "{"
+    else
+      line = line .. "type:" .. type
+    end
+    output[index] = line
+    index = index + 1
+    if type == "table" then
+      for nKey, nValue in pairs(AlloyParseTable(value)) do
+        output[index] = "  " .. nValue
+        index = index + 1
+      end
+    end
+  end
+  return output
+end
+
+dofile("alloyConstants.lua")
+dofile("alloy.lua")
+dofile("alloyItem.lua")
diff -X exclude -ruN daisyMoon/alloyEdit.lua moddedDaisyMoon/alloyEdit.lua
--- daisyMoon/alloyEdit.lua	1970-01-01 01:00:00.000000000 +0100
+++ moddedDaisyMoon/alloyEdit.lua	2023-12-06 20:40:43.492099601 +0100
@@ -0,0 +1,206 @@
+AlloyEdit = inherited("AlloyEdit", ManipulatorState)
+
+local DEFAULT_ALLOY_EDIT_STATE = {
+  manipulatorType = "node",
+  appId = "NIL",
+  autoBackups = true,
+  overallZoom = 1
+}
+
+function AlloyEdit:new()
+	local e = instance(self)
+	
+	e.input:setSet("adventure")
+	e:initStateData("alloystate")
+	e:initView(ResourceView:new(), 0.001, 4)
+	
+	e.menuBar = MenuBar:new(e, "alloy")
+	
+	e:addManipulators("nodeCamera", "node")
+	e:loadState(DEFAULT_ALLOY_EDIT_STATE)
+	sprites.requireDefsKey(e, BGS, "whiteGradient")
+
+	UpdateAlloyItemData()
+	
+	return e
+end
+
+function AlloyEdit:getUndoData()
+	return self.alloy
+end
+
+function AlloyEdit:saveUndoData(file, data, meta)
+	data:save(file)
+end
+
+function AlloyEdit:loadUndoData(file, meta)
+	self.manipulator:clearDependencies()
+	file:setRootPath(self.alloy:getPath())
+	
+	local a = Adventure:load(file)
+	
+	if a then
+		a:initGraph()
+		self:setResource(a)
+	end
+end
+
+function AlloyEdit:init()
+	states.get("music"):stopCurrentMusic()
+	self.menuBar:refreshMenuTree()
+	self:finishInit()
+end
+
+function AlloyEdit:finishInit()
+end
+
+function AlloyEdit:enable()
+	self.gui.gui:setVisible(true)
+	self.input:reset()
+	states.get("input"):offerInput("alloyEdit", self.input)
+	
+	if self:getResource() then
+		self:getResource():refresh()
+	end
+end
+
+function AlloyEdit:unpause()
+	self.gui.gui:setVisible(true)
+end
+
+function AlloyEdit:pause()
+	self.gui.gui:setVisible(false)
+end
+
+function AlloyEdit:disable()
+	states.get("input"):retractInput("alloyEdit")
+	self.gui.gui:setVisible(false)
+end
+
+function AlloyEdit:close()
+	self:onStateEvent("onClose")
+	self:disable()
+	self:saveState()
+end
+
+function AlloyEdit:mouseClick(x, y, button, clickCount)
+	self:super().mouseClick(self, x, y, button, clickCount)
+end
+
+function AlloyEdit:keyPressed(key)
+	self.menuBar:checkMenuShortcut(key)
+end
+
+function AlloyEdit:resourcePositionToCanvas(x, y)
+	if self.layer then
+		return self.layer:positionToCanvas(x, y, self.view.camera)
+	else
+		return x, y
+	end
+end
+
+function AlloyEdit:screenPositionToResource(x, y)
+	if self.layer then
+		return self.layer:xToLayer(self.view:xToCamera(window.xToView(x, self.view), self.layer), self.view.camera), self.layer:yToLayer(self.view:yToCamera(window.yToView(y, self.view), self.layer), self.view.camera)
+	else
+		return x, y
+	end
+end
+
+function AlloyEdit:update(time)
+	self:super().update(self, time)
+	self.view:updatePan(self.mouse, time, 500 / self.overallZoom)
+	self:updateZoom(time)
+	self:refreshMouseCoordinates()
+	
+	if not self.mouse.eaten and self.manipulator then
+		self.manipulator:updateInput(self.input, self.mouse, self.mouse.x, self.mouse.y, time)
+		
+		if self.input.esc and not self.input.lastEsc then
+			self.manipulator:reset()
+			
+			if self.manipulator:isTool() then
+				self:restoreManipulator()
+			else
+				self:setManipulator(self.layer:getManipulatorType())
+			end
+		end
+		
+		if self.input.drag then
+			self:setManipulator("nodeCamera")
+		elseif not self.input.drag and self.input.lastDrag then
+			self:restoreManipulator()
+		end
+	end
+	
+	if self.layer then
+		self.layer:updateEdittime(time)
+	end
+	
+	self:refreshMouseCoordinates()
+	self.view:update(time)
+	self:super().postUpdate(self, time)
+end
+
+function AlloyEdit:stopRoutines()
+	if self.alloy then
+		self.alloy:stopRoutines()
+	end
+end
+
+function AlloyEdit:getResource()
+	return self.alloy
+end
+
+function AlloyEdit:onNewResource(res)
+	res:initEdit(res)
+end
+
+function AlloyEdit:setResource(u)
+	self.alloy = u
+	
+	self.view:setResource(u)
+	self:setView(self.view)
+	
+	self.layer = self.alloy.graph
+	self.view.camera.x = 0
+	self.view.camera.y = 0
+	
+	self:finishInit()
+end
+
+function AlloyEdit:onSaved(res)
+	app.setLastResource(res)
+	
+	if self.autoBackups then
+		resources.backup("alloy", res, self)
+	end
+end
+
+function AlloyEdit:load(res)
+	self:onStateEvent("onLoad", res)
+	self:setResource(res)
+	app.setLastResource(res)
+end
+
+function AlloyEdit:render()
+	if self.layer then
+		self.layer:renderRelations(self.view.camera, 32, 200, 255, 200)
+	end
+	
+	canvas.setToRef()
+	
+	if self.manipulator then
+		self.manipulator:render(self.input, self.mouse, self.view.camera)
+	end
+	
+	canvas.setToWindow()
+	
+	local col = self.manipulator:isTargeting() and COLORS.darkened or COLORS.white
+	
+	if self.view then
+		self.view:renderEditor(255, col.r, col.g, col.b, self.manipulator, self.input, self.mouse)
+	end
+	
+	self:super().postRender(self)
+end
diff -X exclude -ruN daisyMoon/alloyItem.lua moddedDaisyMoon/alloyItem.lua
--- daisyMoon/alloyItem.lua	1970-01-01 01:00:00.000000000 +0100
+++ moddedDaisyMoon/alloyItem.lua	2023-12-06 20:40:43.492099601 +0100
@@ -0,0 +1,177 @@
+AlloyItem = inherited("AlloyItem", GraphResource)
+
+resources.setClass("alloyItem", AlloyItem)
+
+AlloyItem.versions = {
+  current = 1
+}
+
+function AlloyItem:new(owner)
+  local self = instance(self)
+
+  self:setType("alloyItem")
+  self.owner = owner
+	self.itemDefinition = {
+  	name = "",
+		inherits = "",
+  	tags = {}
+	}
+
+  serialization.initParameters(self:getParameters(), self)
+
+  return self
+end
+
+function AlloyItem:getDefinition()
+	return self.itemDefinition
+end
+
+function AlloyItem:updateDefinition(itemDefinition)
+	self.itemDefinition = itemDefinition
+end
+
+function AlloyItem:getItem()
+	local data = {}
+	for key, value in pairs(self.itemDefinition.tags) do
+		local inherits = self.itemDefinition.inherits
+		if inherits == "" then
+			inherits = self.itemDefinition.name
+		end
+		if value.type == "table" then
+			if value.value == "Unchanged" or type(value.value)  == "table" then
+				data[key] = table.copy(ALLOY_ITEMS_CLONE[inherits][key])
+			else
+				data[key] = table.copy(AlloyGetValue(value.value))
+			end
+		elseif value.type == "function" then
+			if value.value == "Unchanged" or type(value.value) == "function" then
+				data[key] = ALLOY_ITEMS_CLONE[inherits][key]
+				-- this would be better since it creates a copy of the function
+				-- however it the function uses file locals this causes a crash
+				--data[key] = loadstring(string.dump(ALLOY_ITEMS_CLONE[inherits][key]))
+			else
+				data[key] = AlloyGetValue(value.value)
+			end
+		else
+			data[key] = value.value
+		end
+	end
+	return data, self.itemDefinition.name
+end
+
+AlloyItem.serialization = {
+  parametersOrder = {
+    "edit",
+    "item",
+  },
+  parameters = {
+    edit = {
+      type = "instance",
+      spawn = function(self)
+      	_editDialogs.createAlloyEditItemDialog("Edit item", self:getDefinition(), self)
+      end
+    },
+    item = {
+      label = "",
+      type = "text"
+    }
+  }
+}
+
+function AlloyItem:register(file)
+	file:register(self, true)
+
+  serialization.registerParameters(file, self:getParameters(), self)
+end
+
+function AlloyItem:saveItemDefinition(file)
+	if self.itemDefinition.name ~= "" then
+  	file:writeBoolean(true)
+		file:writeString(self.itemDefinition.name)
+
+		file:writeString(self.itemDefinition.inherits)
+
+		local tags = {}
+		for key, value in pairs(self.itemDefinition.tags) do
+			tags[#tags+1] = {
+				name = key,
+				type = value.type,
+				value = value.value
+			}
+		end
+
+		file:writeInt(#tags)
+		for index = 1, #tags do
+			local tType = tags[index].type
+    	local tValue = tags[index].value
+			file:writeString(tags[index].name)
+			file:writeString(tType)
+			if tType == "table" or tType == "function" then
+      	if type(tValue) == "string" then
+					file:writeString(tValue)
+				else
+					file:writeString("Unchanged")
+				end
+			elseif tType == "number" then
+				file:writeString("" .. tValue)
+			elseif tType == "boolean" then
+				file:writeBoolean(tValue)
+			else
+				file:writeString(tValue)
+      end
+    end
+	else
+		file:writeBoolean(false)
+  end
+end
+
+function AlloyItem:save(file)
+  file:writeInt(self.versions.current)
+  file:writeInstance(self)
+	self:saveItemDefinition(file)
+
+  serialization.saveParameters(file, self:getParameters(), self)
+end
+
+function AlloyItem:loadItemDefinition(file)
+	self.itemDefinition = {
+  	name = "",
+		inherits = "",
+  	tags = {}
+	}
+	local exists = file:readBoolean()
+	if exists then
+		self.itemDefinition.name = file:readString()
+		self.itemDefinition.inherits = file:readString()
+
+		local tagAmount = file:readInt()
+		for index = 1, tagAmount do
+			local name = file:readString()
+			local type = file:readString()
+			local value
+
+			if type == "number" then
+				value = tonumber(file:readString())
+			elseif type == "boolean" then
+				value = file:readBoolean()
+			else
+				value = file:readString()
+			end
+
+    	self.itemDefinition.tags[name] = {
+				type = type,
+				value = value
+			}
+		end
+	end
+end
+
+function AlloyItem:load(file, owner)
+	local version = file:readInt()
+	local self = file:readReference()
+	self:loadItemDefinition(file)
+
+	serialization.loadParameters(file, self)
+
+  return self
+end
diff -X exclude -ruN daisyMoon/alloy.lua moddedDaisyMoon/alloy.lua
--- daisyMoon/alloy.lua	1970-01-01 01:00:00.000000000 +0100
+++ moddedDaisyMoon/alloy.lua	2023-12-06 20:40:43.492099601 +0100
@@ -0,0 +1,227 @@
+Alloy = inherited("Alloy", GraphResource)
+Alloy.versions = {
+	current = 1
+}
+
+resources.setClass("alloy", Alloy)
+
+function Alloy:new()
+	local self = instance(self)
+
+	self:setType("alloy")
+	serialization.initParameters(self:getParameters(), self)
+
+	return self
+end
+
+Alloy.serialization = {
+	parametersOrder = {
+		"displayName",
+		"description",
+		"author",
+		"codeEntryPoint",
+		"items"
+	},
+	parameters = {
+		displayName = {
+			index = "name",
+			type = "localizedText"
+		},
+		description = {
+			index = "description",
+			type = "localizedText"
+		},
+		author = {
+			type = "text"
+		},
+		codeEntryPoint = {
+			type = "optionalnested",
+			parametersOrder = {
+				"picker",
+				"value"
+			},
+			parameters = {
+				picker = {
+					type = "instance",
+					spawn = function(self)
+						local folder = self.folder
+						if folder then
+							local callback = {
+								codeEntryPoint = self.codeEntryPoint,
+								onOk = function(holder, path)
+									local folder, file, type = string.match(path, "(.-)([^\\/]-%.?([^%.\\/]*))$")
+									holder.codeEntryPoint["value"] = file
+								end
+							}
+							_editDialogs.createFileDialog("Set entry point path...", folder, "*.lua", callback)
+						end
+					end
+				},
+				value = {
+					label = "",
+					type = "text",
+				}
+			}
+		},
+		items = {
+			type = "children",
+			spawn = function(self)
+				return AlloyItem:new(self)
+			end
+		}
+	},
+	header = {},
+	contents = {
+		dummyContent = {
+			type = "text"
+		}
+	}
+}
+
+function Alloy:moduleLoad()
+	if self.codeEntryPoint["value"] and self.folder then
+		local path = self.folder .. "/" .. self.codeEntryPoint.value
+		dofile(path)
+		print("Loaded file at: " .. path .. " !")
+	end
+
+	local amount = 0
+	for _, value in pairs(self.items) do
+		local data, name = value:getItem()
+		ITEMS[name] = data
+		amount = amount + 1
+	end
+	AlloyPreInitItems()
+	AlloyInit()
+
+	print("Loaded " .. amount .. " additional items!")
+end
+
+function Alloy:populateInfo(info)
+	info.author = self.author or info.author
+	info.name = self.displayName or info.name
+	info.description = self.description or info.description
+end
+
+function Alloy:register(file)
+	if file:register(self, true) then
+		if self.graph then
+			self.graph:register(file)
+		end
+
+		self:registerRecursiveChildren(file)
+
+		if self:getParameters() then
+			serialization.registerParameters(file, self:getParameters(), self)
+		end
+
+		file:registerData(self, "header", true)
+		file:registerData(self, "contents")
+	end
+end
+
+function Alloy:saveHeader(file)
+	file:writeInt(self.versions.current)
+	self:register(file)
+	file:writeRegister()
+	file:writeInstance(self)
+	file:writeData(self, "header", true)
+
+	if self:getParameters() then
+		file:writeBoolean(true)
+		serialization.saveParameters(file, self:getParameters(), self)
+	else
+		file:writeBoolean(false)
+	end
+end
+
+function Alloy:saveContents(file)
+	file:writeData(self, "contents")
+end
+
+function Alloy:saveEdit(file, version)
+	if self.graph then
+		file:writeBoolean(true)
+		self.graph:save(file)
+	else
+		file:writeBoolean(false)
+	end
+end
+
+function Alloy:save(file)
+	self:saveHeader(file)
+	self:saveContents(file)
+	self:saveEdit(file)
+
+	return true
+end
+
+function Alloy:loadHeader(file)
+	local version = file:readInt()
+
+	file:readRegister()
+
+	local self = file:readReference() or instance(self)
+
+	file:readData(self)
+
+	local hasParams = file:readBoolean()
+
+	if hasParams then
+		serialization.loadParameters(file, self, self:getParameters())
+	end
+
+	return self, version
+end
+
+function Alloy:loadContents(file, version, yieldStart)
+	self:initGraphTier()
+	file:readData(self)
+	self:setType(self.type)
+end
+
+function Alloy:loadEdit(file, version, yieldStart)
+	local hasGraph = file:readBoolean()
+
+	if hasGraph then
+		self.graph = Layer:load(file, self, yieldStart)
+
+		self.graph:verifyNodes()
+	end
+
+	self:loadChildTree()
+end
+
+function Alloy:load(file, yieldStart)
+	local u, version = self:loadHeader(file)
+
+	u:loadFolderContents(yieldStart)
+	u:loadContents(file, version, yieldStart)
+
+	return u, "OK"
+end
+
+function Alloy:loadFolderContents(yieldStart, edit)
+end
+
+function Alloy:onLoaded()
+	if self.graph then
+		self:initGraph()
+	end
+
+	if self:localizeExists("description") then
+		self.description = self:localize("description")
+	end
+end
+
+function Alloy:refresh()
+	self:loadFolderContents(nil, true)
+end
+
+function Alloy:getLocalizedName()
+	return self.displayName or self.name
+end
+
+function Alloy:getBooker()
+	return self
+end
diff -X exclude -ruN daisyMoon/defaultConfigs.lua moddedDaisyMoon/defaultConfigs.lua
--- daisyMoon/defaultConfigs.lua	2023-11-30 02:17:06.624108474 +0100
+++ moddedDaisyMoon/defaultConfigs.lua	2023-12-06 20:40:43.495099596 +0100
@@ -128,6 +128,7 @@
 	spriteListPath = "NIL",
 	team = "NIL",
 	mod = "NIL",
+	alloy = "NIL",
 	slot = "",
 	talk = "NIL",
 	account = "NIL"
diff -X exclude -ruN daisyMoon/def_logic.lua moddedDaisyMoon/def_logic.lua
--- daisyMoon/def_logic.lua	2023-11-30 02:17:06.629108459 +0100
+++ moddedDaisyMoon/def_logic.lua	2023-12-06 20:40:43.495099596 +0100
@@ -60,9 +60,10 @@
 					end
 				end
 			else
-				assert(def[method_key] == nil, method_key, "for logic", logic, "already preset in def", key)
+				--assert(def[method_key] == nil, method_key, "for logic", logic, "already preset in def", key)
 			end
 		else
+			-- skipping this assert and just applying the check for the following calls crashes the game eveytime?
 			assert(def[method_key] == nil, method_key, "for logic", logic, "already preset in def", key)
 			
 			def[method_key] = method
diff -X exclude -ruN daisyMoon/editDialogs.lua moddedDaisyMoon/editDialogs.lua
--- daisyMoon/editDialogs.lua	2023-11-30 02:17:06.614108503 +0100
+++ moddedDaisyMoon/editDialogs.lua	2023-12-06 20:40:43.495099596 +0100
@@ -5688,3 +5688,512 @@
 	dialog:sortRiver(true, 5, 5)
 	dialog:centerOnParent()
 end
+
+function editDialogs.createAlloyItemExplorer(title)
+	local dialog = gui.createComponent("dframe")
+
+	function dialog:onHide()
+		editDialogs.clearCurrent()
+	end
+
+	local itemName = ""
+	local tagName = ""
+
+-- not the best implementation but it works for now
+	function dialog:renderItem()
+		local item = ITEMS[itemName]
+		local dx, dy, dw, dh = self:getRelativePosition()
+		local ix, iy, iw, ih = dx + dw, dy, dh / 2, dh
+
+		if item then
+			video.renderSpriteRectangle(ix - 1, iy, iw + 1, ih, 255, 219, 221, 222)
+			video.renderSpriteRectangle(ix, iy + 1, iw - 1, ih - 2, 255, 80, 90, 100)
+			if item.iconSprite then
+				video.renderSpriteState(item.iconSprite, ix + iw / 2, iy + iw / 2, 1, 0, 255, 255, 255, 255, false)
+			end
+			if item.sprite then
+				video.renderSpriteState(item.sprite, ix + iw / 2, iy + iw / 2 + iw, 1, 0, 255, 255, 255, 255, false)
+			end
+			if item.customSprites then
+				for name, sprite in pairs(item.customSprites) do
+					if name == "pieces" then
+						for pName, pSprite in pairs(sprite) do
+							video.renderSpriteState(pSprite, ix + iw / 2, iy + iw / 2 + iw, 1, 0, 255, 255, 255, 255, false)
+						end
+					else
+						video.renderSpriteState(sprite, ix + iw / 2, iy + iw / 2 + iw, 1, 0, 255, 255, 255, 255, false)
+					end
+				end
+			end
+		end
+	end
+
+	dialog:setText(WChar(title))
+	dialog.layout = gui.createComponent("layout", dialog)
+
+	local itemList = gui.createComponent("listbox", dialog)
+	itemList:setRelativePosition(5, 50, 200, 200)
+
+	local itemNames = table.copy(ALLOY_ITEM_NAMES)
+	table.sort(itemNames)
+	for i = 1, #itemNames do
+  	itemList:addTextItem(WChar(itemNames[i]))
+  end
+	itemList:setSelected(0)
+	itemList:setSelectable(true)
+
+	local tagList = gui.createComponent("listbox", dialog)
+	tagList:setRelativePosition(210, 50, 150, 200)
+
+	local dataList = gui.createComponent("listbox", dialog)
+	dataList:setRelativePosition(365, 50, 350, 200)
+
+	local dataField = gui.createComponent("editbox", dialog)
+	dataField:setRelativePosition(365, 25, 340, 20)
+
+	function dataField:update()
+  	local value = ALLOY_ITEMS_CLONE[itemName][tagName]
+		local type = type(value)
+		self:setText(WChar(type))
+		dataList:clear()
+		if type == "number" then
+			dataList:addTextItem(WChar(value))
+		elseif type == "string" then
+			dataList:addTextItem(WChar('"' .. value .. '"'))
+		elseif type == "boolean" then
+			if value then
+				dataList:addTextItem(WChar("True"))
+			else
+				dataList:addTextItem(WChar("False"))
+			end
+		elseif type == "table" then
+			for nKey, nValue in pairs(AlloyParseTable(value)) do
+				dataList:addTextItem(WChar(nValue))
+			end
+		elseif type == "function" then
+			for nKey, nValue in pairs(AlloyGetDebugFunction(value, 70)) do
+				dataList:addTextItem(WChar(nValue))
+			end
+		else
+			dataList:addTextItem(WChar("Unrecognised data structure"))
+		end
+  end
+
+	local itemField = gui.createComponent("editbox", dialog)
+	itemField:setSelectable(true)
+	itemField:setRelativePosition(5, 25, 190, 20)
+
+	function itemField:onApply()
+		local name = self:getText():toString()
+		itemName = name
+		tagList:update()
+  end
+
+	function itemList:onRepeat()
+		local index = self:getSelected()
+		local name = self:getTextItem(index):toString()
+
+		itemField:setText(WChar(name))
+		itemName = name
+		tagList:update()
+	end
+
+	local tagField = gui.createComponent("editbox", dialog)
+	tagField:setSelectable(true)
+	tagField:setRelativePosition(210, 25, 140, 20)
+
+	function tagField:onApply()
+		local name = self:getText():toString()
+		tagName = name
+		dataField:update()
+  end
+
+	function tagList:update()
+		self:clear()
+		tagField:setText(WChar(""))
+		local item = itemName
+		if item then
+  		local itemTags = ALLOY_ITEMS_CLONE[item]
+			if itemTags then
+				local tags = {}
+    		local i = 1
+				for key, value in pairs(itemTags) do
+					tags[i] = key
+					i = i+1
+      	end
+				table.sort(tags)
+				for key, value in pairs(tags) do
+      		self:addTextItem(WChar(value))
+        end
+    	end
+		end
+		self:setSelected(0)
+		self:setSelectable(self:getItemCount() > 0)
+  end
+
+	function tagList:onRepeat()
+		local index = self:getSelected()
+		local name = self:getTextItem(index):toString()
+
+		tagField:setText(WChar(name))
+		tagName = name
+		dataField:update()
+	end
+
+	dialog:setRelativePosition(0, 0, 710, 260)
+	dialog:centerOnParent()
+
+	tagList:update()
+
+	return dialog
+end
+
+function editDialogs.createAlloyEditItemDialog(title, item, callbackObject)
+	local dialog = gui.createComponent("dframe")
+
+	function dialog:onHide()
+		editDialogs.clearCurrent()
+	end
+
+	dialog:setText(WChar(title))
+	dialog.layout = gui.createComponent("layout", dialog)
+	dialog.item = table.copy(item or {})
+	local selectedTagName = ""
+
+	local nameLabel = gui.createComponent("label", dialog)
+	nameLabel:setRelativePosition(210, 35, 150, 20)
+
+	function nameLabel:update()
+		if dialog.item.name == "" then
+			self:setText(WChar("No Item selected!"))
+		else
+			self:setText(WChar(dialog.item.name))
+		end
+	end
+
+	local inheritLabel = gui.createComponent("label", dialog)
+	inheritLabel:setRelativePosition(210, 23, 150, 20)
+
+	function inheritLabel:update()
+  	if dialog.item.inherits == "" then
+			self:setText(WChar("Doesn't inherit data!"))
+		else
+			self:setText(WChar(dialog.item.inherits))
+		end
+  end
+
+	local nameField = gui.createComponent("editbox", dialog)
+	nameField:setSelectable(true)
+	nameField:setRelativePosition(5, 25, 190, 20)
+
+	local tagField = gui.createComponent("editbox", dialog)
+	tagField:setSelectable(true)
+	tagField:setRelativePosition(365, 255, 140, 20)
+
+	local nameList = gui.createComponent("listbox", dialog)
+	nameList:setSelectable(true)
+	nameList:setRelativePosition(5, 50, 200, 200)
+
+	local itemNames = table.copy(ALLOY_ITEM_NAMES)
+	table.sort(itemNames)
+	for i = 1, #itemNames do
+  	nameList:addTextItem(WChar(itemNames[i]))
+  end
+
+	local itemTagList = gui.createComponent("listbox", dialog)
+	itemTagList:setRelativePosition(210, 50, 150, 200)
+
+	local tagNameLabel = gui.createComponent("label", dialog)
+	tagNameLabel:setRelativePosition(170, 280, 335, 20)
+
+	function tagNameLabel:update()
+		local tag = dialog.item.tags[selectedTagName]
+		if tag then
+			self:setText(WChar(dialog.item.name .. "." .. selectedTagName))
+		else
+			self:setText(WChar("No tag selected!"))
+		end
+  end
+
+	local tagBoolList = gui.createComponent("radiolist", dialog)
+	tagBoolList:setRelativePosition(105, 260, 50, 20)
+	tagBoolList:addRadioButton(WChar("true"))
+	tagBoolList:addRadioButton(WChar("False"))
+
+	function tagBoolList:update()
+		self:setVisible(false)
+		local tag = dialog.item.tags[selectedTagName]
+		if tag then
+			local type = tag.type
+			local value = tag.value
+			if type == "boolean" then
+				self:setVisible(true)
+				self:setSelection(value and 0 or 1)
+			end
+  	end
+  end
+
+	function tagBoolList:onChange()
+		local tag = dialog.item.tags[selectedTagName]
+		if tag then
+			local type = tag.type
+			if type == "boolean" then
+				tag.value = self:getSelection() == 1
+			else
+				print("Set tag bool value on non bool tag!")
+			end
+		end
+	end
+
+	local tagValueField = gui.createComponent("editbox", dialog)
+	tagValueField:setRelativePosition(110, 295, 395, 20)
+
+	function tagValueField:update()
+		self:setVisible(true)
+		local tag = dialog.item.tags[selectedTagName]
+		if tag then
+			local tType = tag.type
+			local tValue = tag.value
+			if tType == "number" then
+				if tValue then
+					self:setText(WChar(tValue))
+				end
+			elseif tType == "string" then
+				if tValue then
+					self:setText(WChar(tValue))
+				end
+			elseif tType == "table" then
+				if type(tValue) == "string" then
+					self:setText(WChar(tValue))
+				else
+					self:setText(WChar("Unchanged"))
+				end
+			elseif tType == "function" then
+				if type(tValue) == "string" then
+					self:setText(WChar(tValue))
+				else
+					self:setText(WChar("Unchanged"))
+				end
+			else
+				self:setText(WChar(""))
+				self:setVisible(false)
+			end
+  	end
+  end
+
+	function tagValueField:onApply()
+		local tag = dialog.item.tags[selectedTagName]
+		if tag then
+			local type = tag.type
+			local value = self:getText():toString()
+			if type == "number" then
+				local numValue = tonumber(value)
+				if numValue then
+					tag.value = numValue
+				else
+					print("Unable to set non number value to tag with number type!")
+				end
+			elseif type == "string" then
+				tag.value = value
+			elseif type == "boolean" then
+				print("Set arbitrary tag value on bool tag!")
+			elseif type == "table" then
+				if value ~= "Unchanged" then
+					tag.value = value
+				end
+			elseif type == "function" then
+				if value ~= "Unchanged" then
+					tag.value = value
+				end
+			else
+				print("Set tag value on unrecognised tag type!")
+			end
+		end
+  end
+
+	local tagTypeList = gui.createComponent("listbox", dialog)
+	tagTypeList:setRelativePosition(5, 255, 100, 60)
+	tagTypeList:setSelectable(true)
+	tagTypeList:addTextItem(WChar("number"))
+	tagTypeList:addTextItem(WChar("string"))
+	tagTypeList:addTextItem(WChar("boolean"))
+	tagTypeList:addTextItem(WChar("table"))
+	tagTypeList:addTextItem(WChar("function"))
+
+	function tagTypeList:update()
+		local tag = dialog.item.tags[selectedTagName]
+		if tag then
+			local type = tag.type
+			if type == "number" then
+    		self:setSelected(0)
+			elseif type == "string" then
+				self:setSelected(1)
+			elseif type == "boolean" then
+				self:setSelected(2)
+			elseif type == "table" then
+				self:setSelected(3)
+			elseif type == "function" then
+				self:setSelected(4)
+    	end
+		end
+	end
+
+	function tagTypeList:onRepeat()
+		local tag = dialog.item.tags[selectedTagName]
+		local index = self:getSelected()
+		local type = self:getTextItem(index):toString()
+		if tag then
+			if tag.type ~= type then
+				tag.type = type
+				tag.value = nil
+			end
+		end
+		tagValueField:update()
+		tagBoolList:update()
+	end
+
+	function itemTagList:onChange()
+		local index = self:getSelected()
+		local name = self:getTextItem(index):toString()
+
+		selectedTagName = name
+		tagValueField:update()
+		tagNameLabel:update()
+		tagTypeList:update()
+		tagBoolList:update()
+  end
+
+	function itemTagList:update()
+		self:clear()
+		if dialog.item then
+  		local itemTags = dialog.item.tags
+			if itemTags then
+				local tags = {}
+    		local i = 1
+				for key, value in pairs(itemTags) do
+					tags[i] = key
+					i = i+1
+      	end
+				table.sort(tags)
+				for key, value in pairs(tags) do
+      		self:addTextItem(WChar(value))
+        end
+    	end
+		end
+		self:setSelected(0)
+		self:setSelectable(self:getItemCount() > 0)
+
+		selectedTagName = ""
+		tagValueField:update()
+		tagNameLabel:update()
+		tagTypeList:update()
+		tagBoolList:update()
+  end
+
+	local tagList = gui.createComponent("listbox", dialog)
+	tagList:setRelativePosition(365, 50, 150, 200)
+
+	function tagList:update()
+		self:clear()
+		local tags = {}
+		local i = 1
+		for key, value in pairs(ALLOY_ITEM_ATTRIBUTES) do
+			if dialog.item.tags[key] == nil then
+				tags[i] = key
+				i = i+1
+			end
+		end
+		table.sort(tags)
+		for key, value in pairs(tags) do
+				self:addTextItem(WChar(value))
+    end
+		self:setSelected(0)
+		self:setSelectable(self:getItemCount() > 0)
+  end
+
+	function tagList:onRepeat()
+		local index = self:getSelected()
+		local name = self:getTextItem(index):toString()
+		if not dialog.item.tags[name] then
+			dialog.item.tags[name] = {type = "string", value = ""}
+		end
+		self:update()
+		itemTagList:update()
+	end
+
+	function itemTagList:onRepeat()
+		local index = self:getSelected()
+		local name = self:getTextItem(index):toString()
+		dialog.item.tags[name] = nil
+		self:update()
+		tagList:update()
+	end
+	
+	local function loadItemData(itemName)
+  	local itemTags = ALLOY_ITEMS_CLONE[itemName]
+		if itemTags then
+			dialog.item.inherits = ""
+			dialog.item.tags = {}
+  		for key, value in pairs(itemTags) do
+     		dialog.item.tags[key] = {type = type(value), value = value}
+      end
+    end
+		return itemTags ~= nil
+	end
+
+	function nameField:onApply()
+		local name = self:getText():toString()
+		if not loadItemData(name) then
+			dialog.item.inherits = dialog.item.name
+		end
+  	dialog.item.name = name
+		inheritLabel:update()
+		nameLabel:update()
+		itemTagList:update()
+		tagList:update()
+  end
+
+	function tagField:onApply()
+		local name = self:getText():toString()
+		if not dialog.item.tags[name] then
+			dialog.item.tags[name] = {type = "string", value = ""}
+		end
+		itemTagList:update()
+		tagList:update()
+	end
+	
+	function nameList:onRepeat()
+		local index = self:getSelected()
+		local name = self:getTextItem(index):toString()
+		nameField:setText(WChar(name))
+		if not loadItemData(name) then
+			dialog.item.inherits = dialog.item.name
+		end
+		dialog.item.name = name
+		inheritLabel:update()
+		nameLabel:update()
+		itemTagList:update()
+		tagList:update()
+  end
+
+	local applyButton = gui.createComponent("button", dialog)
+	
+	function applyButton:onClick()
+		if dialog.item.name == "" or string.find(dialog.item.name, " ")  then
+			return nil
+		end
+		callbackObject:updateDefinition(dialog.item)
+	end
+
+	applyButton:setText(WChar("Apply"))
+	applyButton:setRelativePosition(385, 25, 50, 20)
+
+	dialog:setRelativePosition(0, 0, 510, 320)
+	dialog:centerOnParent()
+
+
+	inheritLabel:update()
+	nameLabel:update()
+	itemTagList:update()
+	tagList:update()
+end
diff -X exclude -ruN daisyMoon/editMenuBar.lua moddedDaisyMoon/editMenuBar.lua
--- daisyMoon/editMenuBar.lua	2023-11-30 02:17:06.630108456 +0100
+++ moddedDaisyMoon/editMenuBar.lua	2023-12-06 20:40:43.495099596 +0100
@@ -2436,7 +2436,142 @@
 		}
 	}
 }
+-- alloy entry tree
+TREES.alloy = {
+	{
+		name = "File",
+		options = {
+			{},
+			{
+				shortcut = 78,
+				name = "New (Ctrl+N)",
+				shortcutOperator = 17,
+				action = function(b)
+					resources.new("alloy", b.state)
+				end
+			},
+			{
+				shortcut = 79,
+				name = "Open (Ctrl+O)",
+				shortcutOperator = 17,
+				action = function(b)
+					resources.open("alloy", b.state)
+				end
+			},
+			{},
+			{
+				shortcut = 83,
+				name = "Save (Ctrl+S)",
+				shortcutOperator = 17,
+				action = function(b)
+					local ok, msg = resources.save("alloy", b.state.alloy, b.state, true)
 
+					if msg then
+						b.state:print(msg)
+					end
+				end
+			},
+			{
+				name = "Save As...",
+				action = function(b)
+					if b.state.alloy then
+						resources.saveAs("alloy", b.state.alloy, b.state, true)
+
+					return true
+					else
+						b.state:print("No Alloy to save")
+						return false
+					end
+				end
+			},
+			{},
+			{
+				shortcut = 112,
+				name = "Close Editor (F1)",
+				action = function(b)
+					app.switchMode("devmenu")
+				end
+			},
+			{},
+			{
+				name = "Exit",
+				action = function(b)
+					daisy.exitGame()
+				end
+			}
+		}
+	},
+	{
+		name = "Edit",
+		options = {
+			{},
+			{
+				shortcut = 90,
+				name = "Undo (Ctrl+Z)",
+				shortcutOperator = 17,
+				action = function(b)
+					return b.state:undoBack()
+				end
+			},
+			{
+				shortcut = 89,
+				name = "Redo (Ctrl+Y)",
+				shortcutOperator = 17,
+				action = function(b)
+					return b.state:undoForward()
+				end
+			},
+		}
+	},
+	{
+		name = "Tools",
+		options = {
+			{},
+			-- with the new system for item browsing and indexing reloading data isn't required
+			--{
+			--	shortcut = 82,
+			--	name = "Reload data (Shift+R)",
+			--	shortcutOperator = 16,
+			--	action = function (b)
+      --  	UpdateAlloyItemData(ALLOY_ITEMS_CLONE)
+      --  end
+			--},
+			--{
+			--	shortcut = 76,
+			--	name = "Loaded data (Shift+L)",
+			--	shortcutOperator = 16,
+			--	action = function (b)
+      --  	UpdateAlloyItemData(ITEMS)
+      --  end
+			--},
+			--{},
+			{
+				shortcut = 70,
+				name = "Force load (Caps+F)",
+				shortcutOperator = 20,
+				action = function (b)
+					local alloy = b.state.alloy
+					alloy:moduleLoad()
+					local name = alloy:getLocalizedName()
+					if name == "" then
+						name = "selected alloy"
+					end
+					print("Forcfully loaded " .. name .. " !")
+        end
+			},
+			{},
+			{
+				shortcut = 73,
+				name = "Item explorer (Shift+I)",
+				shortcutOperator = 16,
+				action = function(b)
+        	RegisterAlloyItemExplorer(_editDialogs.createAlloyItemExplorer("Item explorer"))
+        end
+			}
+		}
+	}
+}
+-- end of alloy editor tree
 local mods_menu = {
 	name = "Mods",
 	options = {
@@ -2612,7 +2747,16 @@
 					app.switchMode("talk")
 				end
 			},
-			{},
+			{}, -- custom menus
+			{
+				shortcut = 114,
+				name = "Alloy Editor (CTRL+F3)",
+				shortcutOperator = 17,
+				action = function (b)
+        	app.switchMode("alloy")
+        end
+			},
+			{}, -- end of custom menus
 			{
 				name = "Exit",
 				action = function(b)
diff -X exclude -ruN daisyMoon/gameDependencies.lua moddedDaisyMoon/gameDependencies.lua
--- daisyMoon/gameDependencies.lua	2023-11-30 02:17:06.625108471 +0100
+++ moddedDaisyMoon/gameDependencies.lua	2023-12-06 20:40:43.497099592 +0100
@@ -174,3 +174,4 @@
 dofile("sorting.lua")
 dofile("actionDefinitions.lua")
 dofile("mods.lua")
+dofile("alloyDependencies.lua")
diff -X exclude -ruN daisyMoon/game.lua moddedDaisyMoon/game.lua
--- daisyMoon/game.lua	2023-11-30 02:17:06.613108506 +0100
+++ moddedDaisyMoon/game.lua	2023-12-06 20:40:43.497099592 +0100
@@ -52,6 +52,7 @@
 	ARTICLES[Actor.getArticleId(index)] = true
 end
 
+-- strange may have to be reloaded
 for index, item in pairs(ITEMS) do
 	ARTICLES[Item.getArticleId(index)] = true
 end
diff -X exclude -ruN daisyMoon/graphNode.lua moddedDaisyMoon/graphNode.lua
--- daisyMoon/graphNode.lua	2023-11-30 02:17:06.624108474 +0100
+++ moddedDaisyMoon/graphNode.lua	2023-12-06 20:40:43.497099592 +0100
@@ -110,6 +110,13 @@
 		}
 	}
 }
+GRAPH_NODES.alloy = {
+	class = "Alloy",
+	icon = "",
+	resource = true,
+	children = {},
+	lists = {}
+}
 GRAPH_NODES.adventure = {
 	class = "Adventure",
 	icon = "iconAdventure",
Binary files daisyMoon/info.pak.disabled and moddedDaisyMoon/info.pak.disabled differ
diff -X exclude -ruN daisyMoon/items.lua moddedDaisyMoon/items.lua
--- daisyMoon/items.lua	2023-11-30 02:17:06.618108491 +0100
+++ moddedDaisyMoon/items.lua	2023-12-06 20:40:43.499099588 +0100
@@ -4,8 +4,8 @@
 
 local COMP = dofile("item_comp.lua")
 local BT_MUL = 1
-local soundToVisFactor = 0.0022222222222222222
-local recoilToVisFactor = 0.4
+SoundToVisFactor = 0.0022222222222222222
+RecoilToVisFactor = 0.4
 local math_length = math.length
 local math_approachAngle = math.approachAngle
 local math_pi = math.pi
@@ -40,60 +40,60 @@
 	local angle = angle or fireAngle
 	local scope = self.upgrades and self.upgrades.scope
 	local bulletSpeed = self.bulletSpeed
-	
+
 	if scope then
 		bulletSpeed = scope.def.modifyBulletSpeed(scope, bulletSpeed)
 	end
-	
+
 	if def.newtonian then
 		obj = actor:shootNewtonianBullet(x, y, fireAngle, bulletSpeed, self.bullet, self, def.newtonianFactor or 1)
 	else
 		obj = actor:shootProjectedBullet(x, y, fireAngle, bulletSpeed, self.bullet, self)
 	end
-	
+
 	if obj then
 		if def.aimUp then
 			obj.targetAngle = angle
 		end
-		
+
 		if def.bulletBonusTime then
 			obj:setTime(-self.def.bulletBonusTime)
 		end
-		
+
 		if scope then
 			scope.def.onUsedMethod(scope, actor, obj, self)
 		end
-		
+
 		local spec = self:getSpecial()
-		
+
 		if spec then
 			obj:applySpecial(spec, actor, self)
 		end
 	end
-	
+
 	return obj
 end
 
 function METH:genericWeaponFeedback(actor, x, y, angle)
 	if actor.map then
 		local muz = self:getMuzzleFx()
-		
+
 		if muz then
 			self:createMuzzleFx(actor, x, y, muz, 1, angle)
 		end
-		
+
 		if self.def.muzzleMethod then
 			self.def.muzzleMethod(self, actor, angle, x, y)
 		end
-		
+
 		actor:emitSoundAt(self:getUseSound(), x, y, 1, self:getUseSoundMod() * (self.soundMod or 1), self:getSoundRange())
-		
+
 		self.soundMod = nil
 	end
-	
+
 	local rec = self:getRecoilAmount()
-	
-	actor:setStealthPenalty(self:getSoundRange() * soundToVisFactor + rec * recoilToVisFactor)
+
+	actor:setStealthPenalty(self:getSoundRange() * SoundToVisFactor + rec * RecoilToVisFactor)
 	self:applyRandomRecoil(actor, rec)
 	self:applyRecoilFatigue(self:getRecoilFatigue())
 end
@@ -104,7 +104,7 @@
 
 function METH:genericFailUse(actor)
 	self:failedUse(actor)
-	
+
 	return true
 end
 
@@ -112,40 +112,40 @@
 	local x, y = actor:getSafeWeaponXY()
 	local fireAngle = angle
 	local aimUp = self.def.aimUp
-	
+
 	if aimUp then
 		fireAngle = math_approachAngle(angle, -math_pi * 0.5, aimUp)
 	end
-	
+
 	local bullets = self:getBullets()
-	
+
 	if bullets > 1 then
 		for i = 1, bullets do
 			local fireAngle = fireAngle + (i - (bullets + 1) % 2 * 0.5 - math_ceil(bullets / 2)) * self:getBulletSpread()
-			
+
 			METH.genericWeaponShootBullet(self, actor, x, y, fireAngle, angle)
 		end
 	else
 		METH.genericWeaponShootBullet(self, actor, x, y, fireAngle, angle)
 	end
-	
+
 	METH.genericWeaponFeedback(self, actor, x, y, angle)
-	
+
 	local gl = self:getGriplessAmount()
-	
+
 	if gl > 0 then
 		actor:gripless(gl)
 		actor:airGripless(gl)
 	end
-	
+
 	local pb = self:getPushback()
-	
+
 	if pb > 0 then
 		actor:applyItemPushback(angle + math_pi, pb)
 	end
-	
+
 	self:useAmmo(actor, 1)
-	
+
 	return true
 end
 
@@ -153,14 +153,14 @@
 	local x, y = actor:getSafeWeaponXY()
 	local fireAngle = angle
 	local obj = METH.genericWeaponShootBullet(self, actor, x, y, fireAngle, angle)
-	
+
 	if obj then
 		obj:setPower(self:getPower())
 	end
-	
+
 	METH.genericWeaponFeedback(self, actor, x, y, angle)
 	self:useAmmo(actor, 1)
-	
+
 	return true
 end
 
@@ -218,24 +218,24 @@
 
 local function multiAmmo(item, inventory, object, actor)
 	local addItem = Item:new(item.def.ammo)
-	
+
 	addItem:setStack(item.def.ammoAmount)
 	inventory:addToOwner(addItem)
-	
+
 	return true
 end
 
 local function addUpgrade(to, from)
 	local def = ITEMS[to]
-	
+
 	if not def.upgradeTypes then
 		def.upgradeTypes = {}
 	end
-	
+
 	def.upgradable = true
-	
+
 	table.insert(def.upgradeTypes, from)
-	
+
 	if from.ammoCapacity then
 		def.maxAmmoUpgrade = (def.maxAmmoUpgrade or 0) + from.ammoCapacity
 	end
@@ -247,11 +247,11 @@
 
 local function genericRenderUpgrades(self, x, y, angle, r, g, b, facingRight, glow)
 	video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-	
+
 	if self.upgrades then
 		for index, upgrade in pairs(self.upgrades) do
 			local ren = upgrade.def.renderMethod
-			
+
 			if ren then
 				ren(upgrade, x, y, angle, r, g, b, facingRight, glow)
 			end
@@ -282,7 +282,7 @@
 function METH:renderInclusiveGenericLevelUpgrade(x, y, angle, r, g, b, facingRight, glow)
 	local cusprites = self.def.customSprites
 	local cunames = self.def.customSpriteNames
-	
+
 	for i = 1, self.level do
 		video.renderSpriteState(cusprites[cunames[i]], x, y, 1, angle, 255, r, g, b, not facingRight)
 	end
@@ -290,15 +290,19 @@
 
 function METH:renderShinyItem(x, y, angle, r, g, b, facingRight, glow)
 	video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-	
-	local nx, ny = x + math_cos(angle + self.def.shineAngle) * self.def.shineOffset, y + math_sin(angle + self.def.shineAngle) * self.def.shineOffset
-	
-	video.renderSpriteState(self.def.customSprites.shine, nx, ny, 1 - math_safeRandom() * 0.08, math_pi * 0.25, math_abs(math_cos(angle + math_safeRandom() * 0.7)) * 255, r, g, b, not facingRight)
+
+	local nx, ny = x + math_cos(angle + self.def.shineAngle) * self.def.shineOffset,
+			y + math_sin(angle + self.def.shineAngle) * self.def.shineOffset
+
+	video.renderSpriteState(self.def.customSprites.shine, nx, ny, 1 - math_safeRandom() * 0.08, math_pi * 0.25,
+		math_abs(math_cos(angle + math_safeRandom() * 0.7)) * 255, r, g, b, not facingRight)
 end
 
 function METH:renderItemWithGlow(x, y, angle, r, g, b, facingRight, glow)
 	video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-	video.renderSpriteState(self.def.customSprites.glow, x, y, 1, angle, math_abs(math_cos(_time * math_pi + math_pi * 2 * math_seededRandomNumber(self.countId))) * 255, 255, 255, 255, not facingRight)
+	video.renderSpriteState(self.def.customSprites.glow, x, y, 1, angle,
+		math_abs(math_cos(_time * math_pi + math_pi * 2 * math_seededRandomNumber(self.countId))) * 255, 255, 255, 255,
+		not facingRight)
 end
 
 function METH:feedbackItemRender(x, y, angle, r, g, b, facingRight, glow)
@@ -312,7 +316,7 @@
 
 function METH:renderGenericUpgradableItem(x, y, angle, r, g, b, facingRight, glow)
 	video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-	
+
 	for index, upgrade in pairs(self.upgrades) do
 		upgrade.def.renderMethod(upgrade, x, y, angle, r, g, b, facingRight, glow)
 	end
@@ -333,10 +337,10 @@
 function METH:addAmmoForItem(inventory, object, actor, ammoType, item)
 	if self.def.ammoAmounts[ammoType] then
 		local ammo = Item:new(ammoType)
-		
+
 		ammo:setStack(self.def.ammoAmounts[ammoType] * self:getStack(), item and item:getAmmoUse())
 		inventory:addToOwner(ammo, object)
-		
+
 		return true
 	end
 end
@@ -348,47 +352,47 @@
 		if object then
 			local currentItem = inventory:getItem()
 			local currentAmmo = currentItem and currentItem:getAmmoType()
-			
+
 			if currentItem and not currentItem:isFragile() and METH.canAddAmmoForItem(self, currentAmmo) then
 				return true
 			end
 		end
-		
+
 		local lowestAmmoType = inventory:getLowestUsedAmmoType(self.def.ammoAmounts)
-		
+
 		if lowestAmmoType and METH.canAddAmmoForItem(self, lowestAmmoType) then
 			return true
 		end
 	end
-	
+
 	return false
 end
 
 function METH:addAmmoSpecial(inventory, object, actor)
 	local anyFound = false
-	
+
 	if self.ammo and self.ammoType then
 		local ammo = Item:new(self.ammoType)
-		
+
 		ammo:setStack(self.ammo)
 		inventory:addToOwner(ammo, object)
-		
+
 		anyFound = true
 	else
 		local blockedTypes = {}
 		local times = self.def.addTimes
 		local currentItem = inventory:getItem()
 		local currentAmmo = currentItem and currentItem:getAmmoType()
-		
+
 		if currentItem and not currentItem:isFragile() and METH.addAmmoForItem(self, inventory, object, actor, currentAmmo, currentItem) then
 			times = times - 1
 			anyFound = true
 		end
-		
+
 		if times >= 1 then
 			for i = 1, times do
 				local lowestAmmoType, lowestAmmoWeapon = inventory:getLowestUsedAmmoType(self.def.ammoAmounts, blockedTypes)
-				
+
 				if lowestAmmoType and METH.addAmmoForItem(self, inventory, object, actor, lowestAmmoType, lowestAmmoWeapon) then
 					blockedTypes[lowestAmmoType] = true
 					anyFound = true
@@ -396,12 +400,12 @@
 			end
 		end
 	end
-	
+
 	if anyFound then
 		if not inventory.transfering and actor and actor.map then
 			actor:emitSound(self.def.pickupSound or "pickup", 1 * actor:getActionsSoundLevel(), 1)
 		end
-		
+
 		return true
 	else
 		return false, "noweapons"
@@ -425,7 +429,7 @@
 function METH:genericProtectionRuntime()
 	self.feedback = 0
 	self.healthFactor = self.health / self.def.health
-	
+
 	if self.def.customSpriteNames and self.def.customSpriteNames.pieces then
 		self.totalPieces = self.def.customSpriteNames.pieces.sprites
 	end
@@ -433,16 +437,16 @@
 
 function METH:genericProtectionInit()
 	local maxHealth = self.def.health
-	
+
 	self:setHealth(self.health or maxHealth)
-	
+
 	self.feedback = 0
 end
 
 function METH:genericProtectionFeedback(actor, time)
 	if self.feedback > 0 then
 		self.feedback = self.feedback - time / (self.def.feedbackTime or 0.33)
-		
+
 		if self.feedback <= 0 then
 			self.feedback = 0
 		end
@@ -457,12 +461,12 @@
 	if self.feedback > 0 then
 		r, g, b = colors.fadeVariables(r, g, b, COLORS.red, self.feedback)
 	end
-	
+
 	if self.healthFactor < 1 then
 		video.renderSpriteState(self.def.customSprites.base, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		local pieces = self.def.customSprites.pieces
-		
+
 		for i = 1, math_round(self.totalPieces * self.healthFactor) do
 			video.renderSpriteState(pieces[i], x, y, 1, angle, 255, r, g, b, not facingRight)
 		end
@@ -484,7 +488,7 @@
 		local x = impact.x or impact.owner.x
 		local x, y = x, impact.y or impact.owner.y
 		local rel_height = actor:relativeHeightDistance(x, y, self.def.node)
-		
+
 		if (not self.def.protectionLower or self.def.protectionLower and rel_height > self.def.protectionLower) and (not self.def.protectionHigher or rel_height < self.def.protectionHigher) and (not self.def.protectionForwards or self.def.protectionForwards and actor:isPointWithinFacingArc(x, y)) and (not self.def.protectionBackwards or self.def.protectionBackwards and not actor:isPointWithinFacingArc(x, y)) and self.health > 0 then
 			local startHealth = self.health
 			local armor_damage_factor = attack.armorDamageFactor or 1
@@ -492,15 +496,15 @@
 			local angle = impact.angle or -math_pi * 0.5
 			local wasFactor = self.healthFactor
 			local hit_damage_factor = self.def.hitDamageFactor or 1
-			
+
 			self:hurt(damage * hit_damage_factor, actor, angle, x, y)
 			actor:setItemFeedback(self, 1)
-			
+
 			local impulse = impact.impulse or 0
-			
+
 			if self.def.thorns and attack.thornable and impact.owner and impact.owner._category == "actor" then
 				local thorn_impact = FrameTable.alloc_table()
-				
+
 				thorn_impact.owner = actor
 				thorn_impact.target = impact.owner
 				thorn_impact.x = x
@@ -508,90 +512,92 @@
 				thorn_impact.angle = angle + math_pi
 				thorn_impact.impulse = impulse
 				thorn_impact.damageModifier = damage * self.def.thorns
-				
+
 				impact.owner:hit(thorn_impact, ATTACKS.thorns)
 			end
-			
+
 			if actor.map and RENDERING then
 				if self.health <= 0 then
 					actor:emitSound(self.def.breakSound or "helmetHit", 1, 1, RANGES.long)
 					actor:emitFxAt("bulletHitFlash", x, y)
-					
+
 					local details = _config.graphicsFx
-					
+
 					if details > 0 then
 						for i = 1, (math_random(2) + 3) * details do
 							local fx = actor:emitFxAt("jetBulletSpark", x, y)
-							
-							fx:setSpeed(angle + math_pi + math_random() * 0.5 * math_pi - math_random() * 0.5 * math_pi, math_random(4000))
+
+							fx:setSpeed(angle + math_pi + math_random() * 0.5 * math_pi - math_random() * 0.5 * math_pi,
+								math_random(4000))
 							fx:setAngle(math_random() * math_pi * 2)
 							fx:setTime(math_random() * 0.15)
 						end
-						
+
 						for i = 1, (2 + math_random(4)) * details do
 							local offAng = angle + math_random() * math_pi * 0.3 - math_random() * math_pi * 0.3 + math_pi
 							local obj = actor:emitSparkAt(nil, x, y)
-							
+
 							obj:setSpeed(offAng, impulse * (math_random() * 1 + 1) + 15)
 							obj:addSpeedXY(actor.dx, actor.dy)
 						end
 					end
 				elseif not attack.continous then
 					local responded = false
-					
+
 					if self.totalPieces then
 						local oldTotal = math_round(self.totalPieces * wasFactor)
 						local newTotal = math_round(self.totalPieces * self.healthFactor)
-						
+
 						if oldTotal ~= newTotal then
 							local details = _config.graphicsFx
-							
+
 							if details > 0 then
 								for i = 1, math_random(2) * details do
 									local fx = actor:emitFxAt("jetBulletSpark", x, y)
-									
-									fx:setSpeed(angle + math_pi + math_random() * 0.5 * math_pi - math_random() * 0.5 * math_pi, math_random(300))
+
+									fx:setSpeed(angle + math_pi + math_random() * 0.5 * math_pi - math_random() * 0.5 * math_pi,
+										math_random(300))
 									fx:setAngle(math_random() * math_pi * 2)
 									fx:setTime(math_random() * 1)
 								end
-								
+
 								for i = 1, (1 + math_random(2)) * details do
 									local offAng = angle + math_random() * math_pi * 0.3 - math_random() * math_pi * 0.3 + math_pi
 									local obj = actor:emitSparkAt(nil, x, y)
-									
+
 									obj:setSpeed(offAng, impulse * (math_random() * 0.75 + 0.75) + 5)
 									obj:addSpeedXY(actor.dx, actor.dy)
 								end
 							end
-							
+
 							local spr = self.def.customSprites.pieces[oldTotal]
-							
+
 							if spr and spr >= 0 then
 								local fx = actor:emitDebrisAt(spr, x, y)
-								
+
 								fx:addSpeed(-math_pi * 0.5 + math_randomGaussian() * math_pi * 0.2, math_random() * 7 + 2)
 							end
-							
+
 							actor:emitPpFxAt("deformingHitFlash", x, y)
 							actor:emitSoundAt(self.def.hitSound or "protectionHit", x, y, 1.5, 0.8, RANGES.long)
-							
+
 							responded = true
 						end
 					end
-					
+
 					if not responded then
 						actor:emitSoundAt(self.def.hitSound or "protectionHit", x, y, 1, 1, RANGES.long)
 						actor:emitPpFxAt("bulletHitDamageFlash", x, y)
 					end
 				end
 			end
-			
+
 			local damage_done = (startHealth - self.health) / armor_damage_factor / hit_damage_factor
-			
+
 			if self.def.deflects and actor:deflect(impact, attack) then
 				return true, true, damage_done, 0
 			end
-			
+
 			return true, true, damage_done, 0
 		end
 	end
@@ -607,7 +613,7 @@
 
 local function updateShieldBelt(self, actor, time)
 	self.blinkTimer = self.blinkTimer + time
-	
+
 	if self.frontLayers + self.frontWanted < self.maxFront or self.backLayers + self.backWanted < self.maxBack then
 		if self.chargeTimer < 1 then
 			self.chargeTimer = self.chargeTimer + time / self.def.chargeTime
@@ -615,29 +621,29 @@
 			if self.frontLayers + self.frontWanted < self.maxFront then
 				self.frontWanted = self.frontWanted + 1
 			end
-			
+
 			if self.backLayers + self.backWanted < self.maxBack then
 				self.backWanted = self.backWanted + 1
 			end
-			
+
 			self.chargeTimer = 0
 			self.alpha = 0
 		end
 	end
-	
+
 	if self.frontWanted > 0 then
 		self.frontTimer = self.frontTimer + time / self.def.wantedTime
-		
+
 		if self.frontTimer > 1 then
 			self.frontWanted = self.frontWanted - 1
 			self.frontLayers = math_min(self.maxFront, self.frontLayers + 1)
 			self.frontTimer = 0
 		end
 	end
-	
+
 	if self.backWanted > 0 then
 		self.backTimer = self.backTimer + time / self.def.wantedTime
-		
+
 		if self.backTimer > 1 then
 			self.backWanted = self.backWanted - 1
 			self.backLayers = math_min(self.maxBack, self.backLayers + 1)
@@ -648,7 +654,7 @@
 
 local function updateGenericUpgradableWeapon(self, actor, time)
 	self:updateRecoil(actor, time)
-	
+
 	for index, upg in pairs(self.upgrades) do
 		upg:update(actor, time)
 	end
@@ -656,9 +662,9 @@
 
 local function genericUsedSemi(self, actor, amount)
 	self:applyRecoilFatigue(amount * GLOBAL.item_semi_cooldown_recoil_fatigue_factor)
-	
+
 	local factor = self:getCooldownReductionSemi() / self:getCooldown()
-	
+
 	self:applySemiRecoil(actor, self.missRecoil * GLOBAL.item_semi_cooldown_recoil_factor * self.def.recoilAngle * factor)
 end
 
@@ -666,13 +672,13 @@
 	local deflect = false
 	local fromFront = true
 	local actorAngle = actor:getAbsoluteAngle()
-	
+
 	if math_abs(math_angleDifference(actorAngle, impact.angle)) < math_pi * 0.5 then
 		fromFront = false
 	end
-	
+
 	local damage = attacks.getAttackDamage(attack, impact) * (attack.energyDamageFactor or 1) + (attack.shieldDamage or 0)
-	
+
 	if fromFront then
 		if self.frontLayers > 0 then
 			self.frontLayers = math_max(0, self.frontLayers - damage)
@@ -684,44 +690,44 @@
 		deflect = true
 		self.chargeTimer = 0
 	end
-	
+
 	if deflect then
 		local x = impact.x or impact.owner.x
 		local y = impact.y or impact.owner.y
 		local angle = impact.angle or math.angleBetweenPoints(actor.x, actor.y, x, y)
-		
+
 		self.chargeTimer = 0
-		
+
 		actor:emitSound("shieldHit", 1, 1, 1000)
-		
+
 		local fx = actor:emitFxAt("shieldHitGlow", x, y)
-		
+
 		fx:setAngle(math_pi * math_random() * 2)
-		
+
 		local details = _config.graphicsFx
-		
+
 		if details > 0 then
 			for i = 1, math_ceil(3 * damage * details) do
 				local fx2 = actor:emitFxAt("shieldHitFlare", x, y)
-				
+
 				fx2:setAngle(math_pi * math_random() * 2)
 			end
-			
+
 			for i = 1, math_ceil(10 * damage * details) do
 				local fx2 = actor:emitFxAt("shieldDot", x, y)
-				
+
 				fx2:setSpeed(angle + math_random() * 0.4 - math_random() * 0.4, math_random() * 150 + 60)
 				fx2:setAngle(math_pi * math_random() * 2)
 			end
-			
+
 			for i = 1, math_ceil(10 * damage * details) do
 				local fx2 = actor:emitFxAt("shieldDot", x, y)
-				
+
 				fx2:setSpeed(math_pi + angle + math_random() * 0.4 - math_random() * 0.4, math_random() * 300 + 800)
 				fx2:setAngle(math_pi * math_random() * 2)
 			end
 		end
-		
+
 		return true, true, damage, 0
 	else
 		return false, damage
@@ -751,58 +757,69 @@
 	local warnDist = 12
 	local fTimer = 1 - (1 - self.frontTimer) * (1 - self.frontTimer)
 	local frontMove = fTimer * incrementDist
-	
+
 	if frontMove > 0 then
-		video.renderSpriteState(self.def.customSprites.shield_layer, x + math_cos(actorAngle) * (baseDist * fTimer), y + math_sin(actorAngle) * (baseDist * fTimer), 1, actorAngle, 255, 255, 255, 255)
+		video.renderSpriteState(self.def.customSprites.shield_layer, x + math_cos(actorAngle) * (baseDist * fTimer),
+			y + math_sin(actorAngle) * (baseDist * fTimer), 1, actorAngle, 255, 255, 255, 255)
 	end
-	
+
 	if self.frontLayers > 0 then
 		for i = 0, self.frontLayers - 1 do
-			video.renderSpriteState(self.def.customSprites.shield_layer, x + math_cos(actorAngle) * (frontMove + baseDist + incrementDist * i), y + math_sin(actorAngle) * (baseDist + incrementDist * i), 1, actorAngle, 255, 255, 255, 255)
+			video.renderSpriteState(self.def.customSprites.shield_layer,
+				x + math_cos(actorAngle) * (frontMove + baseDist + incrementDist * i),
+				y + math_sin(actorAngle) * (baseDist + incrementDist * i), 1, actorAngle, 255, 255, 255, 255)
 		end
 	else
-		video.renderSpriteState(self.def.customSprites.shield_warning, x + math_cos(actorAngle) * warnDist, y + math_sin(actorAngle) * warnDist, 0.5 + math_abs(math_sin(self.blinkTimer * 10)) * 0.5, actorAngle, 96 + math_abs(math_sin(self.blinkTimer * 10)) * 64, 255, 255, 255)
+		video.renderSpriteState(self.def.customSprites.shield_warning, x + math_cos(actorAngle) * warnDist,
+			y + math_sin(actorAngle) * warnDist, 0.5 + math_abs(math_sin(self.blinkTimer * 10)) * 0.5, actorAngle,
+			96 + math_abs(math_sin(self.blinkTimer * 10)) * 64, 255, 255, 255)
 	end
-	
+
 	local bTimer = 1 - (1 - self.backTimer) * (1 - self.backTimer)
 	local backMove = bTimer * incrementDist
-	
+
 	if backMove > 0 then
-		video.renderSpriteState(self.def.customSprites.shield_layer, x + math_cos(actorAngle - math_pi) * (baseDist * bTimer), y + math_sin(actorAngle - math_pi) * (baseDist * bTimer), 1, actorAngle - math_pi, 255, 255, 255, 255)
+		video.renderSpriteState(self.def.customSprites.shield_layer, x + math_cos(actorAngle - math_pi) * (baseDist * bTimer),
+			y + math_sin(actorAngle - math_pi) * (baseDist * bTimer), 1, actorAngle - math_pi, 255, 255, 255, 255)
 	end
-	
+
 	if self.backLayers > 0 then
 		for i = 0, self.backLayers - 1 do
-			video.renderSpriteState(self.def.customSprites.shield_layer, x + math_cos(actorAngle - math_pi) * (backMove + baseDist + incrementDist * i), y + math_sin(actorAngle - math_pi) * (baseDist + incrementDist * i), 1, actorAngle - math_pi, 255, 255, 255, 255)
+			video.renderSpriteState(self.def.customSprites.shield_layer,
+				x + math_cos(actorAngle - math_pi) * (backMove + baseDist + incrementDist * i),
+				y + math_sin(actorAngle - math_pi) * (baseDist + incrementDist * i), 1, actorAngle - math_pi, 255, 255, 255, 255)
 		end
 	else
-		video.renderSpriteState(self.def.customSprites.shield_warning, x + math_cos(actorAngle - math_pi) * warnDist, y + math_sin(actorAngle - math_pi) * warnDist, 0.5 + math_abs(math_sin(self.blinkTimer * 10)) * 0.5, actorAngle - math_pi, 96 + math_abs(math_sin(self.blinkTimer * 10)) * 64, 255, 255, 255)
+		video.renderSpriteState(self.def.customSprites.shield_warning, x + math_cos(actorAngle - math_pi) * warnDist,
+			y + math_sin(actorAngle - math_pi) * warnDist, 0.5 + math_abs(math_sin(self.blinkTimer * 10)) * 0.5,
+			actorAngle - math_pi, 96 + math_abs(math_sin(self.blinkTimer * 10)) * 64, 255, 255, 255)
 	end
 end
 
 local function portableBounceSensor(object, impact)
 	if object.time > 0.6 and impact.target and impact.target.dx ~= nil and impact.target.dy ~= nil and (impact.target._category == "actor" or impact.target._category == "object") and not impact.target.lastOnGround then
-		local diff = math_abs(math_angleDifference(object.angle - math_pi * 0.5, math_angleBetweenPoints(object.x, object.y, impact.target.x, impact.target.y)))
+		local diff = math_abs(math_angleDifference(object.angle - math_pi * 0.5,
+			math_angleBetweenPoints(object.x, object.y, impact.target.x, impact.target.y)))
 		local mod = 1
-		
+
 		if diff > math_pi * 0.5 then
 			mod = -1
 		end
-		
+
 		local fx = math_cos(object.angle - math_pi * 0.5 * mod)
 		local fy = math_sin(object.angle - math_pi * 0.5 * mod)
 		local dot = _vectorMath.dot2(impact.target.dx, impact.target.dy, fx, fy)
 		local power = 34
-		
+
 		object:emitSound("pad", 1, 1, 500)
-		
+
 		if impact.target.propel then
 			impact.target:setSpeedVector(object.angle - math_pi * 0.5 * mod, 0)
 			impact.target:propel(object.angle - math_pi * 0.5 * mod, power)
 		else
 			impact.target:setSpeedVector(object.angle - math_pi * 0.5 * mod, power)
 		end
-		
+
 		object:setItemFeedback(1)
 		object:setPickupTimer(1.2)
 	end
@@ -814,12 +831,14 @@
 
 local function renderGlowingLight(self, x, y, angle, r, g, b, facingRight, glow)
 	video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-	video.renderSpriteState(self.def.customSprites.light, x, y, 1, angle, 200 + math_cos(_time * 3) * 54, 255, 255, 255, not facingRight)
+	video.renderSpriteState(self.def.customSprites.light, x, y, 1, angle, 200 + math_cos(_time * 3) * 54, 255, 255, 255,
+		not facingRight)
 end
 
 local function renderGlowingBattery(self, x, y, angle, r, g, b, facingRight, glow)
 	video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-	video.renderSpriteState(self.def.customSprites[self.def.glowSprite], x, y, 1, angle, (128 + math_cos(_time * 3) * 127) * glow, 255, 255, 255, not facingRight)
+	video.renderSpriteState(self.def.customSprites[self.def.glowSprite], x, y, 1, angle,
+		(128 + math_cos(_time * 3) * 127) * glow, 255, 255, 255, not facingRight)
 end
 
 local function genericAmmoAdded(self, actor, ref, amount)
@@ -1188,7 +1207,8 @@
 		end
 	end,
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
 	end,
 	getRecoilFatigue = function(self)
 		return self.upgrades.pointer and 0.5 or 1
@@ -1923,10 +1943,10 @@
 
 local function renderUpgradedItemOrdered(self, x, y, angle, r, g, b, facingRight, glow)
 	video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-	
+
 	for index, upgrade_id in ipairs(self.def.upgradeOrder) do
 		local upgrade = self.upgrades[upgrade_id]
-		
+
 		if upgrade then
 			upgrade.def.renderMethod(upgrade, x, y, angle, r, g, b, facingRight, glow)
 		end
@@ -2512,7 +2532,8 @@
 		return math_pi
 	end,
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and (self.upgrades.magazine.def.ammoCapacity or 0) * self.upgrades.magazine.level or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and (self.upgrades.magazine.def.ammoCapacity or 0) * self.upgrades.magazine.level or 0)
 	end,
 	getBulletTimeFactor = function(self)
 		if self.upgrades.silencer then
@@ -2538,7 +2559,7 @@
 	end,
 	getMuzzleFx = function(self)
 		local def = self.def
-		
+
 		if not self.upgrades.silencer then
 			return def.default_muzzleFx
 		else
@@ -2914,14 +2935,15 @@
 		return math_pi
 	end,
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and (self.upgrades.magazine.def.ammoCapacity or 0) * self.upgrades.magazine.level or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and (self.upgrades.magazine.def.ammoCapacity or 0) * self.upgrades.magazine.level or 0)
 	end,
 	getBulletTimeFactor = function(self)
 		return 0.75
 	end,
 	getBulletSpeed = function(self)
 		local barrel = self.upgrades.barrel
-		
+
 		return self.def.bulletSpeed + (barrel and barrel.level * barrel.def.bulletSpeedBonus or 0)
 	end,
 	getRecoilFatigue = function(self)
@@ -3425,7 +3447,8 @@
 		return math_pi
 	end,
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and (self.upgrades.magazine.def.ammoCapacity or 0) * self.upgrades.magazine.level or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and (self.upgrades.magazine.def.ammoCapacity or 0) * self.upgrades.magazine.level or 0)
 	end,
 	getBulletTimeFactor = function(self)
 		return 0.75
@@ -3702,7 +3725,7 @@
 
 local function sluggerAimAbove(self, dist)
 	local steps = dist / self.bulletSpeed * APP.stepTime * slugGravFactor
-	
+
 	return steps * (steps + 1) * 0.5
 end
 
@@ -3827,17 +3850,18 @@
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local prg = self.hammerAnim
 		local ff = facingToFlipFactor(facingRight)
-		
-		video.renderSpriteState(self.def.customSprites.hammer, x, y, 1, angle - prg * math_pi * 0.3 * ff, 255, r, g, b, not facingRight)
+
+		video.renderSpriteState(self.def.customSprites.hammer, x, y, 1, angle - prg * math_pi * 0.3 * ff, 255, r, g, b,
+			not facingRight)
 		METH.renderGenericUpgradableItem(self, x, y, angle, r, g, b, facingRight, glow)
 	end,
 	updateMethod = function(self, actor, time)
 		self.hammerAnim = actor:getNormalizedAttackTimer()
-		
+
 		self:updateRecoil(actor, time)
-		
+
 		local scope = self.upgrades.scope
-		
+
 		if scope then
 			scope:update(actor, time)
 		end
@@ -4180,7 +4204,8 @@
 	},
 	aimArc = math_pi,
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
 	end,
 	getSoundRange = function(self)
 		return self.upgrades.silencer and 50 or 800
@@ -4474,22 +4499,23 @@
 	useFailMethod = METH.genericFailUse,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		local ff = facingToFlipFactor(facingRight)
 		local prg = math_sin(math_pi * math_min(1, self.hammerAnim * 6)) * 5
-		local ex, ey = x + math_cos(angle - math_pi * 0.5 - math_pi * 0.5 * ff) * prg, y + math_sin(angle - math_pi * 0.5 - math_pi * 0.5 * ff) * prg
-		
+		local ex, ey = x + math_cos(angle - math_pi * 0.5 - math_pi * 0.5 * ff) * prg,
+				y + math_sin(angle - math_pi * 0.5 - math_pi * 0.5 * ff) * prg
+
 		video.renderSpriteState(self.def.customSprites.hammer, ex, ey, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		for index, upgrade in pairs(self.upgrades) do
 			upgrade.def.renderMethod(upgrade, x, y, angle, r, g, b, facingRight, glow)
 		end
 	end,
 	updateMethod = function(self, actor, time)
 		self.hammerAnim = actor:getNormalizedAttackTimer()
-		
+
 		self:updateRecoil(actor, time)
-		
+
 		if self.upgrades.scope then
 			self.upgrades.scope:update(actor, time)
 		end
@@ -4763,7 +4789,8 @@
 		}
 	},
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
 	end,
 	getSoundRange = function(self)
 		return self.upgrades.silencer and 100 or 800
@@ -5072,7 +5099,8 @@
 	},
 	aimArc = math_pi,
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.barrel and self.upgrades.barrel.level * self.upgrades.barrel.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.barrel and self.upgrades.barrel.level * self.upgrades.barrel.def.ammoCapacity or 0)
 	end,
 	getCooldown = function(self, actor)
 		return self.upgrades.trigger and self.def.cooldown * 0.65 or self.def.cooldown
@@ -5090,24 +5118,26 @@
 	useFailMethod = METH.genericFailUse,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local trigger = self.upgrades.trigger
-		
+
 		if trigger then
 			local ff = facingToFlipFactor(facingRight)
-			
-			trigger.def.renderMethod(trigger, x + math_cos(angle - math_pi * 0.5 - ff * math_pi * 0.25) * 8, y + math_sin(angle - math_pi * 0.5 - ff * math_pi * 0.25) * 8, angle - self.hammerAnim * math_pi * 0.25 * ff, r, g, b, facingRight, glow)
+
+			trigger.def.renderMethod(trigger, x + math_cos(angle - math_pi * 0.5 - ff * math_pi * 0.25) * 8,
+				y + math_sin(angle - math_pi * 0.5 - ff * math_pi * 0.25) * 8, angle - self.hammerAnim * math_pi * 0.25 * ff, r,
+				g, b, facingRight, glow)
 		end
-		
+
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		local barrel = self.upgrades.barrel
-		
+
 		if barrel then
 			barrel.def.renderMethod(barrel, x, y, angle, r, g, b, facingRight, glow)
 		end
 	end,
 	updateMethod = function(self, actor, time)
 		self:updateRecoil(actor, time)
-		
+
 		self.hammerAnim = actor:getNormalizedAttackTimer()
 	end,
 	initMethod = METH.initGenericWeapon,
@@ -5381,7 +5411,8 @@
 	},
 	aimArc = math_pi * 0.6,
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
 	end,
 	bulletSpeed = 75 * sluggerBulletMod,
 	useMethod = METH.genericWeaponUse,
@@ -5389,25 +5420,26 @@
 	useFailMethod = METH.genericFailUse,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local cusprites = self.def.customSprites
-		
+
 		video.renderSpriteState(cusprites.sluggerBack, x, y, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(cusprites.sluggerGrip, x, y, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(cusprites.sluggerTube, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		for index, upgrade in pairs(self.upgrades) do
 			upgrade.def.renderMethod(upgrade, x, y, angle, r, g, b, facingRight, glow)
 		end
-		
+
 		local prg = -self.hammerAnim * 7
 		local ff = facingToFlipFactor(facingRight)
-		local ex, ey = x + math_cos(angle - math_pi * 0.5 - math_pi * 0.5 * ff) * prg, y + math_sin(angle - math_pi * 0.5 - math_pi * 0.5 * ff) * prg
-		
+		local ex, ey = x + math_cos(angle - math_pi * 0.5 - math_pi * 0.5 * ff) * prg,
+				y + math_sin(angle - math_pi * 0.5 - math_pi * 0.5 * ff) * prg
+
 		video.renderSpriteState(cusprites.sluggerHammer, ex, ey, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(cusprites.sluggerFront, x, y, 1, angle, 255, r, g, b, not facingRight)
 	end,
 	updateMethod = function(self, actor, time)
 		self.hammerAnim = actor:getNormalizedAttackTimer()
-		
+
 		self:updateRecoil(actor, time)
 	end,
 	initMethod = METH.initGenericWeapon,
@@ -5632,7 +5664,8 @@
 	useFailMethod = METH.genericFailUse,
 	initMethod = METH.initGenericWeapon,
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
 	end,
 	getOffence = function(self)
 		return self.upgrades.proximityFuse and 1 or 0.5
@@ -5649,7 +5682,7 @@
 	end,
 	getAimAbove = function(self, dist)
 		local steps = dist / 26 * APP.stepTime * 32
-		
+
 		return steps * (steps + 1) * 0.5
 	end,
 	rackAngle = -math_pi * 0.5,
@@ -5913,7 +5946,8 @@
 		}
 	},
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
 	end,
 	getAimRange = function(self)
 		return self.upgrades.extendedBarrel and 1200 or 1020
@@ -5936,15 +5970,15 @@
 	initMethod = METH.initGenericWeapon,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local magazine = self.upgrades.magazine
-		
+
 		if magazine then
 			magazine.def.renderMethod(magazine, x, y, angle, r, g, b, facingRight, glow)
 		end
-		
+
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		local barrel = self.upgrades.extendedBarrel
-		
+
 		if barrel then
 			barrel.def.renderMethod(barrel, x, y, angle, r, g, b, facingRight, glow)
 		end
@@ -6238,7 +6272,8 @@
 	initMethod = METH.initGenericWeapon,
 	renderMethod = METH.renderGenericUpgradableItem,
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
 	end,
 	rackAngle = -math_pi * 0.5,
 	getAimRange = function(self)
@@ -6576,7 +6611,8 @@
 	initMethod = METH.initGenericWeapon,
 	renderMethod = METH.renderGenericUpgradableItem,
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
 	end,
 	rackAngle = -math_pi * 0.5,
 	getAimRange = function(self)
@@ -6918,7 +6954,8 @@
 	renderMethod = METH.renderGenericUpgradableItem,
 	updateMethod = updateGenericUpgradableWeapon,
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
 	end,
 	rackAngle = -math_pi * 0.5,
 	getFullAimRange = COMP.scope.usingWeapon,
@@ -7246,7 +7283,8 @@
 		return self.upgrades.proximity and "proximity" or nil
 	end,
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
 	end,
 	rackAngle = -math_pi * 0.5,
 	getFullAimRange = COMP.scope.usingWeapon,
@@ -7349,7 +7387,8 @@
 	},
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		video.renderSpriteState(self.def.customSprites.glow, x, y, 1, angle, 200 + math_cos(_time * 3) * 55, 255, 255, 255, not facingRight)
+		video.renderSpriteState(self.def.customSprites.glow, x, y, 1, angle, 200 + math_cos(_time * 3) * 55, 255, 255, 255,
+			not facingRight)
 	end,
 	ai = {}
 }
@@ -7794,7 +7833,8 @@
 	getFullAimRange = COMP.scope.usingWeapon,
 	getMaxAimRange = COMP.scope.maxUsingWeapon,
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * (self.upgrades.magazine.def.ammoCapacity or 0) or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * (self.upgrades.magazine.def.ammoCapacity or 0) or 0)
 	end,
 	getPower = function(self)
 		return 1 + (self.upgrades.power and self.upgrades.power.level * 0.5 or 0)
@@ -7807,20 +7847,20 @@
 	useFailMethod = METH.genericFailUse,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		local upgrades = self.upgrades
-		
+
 		for index, upgrade in pairs(self.upgrades) do
 			upgrade.def.renderMethod(upgrade, x, y, angle, r, g, b, facingRight, glow)
 		end
-		
+
 		local max = 2 + (upgrades.power and upgrades.power.level or 0)
 		local glows = self.def.customSprites.glow
 		local use_time = self.useTimer / 0.4 * max
-		
+
 		for i = 1, max do
 			local alp = (1 - math.clamp(use_time - i + 1, 0, 1)) * 255
-			
+
 			if alp > 0 then
 				video.renderSpriteState(glows[i], x, y, 1, angle, alp, 255, 255, 255, not facingRight)
 			end
@@ -7828,7 +7868,7 @@
 	end,
 	updateMethod = function(self, actor, time)
 		updateGenericUpgradableWeapon(self, actor, time)
-		
+
 		self.useTimer = actor:getUseTimer()
 	end,
 	initMethod = METH.initGenericWeapon,
@@ -8124,22 +8164,22 @@
 		local healing = actor.needsHealing
 		local soothing = actor.needsSoothing
 		local restoration = actor.needsRestoration
-		
+
 		if healing or soothing or restoration then
 			return true
 		end
 	end
-	
+
 	return false
 end
 
 local function nanoObjPumpCondition(owner, obj)
 	local actor = obj:getActor()
-	
+
 	if actor and not owner:isThreatened(actor) then
 		return obj:needsRevive()
 	end
-	
+
 	return false
 end
 
@@ -8263,7 +8303,8 @@
 		}
 	},
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * (self.upgrades.magazine.def.ammoCapacity or 0) or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * (self.upgrades.magazine.def.ammoCapacity or 0) or 0)
 	end,
 	initRuntimeMethod = function(self)
 		self.gasFx = {}
@@ -8281,22 +8322,22 @@
 		local face_angle = angle + (facingRight and 0 or math.pi)
 		local rx, ry = x - math_cos(face_angle) * offset_size, y - math_sin(face_angle) * offset_size
 		local op = self:getAmmo() / self:getMaxAmmo()
-		
+
 		video.renderSpriteState(cu_sprites.light, rx, ry, 1, angle, op * 255 * glow, 255, 255, 255, not facingRight)
 		video.renderSpriteState(cu_sprites.cover, rx, ry, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		local barrel = self.upgrades.barrel
-		
+
 		if barrel then
 			barrel.def.renderMethod(barrel, x, y, angle, r, g, b, facingRight, glow)
 		end
-		
+
 		if self.active then
 			local light = 255 * math_min(1, 0.75 + 0.25 * math_cos(_time * math_pi * 1.7)) * glow
-			
+
 			video.renderSpriteState(cu_sprites.glow, x, y, 1, angle, light, 255, 255, 255, not facingRight)
-			
+
 			if barrel then
 				for i = 1, barrel.level do
 					video.renderSpriteState(cu_sprites.barrel_glows[i], x, y, 1, angle, light, 255, 255, 255, not facingRight)
@@ -8306,16 +8347,16 @@
 	end,
 	getBulletSpeed = function(self)
 		local barrels = self.upgrades.barrel and self.upgrades.barrel.level or 0
-		
+
 		return 15 + 5 * barrels
 	end,
 	updateMethod = function(self, actor, time)
 		if self.active then
 			local barrels = self.upgrades.barrel and self.upgrades.barrel.level or 0
-			
+
 			while self.delay <= 0 do
 				self.healing = false
-				
+
 				local ang = math_randomAngle()
 				local dist = 3 * math_random()
 				local x, y = actor:getSafeWeaponXY()
@@ -8323,69 +8364,70 @@
 				local speed = self.bulletSpeed
 				local fx = actor:emitPpFxAt(self.def.spawn_fx, x + math_cos(ang) * dist, y + math_sin(ang) * dist)
 				local col = actor:getIdentityColor() or COLORS.white
-				
+
 				fx:applyFadedColor(col, COLORS.white, 0.5)
 				table.insert(self.gasFx, fx)
-				
+
 				self.anyGas = true
-				
+
 				local range = 500
 				local healing = false
-				
+
 				if actor.map then
-					local foundList = actor:findRangeArcObjectsInClassification(range, math_pi * 0.25, angle, "healable", nanoObjPumpCondition)
-					
+					local foundList = actor:findRangeArcObjectsInClassification(range, math_pi * 0.25, angle, "healable",
+						nanoObjPumpCondition)
+
 					if foundList then
 						local healed = #foundList
-						
+
 						if healed <= 0 then
 							foundList = actor:findOmniObjectsInClassification(range * 0.15, "healable", nanoObjPumpCondition)
 							healed = #foundList
 						end
-						
+
 						if healed > 0 then
 							local ent = foundList[math_random(1, healed)]
-							
+
 							ent:setIsHealing(true)
 							fx:setTarget(ent)
 							fx:setOwner(actor)
-							
+
 							healing = true
-							
+
 							for i, fx in pairs(self.gasFx) do
 								if not fx.target then
 									local ent = foundList[math_random(1, healed)]
-									
+
 									fx:setTarget(ent)
 								end
 							end
 						end
 					end
-					
+
 					if not healing then
 						local foundList = actor:findRangeArcActors(range, math_pi * 0.25, angle, nanoPumpCondition)
-						
+
 						if foundList then
 							local healed = #foundList
-							
+
 							if healed <= 0 then
 								foundList = actor:findOmniActors(range * 0.15, nanoPumpCondition)
 								healed = #foundList
 							end
-							
+
 							if healed > 0 then
 								healing = true
-								
+
 								local ent = foundList[math_random(1, healed)]
 								local node = ent:getNextHealingNode()
-								
+
 								fx:setTarget(ent, node)
-								
+
 								for i, fx in pairs(self.gasFx) do
 									if not fx.target then
 										local ent = foundList[math_random(1, healed)]
 										local node = ent:getNextHealingNode()
-										
+
 										fx:setTarget(ent, node)
 									end
 								end
@@ -8393,42 +8435,42 @@
 						end
 					end
 				end
-				
+
 				self.healing = healing
-				
+
 				local factor = healing and 1 or 5
-				
+
 				fx:setSpeed(angle + math.randomGaussian() * math_pi * 0.2, 32 * speed * (0.25 + math_random() * 0.75) / factor)
 				fx:addSpeedXY(actor.dx * Fx.speed_multiplier, actor.dy * Fx.speed_multiplier)
-				
+
 				self.delay = self.delay + self:getCooldown(actor) / self:getBullets() * (healing and 1 or 5)
-				
+
 				fx:setOwner(actor)
-				
+
 				self.ammoTimer = self.ammoTimer + self.def.ammoPerFx
-				
+
 				if self.ammoTimer > 1 then
 					self:applyRandomRecoil(actor, 1)
-					
+
 					local rem = math_floor(math_min(self.ammoTimer, self.ammo))
-					
+
 					self.ammoTimer = self.ammoTimer - rem
-					
+
 					self:useAmmo(actor, rem)
 				end
 			end
-			
+
 			self.delay = self.delay - time
-			
+
 			local prg = self:getAmmo() / self:getMaxAmmo()
 			local factor = self.healing and 1 or 0.2
-			
+
 			actor:emitLoop("gas", factor, 0.5 + prg * 0.5 + 0.25 * barrels, RANGES.tiny)
 		end
-		
+
 		if self.anyGas then
 			table.removeCompletelyIf(self.gasFx)
-			
+
 			if #self.gasFx <= 0 then
 				self.anyGas = false
 			end
@@ -8439,7 +8481,7 @@
 	end,
 	initMethod = function(self)
 		METH.initGenericWeapon(self)
-		
+
 		self.ammoTimer = self.ammoTimer or 0
 	end,
 	customSpriteNames = {
@@ -8644,121 +8686,121 @@
 local function createRay(self, actor, rayType)
 	local x, y = actor:getSafeWeaponXY()
 	local obj = actor:emitObjectAt(rayType, x, y)
-	
+
 	obj:setLifeTime(0.25)
-	
+
 	obj.range = 2000
-	
+
 	obj:setAngle(actor:getAbsoluteAngle())
 	obj:setOwner(actor)
-	
+
 	return obj
 end
 
 local function genericBeamWeaponUpdate(self, actor, time)
 	local threshold = self.def.beamThreshold or 0.25
-	
+
 	if self.active then
 		self.outputTimer = math_min(1, self.outputTimer + time * self.def.outputChangeSpeed)
 	else
 		self.outputTimer = math_max(0, self.outputTimer - time * self.def.outputChangeSpeed)
 	end
-	
+
 	if self.ammo <= 0 then
 		self.outputTimer = 0
 	end
-	
+
 	local maxAmmo = self:getMaxAmmo() or 1
-	
+
 	if self.ammo < maxAmmo * 0.9 then
 		self.allowBeep = true
 	end
-	
+
 	if maxAmmo <= self.ammo and self.allowBeep then
 		self.allowBeep = false
-		
+
 		actor:emitSound("beamReady", 0.1, 0.5)
 	end
-	
+
 	if maxAmmo <= self.ammo then
 		self.maxedFill = true
 	else
 		self.maxedFill = false
 	end
-	
+
 	self.lightAmount = self.ammo / maxAmmo
-	
+
 	local power = self:getPower() or 1
 	local beamLevel = self.outputTimer * power
-	
+
 	if beamLevel > 0 then
 		if beamLevel < threshold then
 		else
 			local beamForce = (beamLevel - threshold) / (1 - threshold)
 			local vol = math_easeOut(math_min(1, beamForce))
-			
+
 			actor:emitLoop("beamLoop", vol * 0.5, 0.75 + math_min(1, beamForce * 0.15), vol * RANGES.medium)
-			
+
 			if self.warning then
 				self.warning:remove()
-				
+
 				self.warning = nil
 			end
-			
+
 			actor:setStealthPenalty(beamForce * 0.5)
-			
+
 			self.beamDelay = self.beamDelay - time
-			
+
 			local angle = actor:getAbsoluteWeaponAngle()
-			
+
 			if self.beamDelay <= 0 then
 				local x, y = actor:getSafeWeaponXY()
 				local ray = actor:shootBullet(x, y, angle, self.bulletSpeed, self.bullet, self)
-				
+
 				if ray then
 					self.ray = ray
-					
+
 					ray:setPower(beamForce)
 				end
-				
+
 				self.beamDelay = self.def.beamDelay
-				
+
 				self:applyRandomRecoil(actor, self:getRecoilAmount())
 				self:applyRecoilFatigue(self:getRecoilFatigue())
 			elseif self.ray and self.ray.alpha >= 1 then
 				self.ray.beamForce = beamForce
-				
+
 				self.ray:setAngle(angle)
 			end
 		end
-		
+
 		self.ammoTimer = self.ammoTimer + time * (beamLevel * 0.8 + 0.2 * beamLevel * beamLevel) * 5
 	else
 		if self.warning then
 			self.warning:remove()
-			
+
 			self.warning = nil
 		end
-		
+
 		if self.ray then
 			self.ray:remove()
-			
+
 			self.ray = nil
 		end
 	end
-	
+
 	if self.ammoTimer > 1 then
 		local rem = math_floor(math_min(self.ammoTimer, self.ammo))
-		
+
 		self.ammoTimer = self.ammoTimer - rem
-		
+
 		self:useAmmo(actor, rem)
 	end
 end
 
 local function initGenericBeamWeapon(self)
 	METH.initGenericWeapon(self)
-	
+
 	self.chargeTimer = self.chargeTimer or 0
 	self.outputTimer = self.outputTimer or 0
 	self.ammoTimer = self.ammoTimer or 0
@@ -8864,7 +8906,7 @@
 	},
 	isPreparedMethod = function(self)
 		local beamLevel = self:getPower() or 1
-		
+
 		return beamLevel > self.def.beamThreshold
 	end,
 	initMethod = initGenericBeamWeapon,
@@ -8873,10 +8915,12 @@
 		"use_limited_by_ammo"
 	},
 	getMaxAmmo = function(self)
-		return (self.upgrades.chargeCell and self.upgrades.chargeCell.level * self.upgrades.chargeCell.def.ammoCapacity or 0) + 10
+		return (self.upgrades.chargeCell and self.upgrades.chargeCell.level * self.upgrades.chargeCell.def.ammoCapacity or 0) +
+		10
 	end,
 	getPower = function(self)
-		return ((self.upgrades.powerCrystal and self.upgrades.powerCrystal.level * 0.75 or 0) + 0.75) * (0.75 + self.ammo / self:getMaxAmmo() * 0.25)
+		return ((self.upgrades.powerCrystal and self.upgrades.powerCrystal.level * 0.75 or 0) + 0.75) *
+		(0.75 + self.ammo / self:getMaxAmmo() * 0.25)
 	end,
 	updateMethod = function(self, actor, time)
 		genericBeamWeaponUpdate(self, actor, time)
@@ -8885,53 +8929,59 @@
 	switchedFromMethod = function(self)
 		if self.ray then
 			self.ray:remove()
-			
+
 			self.ray = nil
 		end
-		
+
 		if self.warning then
 			self.warning:remove()
-			
+
 			self.warning = nil
 		end
-		
+
 		self.outputTimer = 0
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local cusprites = self.def.customSprites
-		
+
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if self.maxedFill then
-			video.renderSpriteState(cusprites.beamgun_light, x, y, 1, angle, 255, math_min(255, r / 3 + 10 * self.lightAmount), math_min(255, g / 3 + 255 * self.lightAmount), math_min(255, b / 3 + 20 * self.lightAmount), not facingRight)
+			video.renderSpriteState(cusprites.beamgun_light, x, y, 1, angle, 255, math_min(255, r / 3 + 10 * self.lightAmount),
+				math_min(255, g / 3 + 255 * self.lightAmount), math_min(255, b / 3 + 20 * self.lightAmount), not facingRight)
 		else
-			video.renderSpriteState(cusprites.beamgun_light, x, y, 1, angle, 255, math_min(255, r / 3 + 255 * self.lightAmount), math_min(255, g / 3 + 150 * self.lightAmount), math_min(255, b / 3 + 20 * self.lightAmount), not facingRight)
+			video.renderSpriteState(cusprites.beamgun_light, x, y, 1, angle, 255, math_min(255, r / 3 + 255 * self.lightAmount),
+				math_min(255, g / 3 + 150 * self.lightAmount), math_min(255, b / 3 + 20 * self.lightAmount), not facingRight)
 		end
-		
+
 		for index, upgrade in pairs(self.upgrades) do
 			upgrade.def.renderMethod(upgrade, x, y, angle, r, g, b, facingRight, glow)
 		end
-		
+
 		local chargeCell = self.upgrades.chargeCell
-		
+
 		if chargeCell then
 			local level = chargeCell.level
 			local render_level = (self.ammo - 1) / 10 / level
-			
+
 			if level >= 4 then
-				video.renderSpriteState(cusprites.beamgun_ball1, x, y, 1, angle, math_min(1, 4 * math_max(0, render_level - 0.75)) * 255, 255, 255, 255, not facingRight)
+				video.renderSpriteState(cusprites.beamgun_ball1, x, y, 1, angle,
+					math_min(1, 4 * math_max(0, render_level - 0.75)) * 255, 255, 255, 255, not facingRight)
 			end
-			
+
 			if level >= 3 then
-				video.renderSpriteState(cusprites.beamgun_ball2, x, y, 1, angle, math_min(1, 4 * math_max(0, render_level - 0.5)) * 255, 255, 255, 255, not facingRight)
+				video.renderSpriteState(cusprites.beamgun_ball2, x, y, 1, angle,
+					math_min(1, 4 * math_max(0, render_level - 0.5)) * 255, 255, 255, 255, not facingRight)
 			end
-			
+
 			if level >= 2 then
-				video.renderSpriteState(cusprites.beamgun_ball3, x, y, 1, angle, math_min(1, 4 * math_max(0, render_level - 0.25)) * 255, 255, 255, 255, not facingRight)
+				video.renderSpriteState(cusprites.beamgun_ball3, x, y, 1, angle,
+					math_min(1, 4 * math_max(0, render_level - 0.25)) * 255, 255, 255, 255, not facingRight)
 			end
-			
+
 			if level >= 1 then
-				video.renderSpriteState(cusprites.beamgun_ball4, x, y, 1, angle, math_min(1, 4 * math_max(0, render_level)) * 255, 255, 255, 255, not facingRight)
+				video.renderSpriteState(cusprites.beamgun_ball4, x, y, 1, angle, math_min(1, 4 * math_max(0, render_level)) * 255,
+					255, 255, 255, not facingRight)
 			end
 		end
 	end,
@@ -9251,29 +9301,29 @@
 	useMethod = function(self, actor, angle)
 		local x, y = actor:getSafeWeaponXY()
 		local ang = actor:getAbsoluteWeaponAngle()
-		
+
 		actor:emitFxAt("chemicalFlash", x, y)
 		actor:emitSoundAt("chemicalShot", x, y, 1, 1, RANGES.medium)
-		
+
 		local obj = actor:shootNewtonianBullet(x, y, ang, 20, "chemical", self, 1)
-		
+
 		if obj then
 			obj:setAngle(ang)
 			obj:setOwner(actor)
 			obj:setSpeed(ang, 20)
 			obj:applySpecial(self:getSpecial(), actor, self)
-			
+
 			obj.target = actor.aimedAtTarget
 		end
-		
+
 		self:useAmmo(actor, 1)
-		
+
 		return true
 	end,
 	updateMethod = function(self, actor, time)
 		if self.chargeDelay < 0 then
 			self.chargeDelay = 0.5
-			
+
 			self:addAmmo(1, actor)
 		else
 			self.chargeDelay = self.chargeDelay - time
@@ -9300,17 +9350,18 @@
 	useMethod = function(self, actor, angle)
 		local spikes = (actor.health or 1) * 1.5
 		local bspeed = self.bulletSpeed
-		
+
 		for i = 1, spikes do
 			local x, y = actor:getSafeWeaponXY()
 			local arcing = angle - math_pi * 0.3 + math_pi * 0.6 / math_max(spikes - 1) * (i - 1)
 			local arcingSmall = angle - math_pi * 0.15 + math_pi * 0.3 / math_max(1, spikes - 1) * (i - 1)
-			
-			actor:shootBullet(x + math_cos(angle) * -20 + math_cos(arcing) * 20, y + math_sin(angle) * -20 + math_sin(arcing) * 20, arcingSmall, bspeed, "spikeBullet", self)
+
+			actor:shootBullet(x + math_cos(angle) * -20 + math_cos(arcing) * 20,
+				y + math_sin(angle) * -20 + math_sin(arcing) * 20, arcingSmall, bspeed, "spikeBullet", self)
 		end
-		
+
 		actor.health = actor.health / 2
-		
+
 		return true
 	end,
 	ai = {
@@ -9398,27 +9449,27 @@
 	},
 	getAimAbove = function(self, dist)
 		local steps = dist / 57 * APP.stepTime * 46
-		
+
 		return steps * (steps + 1) * 0.5
 	end,
 	canUseMethod = METH.genericHasAmmo,
 	useMethod = function(self, actor, angle)
 		local x, y = actor:getSafeWeaponXY()
-		
+
 		self.fired = true
-		
+
 		actor:shootProjectedBullet(x, y, angle, self.bulletSpeed, self.bullet, self)
 		self:applyRandomRecoil(actor)
 		self:applyRecoilFatigue()
 		self:useAmmo(actor, 1)
-		
+
 		return true
 	end,
 	useFailMethod = function(self, actor)
 		self.fired = false
-		
+
 		self:failedUse(actor)
-		
+
 		return true
 	end,
 	rackAngle = -math_pi * 0.5,
@@ -9433,34 +9484,37 @@
 	end,
 	updateMethod = function(self, actor, time)
 		self.useTimer = actor:getNormalizedAttackTimer()
-		
+
 		self:updateRecoil(actor, time)
-		
+
 		if self.upgrades.scope then
 			self.upgrades.scope:update(actor, time)
 		end
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local cusprites = self.def.customSprites
-		
+
 		video.renderSpriteState(cusprites.crossbow_outline, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if self.useTimer then
 			if self.useTimer <= 0.2 and self:getAmmo() > 0 then
-				video.renderSpriteState(cusprites.crossbow_bolt, x, y, 1, angle, 255 - self.useTimer * 255 * 5, r, g, b, not facingRight)
+				video.renderSpriteState(cusprites.crossbow_bolt, x, y, 1, angle, 255 - self.useTimer * 255 * 5, r, g, b,
+					not facingRight)
 			end
-			
+
 			if self.fired then
 				local ff = facingToFlipFactor(facingRight)
-				
-				video.renderSpriteState(cusprites.crossbow_crank, x, y, 1, angle - math_pi * 0.5 * math_min(1, self.useTimer) * math_min(1, self.useTimer) * ff, 255, r, g, b, not facingRight)
+
+				video.renderSpriteState(cusprites.crossbow_crank, x, y, 1,
+					angle - math_pi * 0.5 * math_min(1, self.useTimer) * math_min(1, self.useTimer) * ff, 255, r, g, b,
+					not facingRight)
 			else
 				video.renderSpriteState(cusprites.crossbow_crank, x, y, 1, angle, 255, r, g, b, not facingRight)
 			end
 		end
-		
+
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		for index, upgrade in pairs(self.upgrades) do
 			upgrade:render(x, y, angle, r, g, b, facingRight, glow)
 		end
@@ -9739,13 +9793,13 @@
 	switchedFromMethod = function(self, actor)
 		if self.linkedBullet then
 			self.linkedBullet:performReaction()
-			
+
 			self.linkedBullet = nil
 		end
-		
+
 		if self.target then
 			self.target:performReaction()
-			
+
 			self.target = nil
 		end
 	end,
@@ -9753,7 +9807,7 @@
 		if self.actor then
 			return true
 		end
-		
+
 		if not self.target and not self.linkedBullet and self:getAmmo() > 0 then
 			return true
 		end
@@ -9762,29 +9816,29 @@
 		if self.actor then
 			local x, y = actor:getSafeWeaponXY()
 			local obj = actor:shootProjectedBullet(x, y, angle, self.bulletSpeed, "dematerialized", self)
-			
+
 			if obj then
 				obj:setActor(self.actor)
-				
+
 				obj.volatile = true
 				obj.instability = 0
 				obj.charge = 1
-				
+
 				self:setActor(nil)
 			end
-			
+
 			return true
 		elseif not self.target and not self.linkedBullet then
 			local x, y = actor:getSafeWeaponXY()
 			local obj = METH.genericWeaponShootBullet(self, actor, x, y, angle, angle)
-			
+
 			if obj then
 				self:setLinkedBullet(obj)
 			end
-			
+
 			METH.genericWeaponFeedback(self, actor, x, y, angle)
 			self:useAmmo(actor, 1)
-			
+
 			return true
 		end
 	end,
@@ -9804,27 +9858,29 @@
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		if self.actor then
 			local col = self.actor:getIdentityColor() or COLORS.white
-			
-			video.renderSpriteState(self.def.customSprites.light, x, y, 1, angle, 175 + 50 * math_cos(_time * math_pi * 5), col.r, col.g, col.b, not facingRight)
+
+			video.renderSpriteState(self.def.customSprites.light, x, y, 1, angle, 175 + 50 * math_cos(_time * math_pi * 5),
+				col.r, col.g, col.b, not facingRight)
 		end
-		
+
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if self.actor then
 			local col = self.actor:getIdentityColor() or COLORS.white
-			
-			video.renderSpriteState(self.def.customSprites.glow, x, y, 1 + 0.45 * math_cos(_time * math_pi * 5), angle, 255, col.r, col.g, col.b, not facingRight)
+
+			video.renderSpriteState(self.def.customSprites.glow, x, y, 1 + 0.45 * math_cos(_time * math_pi * 5), angle, 255,
+				col.r, col.g, col.b, not facingRight)
 		end
 	end,
 	updateMethod = function(self, actor, time)
 		self:updateRecoil(actor, time)
-		
+
 		if self.linkedBullet and self.linkedBullet._remove then
 			self.linkedBullet = nil
 		end
-		
+
 		local captured_actor = self.actor
-		
+
 		if not captured_actor then
 			if self.target then
 				if self.target._remove then
@@ -9832,25 +9888,25 @@
 				elseif self.target:getActor() then
 					local x, y = actor:getSafeWeaponXY()
 					local angle = math_angleBetweenPoints(self.target.x, self.target.y, x, y)
-					
+
 					self.target:addSpeed(angle, 100 * time)
-					
+
 					local speed = self.target:getSpeed()
-					
+
 					self.target:stopSpeedXY(speed * 0.1, speed * 0.1, time)
-					
+
 					local dist = math_distance(x, y, self.target.x, self.target.y)
-					
+
 					if dist < 32 and actor ~= self.target:getActor() and self:capture(actor, self.target:getActor()) then
 						self.target:remove()
-						
+
 						self.target = nil
 					end
 				end
 			end
 		else
 			local x, y = actor:getWeaponX(), actor:getWeaponY()
-			
+
 			captured_actor:setPosition(x, y)
 		end
 	end,
@@ -9885,46 +9941,46 @@
 local function blasterTrigger(self, actor)
 	if #self.linkedBullets > 0 then
 		local ok = false
-		
+
 		for index, linkedBullet in pairs(self.linkedBullets) do
 			if not linkedBullet._remove then
 				for i = 0, 2 do
 					local fx = linkedBullet:emitFx("blasterRadioIn")
-					
+
 					fx.time = -i / 10
 				end
-				
+
 				linkedBullet:performReaction()
-				
+
 				ok = true
 			end
 		end
-		
+
 		if ok then
 			actor:emitSound("blasterTrigger", 1, 1, 100)
-			
+
 			if actor:getWeaponHoldingNode() then
 				local recoilAng = actor:getWeaponAngle() + math_pi
-				
+
 				actor.rig:setNodeSpeed(actor:getWeaponHoldingNode(), math_cos(recoilAng) * 200, math_sin(recoilAng) * 200)
 				actor.rig:setNodeAngleSpeed(actor:getWeaponHoldingNode(), 30)
 			end
-			
+
 			local x, y = actor:getWeaponX(), actor:getWeaponY()
-			
+
 			for i = 0, 2 do
 				local fx = actor:emitFxAt("blasterRadioOut", x, y)
-				
+
 				fx:setReference(actor)
 				fx:setNode("weapon")
-				
+
 				fx.time = -i / 10
 			end
 		end
-		
+
 		return ok
 	end
-	
+
 	return false
 end
 
@@ -10023,29 +10079,30 @@
 		}
 	},
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
 	end,
 	canUseMethod = METH.genericHasAmmo,
 	useFailMethod = METH.genericFailUse,
 	useMethod = function(self, actor, angle)
 		actor:emitSound(self:getUseSound(), 1, 1, self:getSoundRange())
-		
+
 		local rec = self:getRecoilAmount()
-		
-		actor:setStealthPenalty(self:getSoundRange() * soundToVisFactor + rec * recoilToVisFactor)
-		
+
+		actor:setStealthPenalty(self:getSoundRange() * SoundToVisFactor + rec * RecoilToVisFactor)
+
 		local x, y = actor:getSafeWeaponXY()
 		local obj = actor:shootProjectedBullet(x, y, angle, self.bulletSpeed, self.bullet, self)
-		
+
 		if obj and self.upgrades.energyDish then
 			self:setLinkedBullet(obj)
 		end
-		
+
 		self:createMuzzleFx(actor, x, y, "blasterMuzzle", 1, angle)
 		self:applyRandomRecoil(actor, rec)
 		self:applyRecoilFatigue()
 		self:useAmmo(actor, 1)
-		
+
 		return true
 	end,
 	getSpecial = function(self)
@@ -10053,16 +10110,16 @@
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		for index, upgrade in pairs(self.upgrades) do
 			upgrade:render(x, y, angle, r, g, b, facingRight, glow)
 		end
 	end,
 	updateMethod = function(self, actor, time)
 		self:updateRecoil(actor, time)
-		
+
 		local linkedBullet = self.linkedBullet
-		
+
 		if linkedBullet and self.upgrades.energyDish then
 			if actor:losCheck(linkedBullet, nil, true, math_pi, false) then
 				linkedBullet.power = linkedBullet.power + time / 0.6
@@ -10072,17 +10129,17 @@
 			end
 		elseif self.linkFx then
 			self.linkFx:remove()
-			
+
 			self.linkFx = nil
 		end
-		
+
 		if linkedBullet and linkedBullet._remove then
 			self.linkedBullet = nil
 		end
 	end,
 	initMethod = function(self)
 		METH.initGenericWeapon(self)
-		
+
 		self.linkedBullet = nil
 	end,
 	onUsedSemiMethod = genericUsedSemi,
@@ -10280,51 +10337,51 @@
 		if actor.onGround and not actor.input.jump then
 			self.doFire = true
 			self.fireTime = self.def.cooldown
-			
+
 			local x, y = actor.x + 48, actor.y - 40
-			
+
 			if not actor.facingRight then
 				x = actor.x - 56
 			end
-			
+
 			if actor.rig then
 				x, y = actor:getSafeWeaponXY()
 				y = y - 4
 			end
-			
+
 			actor:emitFxAt("starGuardAttackFlash", x, y)
-			
+
 			return true
 		end
-		
+
 		return nil
 	end,
 	updateMethod = function(self, actor, time)
 		if self.doFire and not actor.damaged then
 			actor:resetInput()
-			
+
 			self.fireTime = self.fireTime - time
-			
+
 			if self.fireTime <= 0 then
 				self.doFire = false
-				
+
 				local x, y = actor.x + 64, actor.y - 40 + 4
-				
+
 				if not actor.facingRight then
 					x = actor.x - 64
 				end
-				
+
 				if actor.rig then
 					x, y = actor:getSafeWeaponXY(48)
 				end
-				
+
 				local obj = actor:emitObjectAt("starGuardGuardBullet", x, y)
-				
+
 				obj.a, obj.r, obj.g, obj.b = 255, 255, 0, 0
 				obj.flipped = not actor.facingRight
-				
+
 				obj:setOwner(actor)
-				
+
 				if actor.facingRight then
 					obj:addSpeedXY(20, 0)
 				else
@@ -10358,25 +10415,25 @@
 	weapon = true,
 	useMethod = function(self, actor, angle)
 		local x, y = actor.x + 64, actor.y - 40 + 4
-		
+
 		if not actor.facingRight then
 			x = actor.x - 64
 		end
-		
+
 		if actor.rig then
 			x, y = actor:getSafeWeaponXY(48)
 		end
-		
+
 		local obj = actor:emitObjectAt("starGuardGuardBullet", x, y, actor.map)
-		
+
 		obj.a, obj.r, obj.g, obj.b = 255, 0, 255, 0
 		obj.whiteOut = true
 		obj.flipped = not actor.facingRight
-		
+
 		obj:setOwner(actor)
 		obj:addSpeed(actor:getAbsoluteWeaponAngle(), 40)
 		obj:setAngle(actor:getAbsoluteWeaponAngle())
-		
+
 		return true
 	end,
 	updateMethod = function(self, actor, time)
@@ -11486,18 +11543,18 @@
 	useFailMethod = METH.genericFailUse,
 	useMethod = function(self, actor, angle)
 		self.burst = self.ammo
-		
+
 		return true
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local cusprites = self.def.customSprites
-		
+
 		video.renderSpriteState(cusprites.back, x, y, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(cusprites.slider, x, y, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(cusprites.sliderSlug, x, y, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(cusprites.sliderTop, x, y, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		for index, upgrade in pairs(self.upgrades) do
 			upgrade:render(x, y, angle, r, g, b, facingRight, glow)
 		end
@@ -11519,7 +11576,8 @@
 		back = "railBurst_back"
 	},
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
 	end,
 	rackAngle = -math_pi * 0.5,
 	ai = {
@@ -11694,10 +11752,10 @@
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local ff = facingToFlipFactor(facingRight)
-		
+
 		x = x + math_cos(angle) * self.def.offsetX * ff + math_cos(angle) * self.def.offsetY
 		y = y + math_sin(angle) * self.def.offsetY + math_sin(angle) * self.def.offsetX * ff
-		
+
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle + self.spin * math_pi * ff, 255, r, g, b, not facingRight)
 	end,
 	ai = {}
@@ -11817,18 +11875,18 @@
 	useFailMethod = METH.genericFailUse,
 	useMethod = function(self, actor, angle)
 		self.burst = self.ammo
-		
+
 		return true
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local cusprites = self.def.customSprites
-		
+
 		video.renderSpriteState(cusprites.back, x, y, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(cusprites.slider, x, y, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(cusprites.sliderSlug, x, y, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(cusprites.sliderTop, x, y, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		for index, upgrade in pairs(self.upgrades) do
 			upgrade:render(x, y, angle, r, g, b, facingRight, glow)
 		end
@@ -11850,7 +11908,8 @@
 		back = "railBurstBig_back"
 	},
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
 	end,
 	rackAngle = -math_pi * 0.5,
 	ai = {
@@ -12025,10 +12084,10 @@
 	},
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local ff = facingToFlipFactor(facingRight)
-		
+
 		x = x + math_cos(angle) * self.def.offsetX * ff + math_cos(angle) * self.def.offsetY
 		y = y + math_sin(angle) * self.def.offsetY + math_sin(angle) * self.def.offsetX * ff
-		
+
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle + self.spin * math_pi * ff, 255, r, g, b, not facingRight)
 	end,
 	ai = {}
@@ -12161,15 +12220,18 @@
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local cusprites = self.def.customSprites
 		local ff = facingToFlipFactor(facingRight)
-		
+
 		video.renderSpriteState(cusprites.bottom, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		for i = 1, 5 do
-			video.renderSpriteState(cusprites.barrel, x + math_cos(angle + math_pi * 0.5 * ff) * math_cos(self.spin * ff + 5 / i * math_pi * 2) * 2, y + math_sin(angle + math_pi * 0.5 * ff) * math_cos(self.spin * ff + 5 / i * math_pi * 2) * 2, 1, angle, 255, r, g, b, not facingRight)
+			video.renderSpriteState(cusprites.barrel,
+				x + math_cos(angle + math_pi * 0.5 * ff) * math_cos(self.spin * ff + 5 / i * math_pi * 2) * 2,
+				y + math_sin(angle + math_pi * 0.5 * ff) * math_cos(self.spin * ff + 5 / i * math_pi * 2) * 2, 1, angle, 255, r,
+				g, b, not facingRight)
 		end
-		
+
 		video.renderSpriteState(cusprites.top, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		for index, upgrade in pairs(self.upgrades) do
 			upgrade:render(x, y, angle, r, g, b, facingRight, glow)
 		end
@@ -12472,13 +12534,16 @@
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local cusprites = self.def.customSprites
 		local ff = facingToFlipFactor(facingRight)
-		
+
 		for i = 1, 8 do
-			video.renderSpriteState(cusprites.barrel, x + math_cos(angle + math_pi * 0.5 * ff) * math_cos(self.spin * ff + 5 / i * math_pi * 2) * 3, y + math_sin(angle + math_pi * 0.5 * ff) * math_cos(self.spin * ff + 5 / i * math_pi * 2) * 3, 1, angle, 255, r, g, b, not facingRight)
+			video.renderSpriteState(cusprites.barrel,
+				x + math_cos(angle + math_pi * 0.5 * ff) * math_cos(self.spin * ff + 5 / i * math_pi * 2) * 3,
+				y + math_sin(angle + math_pi * 0.5 * ff) * math_cos(self.spin * ff + 5 / i * math_pi * 2) * 3, 1, angle, 255, r,
+				g, b, not facingRight)
 		end
-		
+
 		video.renderSpriteState(cusprites.top, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		for index, upgrade in pairs(self.upgrades) do
 			upgrade:render(x, y, angle, r, g, b, facingRight, glow)
 		end
@@ -12835,13 +12900,16 @@
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local cusprites = self.def.customSprites
 		local ff = facingToFlipFactor(facingRight)
-		
+
 		for i = 1, 4 do
-			video.renderSpriteState(cusprites.barrel, x + math_cos(angle + math_pi * 0.5 * ff) * math_cos(self.spin * ff + 5 / i * math_pi * 2) * 2, y + math_sin(angle + math_pi * 0.5 * ff) * math_cos(self.spin * ff + 5 / i * math_pi * 2) * 2, 1, angle, 255, r, g, b, not facingRight)
+			video.renderSpriteState(cusprites.barrel,
+				x + math_cos(angle + math_pi * 0.5 * ff) * math_cos(self.spin * ff + 5 / i * math_pi * 2) * 2,
+				y + math_sin(angle + math_pi * 0.5 * ff) * math_cos(self.spin * ff + 5 / i * math_pi * 2) * 2, 1, angle, 255, r,
+				g, b, not facingRight)
 		end
-		
+
 		video.renderSpriteState(cusprites.top, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		for index, upgrade in pairs(self.upgrades) do
 			upgrade:render(x, y, angle, r, g, b, facingRight, glow)
 		end
@@ -12868,7 +12936,8 @@
 		top = "railVanquisher_top"
 	},
 	getMaxAmmo = function(self)
-		return self.def.maxAmmo + (self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
+		return self.def.maxAmmo +
+		(self.upgrades.magazine and self.upgrades.magazine.level * self.upgrades.magazine.def.ammoCapacity or 0)
 	end,
 	rackAngle = -math_pi * 0.5,
 	ai = {
@@ -14377,7 +14446,7 @@
 		if self.upgrades.scope then
 			return 1000
 		end
-		
+
 		return 800
 	end,
 	reloadSequence = {
@@ -15020,12 +15089,12 @@
 		self.charge = math_min(1, self.charge + time / 0.25)
 		self.chargeMe = false
 	end
-	
+
 	if self.charge > 0 then
 		local charge = math_easeOut(self.charge)
 		local def = actor:getNodeAttack("peck")
 		local nodeAngle = actor:getRelativeNodeAngle(def.node)
-		
+
 		actor:applyNodeAttackChargeSpeeds("peck", nodeAngle, charge, math_min(1, charge * 10))
 	end
 end
@@ -15055,7 +15124,7 @@
 	updateMethod = peckUpdate,
 	getCooldown = function(self, actor)
 		local c = actor:getNodeAttack("peck").cooldown or 1
-		
+
 		return (self.charge * 0.1 + 0.05) * c
 	end,
 	getCharge = function(self)
@@ -15068,11 +15137,12 @@
 			local nodeAngle = actor:getRelativeWeaponAngle()
 			local x, y = actor:getSafeWeaponXY(0)
 			local def = actor:getNodeAttack("peck")
-			local target = actor:performNodeAttack("peck", angle, nodeAngle, 0.33 + 0.67 * charge, charge, def.attack or self:getAttack(), self, x, y)
-			
+			local target = actor:performNodeAttack("peck", angle, nodeAngle, 0.33 + 0.67 * charge, charge,
+				def.attack or self:getAttack(), self, x, y)
+
 			self.charge = 0
 		end
-		
+
 		return true
 	end,
 	useMethod = function(self, actor, angle)
@@ -15138,8 +15208,11 @@
 	useMethod = function(self, actor, angle)
 		local x, y = actor:getSafeWeaponXY()
 		local range = 60
-		local result, hitx, hity, nx, ny, userData, id = actor.map.physics:raycastPoints(x * actor.map.resolution, y * actor.map.resolution, (x + math_cos(angle) * range) * actor.map.resolution, (y + math_sin(angle) * range) * actor.map.resolution, false, _collisionCategory.objectSensor, _collisionFilter.solidActives, actor.bodyFilter)
-		
+		local result, hitx, hity, nx, ny, userData, id = actor.map.physics:raycastPoints(x * actor.map.resolution,
+			y * actor.map.resolution, (x + math_cos(angle) * range) * actor.map.resolution,
+			(y + math_sin(angle) * range) * actor.map.resolution, false, _collisionCategory.objectSensor,
+			_collisionFilter.solidActives, actor.bodyFilter)
+
 		if result then
 			local rayInfo = {
 				nx = nx,
@@ -15147,26 +15220,26 @@
 				userData = userData,
 				id = id
 			}
-			
+
 			rayInfo.target = actor.map.bodyLookup[id]
-			
+
 			if rayInfo.target then
 				rayInfo.owner = actor
 				rayInfo.x = hitx / actor.map.resolution
 				rayInfo.y = hity / actor.map.resolution
 				rayInfo.angle = math_angleBetweenPoints(0, 0, nx, ny)
 				rayInfo.impulse = 1
-				
+
 				if rayInfo.target._category == "actor" or rayInfo.target._category == "object" or rayInfo.target._category == "tile" then
 					if rayInfo.target.propel then
 						rayInfo.target:propel(angle, 17)
 					end
-					
+
 					rayInfo.target:hit(rayInfo, ATTACKS.bite)
 				end
 			end
 		end
-		
+
 		return true
 	end,
 	ai = {
@@ -15199,27 +15272,28 @@
 		if object.lifeTime and object.time > object.lifeTime then
 			object:remove()
 		end
-		
+
 		object.time = object.time + time
-		
+
 		if self.hitActive then
-			object:setAngle(math_approachAngle(object.angle, math_angleBetweenPoints(0, 0, object.dx, object.dy), time * math_pi * 2))
+			object:setAngle(math_approachAngle(object.angle, math_angleBetweenPoints(0, 0, object.dx, object.dy),
+				time * math_pi * 2))
 		end
 	end,
 	onThrowMethod = function(self, actor, object)
 		object:emitSound("spikeAttack", 1, 1, 120)
 		object:setAllowPickup(false)
 		object:setLifeTime(6)
-		
+
 		object.time = 0
 	end,
 	asObjectCollision = function(object, impact)
 		impact.damageModifier = math_min(1, object:getSpeed() / 40)
-		
+
 		if object.itemRef.hitActive and impact.target:hit(impact, ATTACKS.spike) then
 			local x = impact.x or object.x
 			local x, y = x, impact.y or object.y
-			
+
 			object:hitSound(impact, 8)
 			object:emitFxAt("spikeHitFlash", x, y)
 			object:emitSound("spikeHit", 1, 1, 200)
@@ -15229,18 +15303,18 @@
 	asObjectDestroy = function(object, self)
 		if RENDERING then
 			local obj = object:emitFxDebris("spikeDebris", 1)
-			
+
 			obj:setAngle(object.angle)
 			obj:setSpeed(math_random() * math_pi * 2, math_random() * 6 + 6)
 			obj:addSpeedXY(object.dx / 2, object.dy / 2)
 			obj:setLifeTime(15)
 			object.map.physics:setEntityAngleSpeed(obj.body, math_random() * 2 * math_pi - math_random() * 2 * math_pi)
-			
+
 			local details = _config.graphicsFx
-			
+
 			if details > 0 then
 				obj = object:emitFxDebris("spikeDebris", 2)
-				
+
 				obj:setAngle(object.angle)
 				obj:setSpeed(math_random() * math_pi * 2, math_random() * 6 + 6)
 				obj:addSpeedXY(object.dx / 2, object.dy / 2)
@@ -15248,7 +15322,7 @@
 				object.map.physics:setEntityAngleSpeed(obj.body, math_random() * 2 * math_pi - math_random() * 2 * math_pi)
 			end
 		end
-		
+
 		object:remove()
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight)
@@ -15288,7 +15362,7 @@
 	getObjectBulletTimeFactor = function(object)
 		if object then
 			local s = object:getSpeed()
-			
+
 			return math_min(1, s / 57) * 0.75
 		else
 			return 0.75
@@ -15336,9 +15410,9 @@
 	vendorAngle = 0.25 * math_pi,
 	armObjectMethod = function(self, object)
 		object:setLifeTime(self.def.armDuration + self.def.duration * self.def.objectTimeFactor)
-		
+
 		object.blinkTimer = 0
-		
+
 		object:emitSound("chronoBomb", 1, 1, 1050)
 		object:setAllowPickup(false)
 	end,
@@ -15346,68 +15420,68 @@
 		object:setRemovable()
 		self:disarm(object)
 		object:setPhysicsType("debris")
-		
+
 		self.delay = 0
-		
+
 		object:emitFx("chronoGlow")
 	end,
 	asArmedObjectUpdate = function(self, object, time)
 		if self.active then
 			self.effectFade = math_min(1, self.effectFade + time * 200)
-			
+
 			local def = self.def
 			local range = def.range
-			
+
 			if self.delay <= 0 then
 				local details = _config.graphicsFx
-				
+
 				if math_random() < 0.25 + 0.75 * details then
 					local ang = math_randomAngle()
 					local dist = range * math_random() * 0.67
 					local fx = object:emitFxAt("chronoSpark", object.x + math_cos(ang) * dist, object.y + math_sin(ang) * dist)
-					
+
 					fx:setSpeed(ang, (range * 0.75 - dist) * (0.9 + math_random() * 0.2))
-					
+
 					if self.soundDelay <= 0 then
 						fx:emitSound("chronoBlip", 0.4, 1)
-						
+
 						self.soundDelay = 0.2 + math_random() * 0.2
 					end
 				end
-				
+
 				self.delay = 0.0005 + math_random() * 0.005
 			else
 				self.delay = self.delay - time
 			end
-			
+
 			self.soundDelay = self.soundDelay - time / object.timeFactor
 			self.activeTimer = self.activeTimer + time
-			
+
 			object:emitOmniTimeFactor(range, self.def.objectTimeFactor, 1, self.def.actorTimeFactor)
-			
+
 			if object.lifeTime and object.time > object.lifeTime then
 				object:expire()
 			end
-			
+
 			if self.effectFade > 0 then
 				object:emitLoop("chrono", math_min(1, self.effectFade * 25), 2)
 			end
-			
+
 			self:updateVisual(object, time)
 		elseif object.time > self.def.armDuration then
 			object:activate()
 		else
 			object.blinkTimer = object.blinkTimer + time * 14
-			
+
 			local limit = math_max(1.25 - object.time / self.def.armDuration * 1.25, 0)
-			
+
 			if object.blinkTimer > limit + 0.07 then
 				local fx = object:emitPpFx("chronoBombBlink")
-				
+
 				fx:setReference(object)
-				
+
 				object.blinkTimer = 0
-				
+
 				object:emitSound("chronoBombBeep", 0.6, 0.9 + 0.5 * object.time / self.def.armDuration, 400)
 			end
 		end
@@ -15503,17 +15577,17 @@
 	},
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local def = self.def
-		
+
 		video.renderSpriteState(def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if self.armed and self.active then
 			local glows = def.customSprites.glows
 			local activeTimer = self.activeTimer * 300
 			local pi7 = math_pi / 7
-			
+
 			for i = 1, 7 do
 				local light = 255 * math_max(0, math_cos(math_abs(math_angleDifference(i * pi7 + activeTimer, 0))))
-				
+
 				video.renderSpriteState(glows[i], x, y, 1, angle, light, 255, 255, 255, not facingRight)
 			end
 		end
@@ -15568,78 +15642,78 @@
 	iconName = "liquidNitrogen_icon",
 	asObjectDestroy = function(object, self)
 		local amt
-		
+
 		if object.lifeTime then
 			amt = 1 - 0.5 * math_min(1, object.time / object.lifeTime)
 		else
 			amt = 1
 		end
-		
+
 		EXPLOSIONS.chill.emit(object, amt * 4, amt * 175)
 		object:emitSound("nitrogenBoom", 1, 1, 500)
 		object:emitFx("nitrogenSpark")
 	end,
 	armObjectMethod = function(self, object)
 		object:setLifeTime(self.def.armDuration + self.def.duration)
-		
+
 		object.blinkTimer = 0
-		
+
 		object:emitSound("grenadeArm", 1, 1, 1050)
 		object:setAllowPickup(false)
-		
+
 		self.delay = 0
 		self.activeTimer = 0
 	end,
 	asObjectActivate = function(self, object)
 		local fx = object:emitPpFx("nitrogenActiveLight")
-		
+
 		fx:setReference(object)
-		
+
 		self.active_fx = fx
 	end,
 	asArmedObjectUpdate = function(self, object, time)
 		local def = self.def
-		
+
 		if self.active then
 			local active_fx = self.active_fx
-			
+
 			if active_fx and not active_fx._remove then
 				active_fx:setTime(0)
 			else
 				self.active_fx = nil
 			end
-			
+
 			local fx
 			local range = def.range
-			
+
 			if self.delay <= 0 then
 				local ang = math_randomAngle()
 				local dist = range * math_random() / 18
-				
+
 				fx = object:emitFxAt("nitrogen", object.x + math_cos(ang) * dist, object.y + math_sin(ang) * dist)
-				
+
 				fx:setSpeed(ang, range * (0.9 + math_random() * 0.2) * 2)
-				
+
 				self.delay = 0.06 - _config.graphicsFx * 0.04 + math_random() * 0.04
 			else
 				self.delay = self.delay - time
 			end
-			
+
 			self.activeTimer = self.activeTimer + time
-			
+
 			if self.emitDelay <= 0 then
 				object:emitOmniSimpleHitModified(range, 0, ATTACKS.chill, 0.2)
-				
+
 				self.emitDelay = 0.2
 			else
 				self.emitDelay = self.emitDelay - time
 			end
-			
+
 			if object.lifeTime then
 				local prg = math_min(1, object.time / object.lifeTime)
-				
+
 				object:emitLoop("gas", 0.5 - prg * 0.2, 0.85 + prg * 0.25, RANGES.tiny)
-				
+
 				if object.time > object.lifeTime then
 					object:destroy()
 				end
@@ -15648,14 +15722,14 @@
 			object:activate()
 		else
 			object.blinkTimer = object.blinkTimer + time * 14
-			
+
 			if object.blinkTimer > def.armDuration - object.time + 0.07 then
 				local fx = object:emitPpFx("nitrogenBlink")
-				
+
 				fx:setReference(object)
-				
+
 				object.blinkTimer = 0
-				
+
 				object:emitSound("nitrogenBeep", 0.6, 0.9 + 0.5 * object.time / def.armDuration, 400)
 			end
 		end
@@ -15737,7 +15811,7 @@
 	},
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local def = self.def
-		
+
 		video.renderSpriteState(def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
 	end,
 	ai = {
@@ -15789,20 +15863,20 @@
 			local range = def.destroyExplosionRange
 			local intensity = def.destroyExplosionIntensity
 			local amt = 0.5 + math.clamp(0.5 * (life_time - object.time) / life_time, 0, 1)
-			
+
 			object:emitExplosion(self.def.destroyExplosion, math.max(0.5, amt * intensity), range * 0.5 + amt * range * 5)
 		end
 	end,
 	asObjectExpire = function(self, object)
 		object:setRemovable()
-		
+
 		self.armed = false
-		
+
 		object:setPhysicsType("debris")
-		
+
 		self.delay = 0
 		self.depleted = true
-		
+
 		object:emitFx("healSpark")
 	end,
 	logic = {
@@ -15817,12 +15891,12 @@
 		self.delay = 0
 		self.activeTimer = 0
 		object.emitDelay = 0
-		
+
 		object:setLifeTime(self.def.duration)
-		
+
 		object.totalTimer = 0
 		object.blinkTimer = 0
-		
+
 		object:emitSound("chronoBomb", 1, 1, 1050)
 		object:setAllowPickup(false)
 	end,
@@ -15887,12 +15961,12 @@
 	},
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local def = self.def
-		
+
 		video.renderSpriteState(def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if not self.depleted then
 			local light = 255 * math_min(1, 0.75 + 0.25 * math_cos(_time * math_pi * 1.7))
-			
+
 			video.renderSpriteState(def.customSprites.glow, x, y, 1, angle, light * glow, 255, 255, 255, not facingRight)
 		end
 	end,
@@ -15949,9 +16023,9 @@
 		self.delay = 0
 		self.soundPhase = 0
 		object.blinkTimer = 0
-		
+
 		local def = self.def
-		
+
 		object:setLifeTime(def.duration + def.armDuration)
 		object:setAllowPickup(false)
 		object:classify("blockSpawn")
@@ -15961,9 +16035,9 @@
 		object:setRemovable()
 		self:disarm(object)
 		object:setPhysicsType("debris")
-		
+
 		self.delay = 0
-		
+
 		for i = 1, 1 + 2 * _config.graphicsFx do
 			local fx = object:emitFx("klonkFlash")
 		end
@@ -15979,58 +16053,58 @@
 			if self.delay <= 0 then
 				local def = self.def
 				local range = def.range
-				
+
 				self.soundPhase = self.soundPhase - 1
-				
+
 				local amt = math_random()
-				
+
 				if self.soundPhase <= 0 then
 					object:emitSound("klonk", 0.2, 0.9 + amt * 0.2, 1050)
-					
+
 					local fx = object:emitPpFx("klonkBlink")
-					
+
 					fx:setReference(object)
-					
+
 					self.soundPhase = 3
 					amt = amt + 1
 				end
-				
+
 				local detail = _config.graphicsFx
-				
+
 				if math_random() < 0.25 + 0.75 * detail then
 					local fx = object:emitPpFx("klonkBolt")
-					
+
 					fx:setOwner(object)
-					
+
 					local ang = math_randomAngle()
 					local dist = range * 0.33 * amt
-					
+
 					fx:setEnd(object.x + math_cos(ang) * dist, object.y + math_sin(ang) * dist)
 				end
-				
+
 				local new_delay = 0.02 + math_random() * 0.05
 				local hitlist = EXPLOSIONS.klonk.emit(object, 1, range, true)
-				
+
 				if hitlist then
 					local lost_per_hit = def.duration_lost_per_hit
 					local hits = #hitlist
-					
+
 					if lost_per_hit and lost_per_hit > 0 then
 						object.time = object.time + self.def.duration_lost_per_hit * hits
 					end
-					
+
 					local delay_per_hit = def.delay_per_hit
-					
+
 					if delay_per_hit and delay_per_hit > 0 then
 						new_delay = new_delay + delay_per_hit * hits
 					end
 				end
-				
+
 				self.delay = new_delay
 			else
 				self.delay = self.delay - time
 			end
-			
+
 			if object.lifeTime and object.time > object.lifeTime then
 				object:expire()
 			end
@@ -16038,14 +16112,14 @@
 			object:activate()
 		else
 			object.blinkTimer = object.blinkTimer + time * 7
-			
+
 			if object.blinkTimer > self.def.armDuration - object.time + 0.07 then
 				local fx = object:emitPpFx("throwGrenadeBlink")
-				
+
 				fx:setReference(object)
-				
+
 				object.blinkTimer = 0
-				
+
 				object:emitSound("klonkBeep", 0.6, 0.9 + 0.5 * object.time / self.def.armDuration, 400)
 			end
 		end
@@ -16114,17 +16188,19 @@
 	},
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		local light = 0
 		local cusprites = self.def.customSprites
-		
+
 		if self.armed then
 			local pulse = math.clamp(0.5 + 0.5 * math.cos(_time * math.pi * 2), 0, 1)
 			local lightStar = 250 * pulse
 			local light = 250 * pulse
-			
-			video.renderSpriteState(cusprites.klonkStar, x, y, 1, angle, 255, math_min(255, r / 3 + lightStar), math_min(255, r / 3 + lightStar), math_min(255, b / 3 + lightStar), not facingRight)
-			video.renderSpriteState(cusprites.klonkLight, x, y, 1, angle, 255, math_min(255, r / 3 + light), math_min(255, g / 3 + light), math_min(255, b / 3 + light), not facingRight)
+
+			video.renderSpriteState(cusprites.klonkStar, x, y, 1, angle, 255, math_min(255, r / 3 + lightStar),
+				math_min(255, r / 3 + lightStar), math_min(255, b / 3 + lightStar), not facingRight)
+			video.renderSpriteState(cusprites.klonkLight, x, y, 1, angle, 255, math_min(255, r / 3 + light),
+				math_min(255, g / 3 + light), math_min(255, b / 3 + light), not facingRight)
 		else
 			video.renderSpriteState(cusprites.klonkStar, x, y, 1, angle, 255, r / 3, g / 3, b / 3, not facingRight)
 			video.renderSpriteState(cusprites.klonkLight, x, y, 1, angle, 255, r / 3, g / 3, b / 3, not facingRight)
@@ -16175,18 +16251,18 @@
 	iconName = "doomBomb_icon",
 	asObjectDestroy = function(object, self)
 		EXPLOSIONS.thermal.emit(object, 1)
-		
+
 		for index, view in pairs(states.get("game").views) do
 			if view:tracks(object) then
 				view.camera:zoomTo(0.7, 6, 1.5)
 			end
 		end
-		
+
 		object:remove()
 	end,
 	armObjectMethod = function(self, object)
 		object:setAllowPickup(false)
-		
+
 		if self.upgrades and self.upgrades.extendedTimer then
 			self.explodeTimer = 3 + self.upgrades.extendedTimer.level
 		else
@@ -16196,19 +16272,19 @@
 	asArmedObjectUpdate = function(self, object, time)
 		if self.explodeTimer > 0 then
 			self.blinkTimer = self.blinkTimer + time * 7
-			
+
 			if self.blinkTimer > self.explodeTimer / 2 then
 				local fx = object:emitPpFx("grenadeBlink")
-				
+
 				fx:setReference(object)
-				
+
 				self.blinkTimer = 0
-				
+
 				object:emitSound("megaBombBeep", 0.6, 0.9 + 0.5 * (5 - self.explodeTimer) / 5, 600)
 			end
-			
+
 			self.explodeTimer = self.explodeTimer - time
-			
+
 			if self.explodeTimer <= 0 then
 				object:destroy()
 			end
@@ -16223,10 +16299,14 @@
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if self.armed then
-			video.renderSpriteState(self.def.customSprites.doomBomb_glow1, x, y, 1, angle, math_min(255, math_abs(math_cos(_time / self.explodeTimer) * math_cos(_time / self.explodeTimer) * 255) * 3), 255, 255, 255, not facingRight)
-			video.renderSpriteState(self.def.customSprites.doomBomb_glow2, x, y, 1, angle, math_min(255, math_abs(math_cos(_time / self.explodeTimer) * math_sin(_time / self.explodeTimer) * 255) * 3), 255, 255, 255, not facingRight)
+			video.renderSpriteState(self.def.customSprites.doomBomb_glow1, x, y, 1, angle,
+				math_min(255, math_abs(math_cos(_time / self.explodeTimer) * math_cos(_time / self.explodeTimer) * 255) * 3), 255,
+				255, 255, not facingRight)
+			video.renderSpriteState(self.def.customSprites.doomBomb_glow2, x, y, 1, angle,
+				math_min(255, math_abs(math_cos(_time / self.explodeTimer) * math_sin(_time / self.explodeTimer) * 255) * 3), 255,
+				255, 255, not facingRight)
 		end
 	end,
 	customSpriteNames = {
@@ -16585,10 +16665,10 @@
 	},
 	asObjectSensor = function(object, impact)
 		local item = object:getItem()
-		
+
 		if item and item.armed then
 			local target = impact.target
-			
+
 			if target and target._category == "actor" and item.team ~= target.team then
 				target:sendOffer("disarm", object)
 			end
@@ -16596,13 +16676,14 @@
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight)
 		local def = self.def
-		
+
 		video.renderSpriteState(def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if self.armed then
 			local blink = self.blinkTimer / (self.explodeTimer / 2)
-			
-			video.renderSpriteState(def.customSprites.light, x, y, 1, angle, math_min(255, blink * 255), 255, 255, 255, not facingRight)
+
+			video.renderSpriteState(def.customSprites.light, x, y, 1, angle, math_min(255, blink * 255), 255, 255, 255,
+				not facingRight)
 		end
 	end,
 	customSpriteNames = {
@@ -16686,32 +16767,32 @@
 	iconName = "flashbang_icon",
 	asObjectHitSensor = function(object, impact)
 		local collide, hit = genericCheckHitOnlyCollideSelf(object, impact, ATTACKS.sensor)
-		
+
 		if hit and impact.target and impact.target._category == "actor" then
 			object:destroy()
 		end
 	end,
 	armObjectMethod = function(self, object)
 		self.explodeTimer = self.def.lifeTime
-		
+
 		object:setAllowPickup(false)
 	end,
 	asArmedObjectUpdate = function(self, object, time)
 		object:emitLoop("flashbeep5", 0.5, 2 - self.explodeTimer * 0.8, RANGES.medium)
-		
+
 		self.topTimer = self.topTimer + 13 / (self.explodeTimer * 0.5 + 0.1) * time
-		
+
 		if self.explodeTimer > 0 then
 			self.blinkTimer = self.blinkTimer + time * 7
-			
+
 			if self.blinkTimer > 1 then
 				object:emitSound("flashbangBeep", 0.4, 1.1 + 0.2 * self.explodeTimer, 400)
-				
+
 				self.blinkTimer = 0
 			end
-			
+
 			self.explodeTimer = self.explodeTimer - time
-			
+
 			if self.explodeTimer <= 0 then
 				object:destroy()
 			end
@@ -16729,18 +16810,20 @@
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight)
 		local flipped = not facingRight
-		
+
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, flipped)
-		
+
 		local cu_sprites = self.def.customSprites
-		
+
 		if self.armed then
-			video.renderSpriteState(cu_sprites.flashbang_glow, x, y, 1, angle, math_min(255, 255 * math_abs(math_cos(self.topTimer * math_pi / 7))), 255, 255, 255, flipped)
+			video.renderSpriteState(cu_sprites.flashbang_glow, x, y, 1, angle,
+				math_min(255, 255 * math_abs(math_cos(self.topTimer * math_pi / 7))), 255, 255, 255, flipped)
 		end
-		
+
 		local flashbang_name = flashbang_top_names[math_floor(self.topTimer) % 7 + 1]
-		
-		video.renderSpriteState(cu_sprites[flashbang_name], x + math_cos(angle - math_pi * 0.5) * 9, y + math_sin(angle - math_pi * 0.5) * 9, 1, angle, 255, r, g, b, flipped)
+
+		video.renderSpriteState(cu_sprites[flashbang_name], x + math_cos(angle - math_pi * 0.5) * 9,
+			y + math_sin(angle - math_pi * 0.5) * 9, 1, angle, 255, r, g, b, flipped)
 	end,
 	customSpriteNames = {
 		"flashbang_glow",
@@ -16823,7 +16906,7 @@
 local function timedGrenadeBulletTimeFactor(object)
 	if object and object.lifeTime then
 		local prg = math_min(1, object.time / object.lifeTime)
-		
+
 		return (0.1 + 0.9 * prg * prg * prg) * object.def.bulletTimeFactor
 	else
 		return 1 * object.def.bulletTimeFactor
@@ -16833,7 +16916,7 @@
 local function grenadeBulletTimeFactor(object)
 	if object and object.lifeTime then
 		local prg = math_min(1, object.time / object.lifeTime)
-		
+
 		return (0.9 + 0.1 * prg * prg * prg) * object.def.bulletTimeFactor
 	else
 		return 0.9 * object.def.bulletTimeFactor
@@ -16842,15 +16925,15 @@
 
 local function sendHack(owner, entity, master)
 	local obj = owner:emitObject("hackGrenadeBolt")
-	
+
 	obj:setHitActive(true)
 	obj:setTarget(entity)
 	obj:setOwner(master)
 	obj:setEmitter(owner)
 	obj:setSpeedXY(owner.dx, owner.dy)
-	
+
 	local ang = math.angleBetweenPoints(owner.x, owner.y, entity.x, entity.y)
-	
+
 	owner:addSpeed(ang, owner.def.hack_speed_impulse)
 	owner:addSpeed(-math.pi * 0.5, owner.def.hack_speed_impulse * 0.5)
 	owner:emitProximityFeedback(entity)
@@ -16901,7 +16984,7 @@
 		object.blinkTimer = 0
 		self.delay = 0
 		self.soundPhase = 0
-		
+
 		object:setLifeTime(self.def.duration)
 		object:emitSound("grenadeArm", 1, 0.5, 200)
 		object:setAllowPickup(false)
@@ -16912,33 +16995,33 @@
 				local def = self.def
 				local master = object:getOwner()
 				local fx = object:emitPpFx("hackGrenadeSourceFlash")
-				
+
 				fx:setReference(object)
 				fx:applyColor(master and master:getIdentityColor() or def.color)
 				object:emitSound("hackGrenadeBeep", 0.4, 1, 400)
-				
+
 				self.delay = self.def.emit_scan_delay
-				
+
 				if not object.husk and master then
 					local hacks = 0
 					local range = def.range
-					local range2 = range^2
+					local range2 = range ^ 2
 					local hack = false
 					local enemies = object.map.actors.enemiesOfTeam[master.team]
-					
+
 					if enemies then
 						for enemy, _ in pairs(enemies) do
 							local in_range = object:isInRange2(enemy, range2)
-							
+
 							if in_range and enemy:isElectric() then
 								if object:getLosTo(enemy) then
 									sendHack(object, enemy, master)
-									
+
 									hack = true
 									object.time = object.time + def.duration_lost_per_hit
 								else
 									local ang = math.angleBetweenPoints(object.x, object.y, enemy.x, enemy.y)
-									
+
 									object:addSpeed(ang, def.hack_speed_impulse)
 									object:addSpeed(-math.pi * 0.5, def.hack_speed_impulse * 0.5)
 									object:emitSound("proximityFriend", 1, 1)
@@ -16947,30 +17030,30 @@
 							end
 						end
 					end
-					
+
 					local hackable = object.map.objects.hackable
-					
+
 					for obj, _ in pairs(hackable) do
 						if obj.itemRef.armed then
 							local in_range = object:isInRange2(obj, range2)
-							
+
 							if in_range and object:getLosTo(obj) then
 								local owner = obj:getOwner()
-								
+
 								if not owner or master:isThreatened(owner) then
 									sendHack(object, obj, master)
-									
+
 									hack = true
 									object.time = object.time + def.duration_lost_per_hit
 								end
 							end
 						end
 					end
-					
+
 					if hack then
 						self.delay = self.def.emit_found_delay
 					end
-					
+
 					if not hack and object.onGround then
 						object:addSpeed(-math.pi * 0.5, def.jump_speed_impulse)
 						object:emitFx("jetSmoke")
@@ -16979,7 +17062,7 @@
 			else
 				self.delay = self.delay - time
 			end
-			
+
 			if object.time > object.lifeTime then
 				object:performReaction()
 			end
@@ -16987,18 +17070,18 @@
 			if object.time > self.def.armDuration then
 				object:activate()
 			end
-			
+
 			object.blinkTimer = object.blinkTimer + time * 7
-			
+
 			if object.blinkTimer > self.def.armDuration - object.time + 0.1 then
 				local fx = object:emitPpFx("hackGrenadeBlink")
 				local master = object:getOwner()
-				
+
 				fx:setReference(object)
 				fx:applyColor(master and master:getIdentityColor() or self.def.color)
-				
+
 				object.blinkTimer = 0
-				
+
 				object:emitSound("hackGrenadeBeep", 0.6, 1.5 - 0.5 * object.time / self.def.armDuration, 400)
 			end
 		end
@@ -17014,12 +17097,12 @@
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight)
 		local def = self.def
 		local flip = not facingRight
-		
+
 		video.renderSpriteState(def.sprite, x, y, 1, angle, 255, r, g, b, flip)
-		
+
 		if self.armed then
 			local col = self.color
-			
+
 			video.renderSpriteState(def.customSprites.glow, x, y, 1, angle, 255, col.r, col.g, col.b, flip)
 		end
 	end,
@@ -17123,24 +17206,24 @@
 	iconName = "grenade_icon",
 	armObjectMethod = function(self, object)
 		object.blinkTimer = 0
-		
+
 		object:setLifeTime(2)
 		object:emitSound("grenadeArm", 1, 1, 200)
 		object:setAllowPickup(false)
 	end,
 	asArmedObjectUpdate = function(self, object, time)
 		object.blinkTimer = object.blinkTimer + time * 18
-		
+
 		if object.lifeTime then
 			if object.blinkTimer > object.lifeTime then
 				object.blinkTimer = 0
-				
+
 				local fx = object:emitPpFx("grenadeBlinkBig")
-				
+
 				fx:setReference(object)
 				object:emitSound("sphereGrenadeBeep", 0.6, 1.5 - 0.5 * math_max(object.time, 0) / object.lifeTime, 400)
 			end
-			
+
 			if object.time > object.lifeTime then
 				object:destroy()
 			end
@@ -17153,12 +17236,12 @@
 	end,
 	asObjectCollision = function(object, impact)
 		local item = object.itemRef
-		
+
 		if item.armed and impact.target and (impact.target._category == "actor" or impact.target._category == "tile" and impact.target.destructible) then
 			impact.damageModifier = math_min(1, object:getStartSpeed() / 18)
-			
+
 			local collide, hit = genericCheckHitOnlyCollideSelf(object, impact, item:getAttack())
-			
+
 			if collide and hit and impact.target and (collide or impact.target._category == "actor") then
 				object:destroy()
 			end
@@ -17166,17 +17249,17 @@
 	end,
 	asObjectHitSensor = function(object, impact)
 		impact.damageModifier = math_min(1, object:getStartSpeed() / 18)
-		
+
 		local item = object.itemRef
 		local collide, hit = genericCheckHitOnlyCollideSelf(object, impact, item:getAttack())
-		
+
 		if collide and hit and impact.target and impact.target._category == "actor" then
 			object:destroy()
 		end
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if self.armed then
 			video.renderSpriteState(self.def.customSprites.grenadeRed, x, y, 1, angle, 255, 255, 255, 255, not facingRight)
 		end
@@ -17280,48 +17363,48 @@
 	vendorAngle = 0.25 * math_pi,
 	armObjectMethod = function(self, object)
 		object:setLifeTime(self.def.lifeTime)
-		
+
 		object.blinkTimer = 0
-		
+
 		object:setAllowPickup(false)
-		
+
 		object.fireTimer = 0
 	end,
 	asArmedObjectUpdate = function(self, object, time)
 		object.blinkTimer = object.blinkTimer + time * 7
-		
+
 		if object.lifeTime then
 			local prg = math_min(1, object.time / object.lifeTime)
-			
+
 			object:emitLoop("molotovFire", 0.25 + 0.75 * prg, 1)
-			
+
 			if object.time > object.lifeTime then
 				object:destroy()
 			else
 				if object.blinkTimer > (object.lifeTime - object.time) * 0.25 + 0.12 then
 					local fx = object:emitPpFx("molotovBlink")
-					
+
 					fx:setReference(object)
-					
+
 					object.blinkTimer = 0
-					
+
 					object:emitSound("molotov", 0.5, 0.9 + 0.2 * prg, 400)
 				end
-				
+
 				object.fireTimer = object.fireTimer + time
-				
+
 				if object.fireTimer > 0.08 - 0.06 * prg then
 					object.fireTimer = 0
-					
+
 					if math_random() > 0.5 then
 						local fx = object:emitPpFx("molotovFire")
-						
+
 						fx:setSpeed(object.angle - math_pi * 0.5 + math_randomGaussian() * 0.2, math_random() * 80)
 						fx:setAngle(object.angle - math_pi * 0.5)
 						fx:addSpeedXY(object.dx / object.map.resolution * 0.5, object.dy / object.map.resolution * 0.5)
 					else
 						local fx = object:emitPpFx("molotovSmoke")
-						
+
 						fx:setSpeed(object.angle - math_pi * 0.5 + math_randomGaussian() * 0.2, math_random() * 180)
 						fx:setAngle(object.angle - math_pi * 0.5)
 						fx:addSpeedXY(object.dx / object.map.resolution * 0.5, object.dy / object.map.resolution * 0.5)
@@ -17340,10 +17423,10 @@
 	end,
 	asObjectHitSensor = function(object, impact)
 		impact.damageModifier = math_min(1, object:getStartSpeed() / 18)
-		
+
 		local item = object.itemRef
 		local collide, hit = genericCheckHitOnlyCollideSelf(object, impact, item:getAttack())
-		
+
 		if collide and hit and impact.target and impact.target._category == "actor" then
 			object:destroy()
 		end
@@ -17437,43 +17520,43 @@
 	vendorAngle = 0.25 * math_pi,
 	armObjectMethod = function(self, object)
 		object:setLifeTime(1)
-		
+
 		object.blinkTimer = 0
-		
+
 		object:emitSound("grenadeArm", 1, 1, 200)
 		object:setAllowPickup(false)
 	end,
 	asArmedObjectUpdate = function(self, object, time)
 		object.blinkTimer = object.blinkTimer + time * 7
-		
+
 		if object.lifeTime then
 			if object.time > object.lifeTime then
 				object:destroy()
 			elseif object.blinkTimer > math_max(0, object.lifeTime - object.time) + 0.07 then
 				local fx = object:emitPpFx("throwGrenadeBlink")
-				
+
 				fx:setReference(object)
-				
+
 				object.blinkTimer = 0
-				
+
 				local prg = math_min(1, object.time / object.lifeTime)
-				
+
 				object:emitSound("grenadeBeep", 0.6, 0.9 + 0.5 * prg, 400)
 			end
 		end
 	end,
 	asObjectHitSensor = function(object, impact)
 		impact.damageModifier = math_min(1, object:getStartSpeed() / 18)
-		
+
 		local collide, hit = genericCheckHitOnlyCollideSelf(object, impact, ATTACKS.grenade)
-		
+
 		if collide and hit and impact.target and impact.target._category == "actor" then
 			object:destroy()
 		end
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if self.armed then
 			video.renderSpriteState(self.def.customSprites.throwGrenadeRed, x, y, 1, angle, 255, 255, 255, 255, not facingRight)
 		end
@@ -17602,36 +17685,36 @@
 	vendorAngle = 0.15 * math_pi,
 	asObjectDestroy = function(object, self)
 		object:emitExplosion(self.def.explosion, self.def.explosionIntensity)
-		
+
 		for index, view in pairs(states.get("game").views) do
 			if view:tracks(object) then
 				view.camera:zoomTo(0.7, 6, 1.5)
 			end
 		end
-		
+
 		object:remove()
 	end,
 	armObjectMethod = function(self, object)
 		object:setAllowPickup(false)
-		
+
 		self.explodeTimer = self.def.lifeTime
 	end,
 	asArmedObjectUpdate = function(self, object, time)
 		if self.explodeTimer > 0 then
 			self.blinkTimer = self.blinkTimer + time * 7
-			
+
 			if self.blinkTimer > self.explodeTimer / 2 then
 				local fx = object:emitPpFx("grenadeBlink")
-				
+
 				fx:setReference(object)
-				
+
 				self.blinkTimer = 0
-				
+
 				object:emitSound("tickingClock", 0.8, 1.2 + 0.5 * (5 - self.explodeTimer) / 5, 600)
 			end
-			
+
 			self.explodeTimer = self.explodeTimer - time
-			
+
 			if self.explodeTimer <= 0 then
 				object:destroy()
 			end
@@ -17645,10 +17728,14 @@
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if self.armed then
-			video.renderSpriteState(self.def.customSprites.dynamiteGlow1, x, y, 1, angle, math_min(255, math_abs(math_cos(_time / self.explodeTimer) * math_cos(_time / self.explodeTimer) * 255) * 3), 255, 255, 255, not facingRight)
-			video.renderSpriteState(self.def.customSprites.dynamiteGlow2, x, y, 1, angle, math_min(255, math_abs(math_cos(_time / self.explodeTimer) * math_sin(_time / self.explodeTimer) * 255) * 3), 255, 255, 255, not facingRight)
+			video.renderSpriteState(self.def.customSprites.dynamiteGlow1, x, y, 1, angle,
+				math_min(255, math_abs(math_cos(_time / self.explodeTimer) * math_cos(_time / self.explodeTimer) * 255) * 3), 255,
+				255, 255, not facingRight)
+			video.renderSpriteState(self.def.customSprites.dynamiteGlow2, x, y, 1, angle,
+				math_min(255, math_abs(math_cos(_time / self.explodeTimer) * math_sin(_time / self.explodeTimer) * 255) * 3), 255,
+				255, 255, not facingRight)
 		end
 	end,
 	customSpriteNames = {
@@ -17754,9 +17841,9 @@
 	iconName = "stickyMine_icon",
 	armObjectMethod = function(self, object)
 		object:emitSound("grenadeArm", 1, 2, 200)
-		
+
 		local fx = object:emitFx("spikedMineBlinkActivate")
-		
+
 		fx:setReference(object)
 		object:setAllowPickup(false)
 	end,
@@ -17772,9 +17859,10 @@
 	},
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if self.armed then
-			video.renderSpriteState(self.def.customSprites.stickyMineRed, x, y, 1, angle, 255 * math_max(0, math_sign(math_cos(_time * 12 * math_pi))), 255, 255, 255, not facingRight)
+			video.renderSpriteState(self.def.customSprites.stickyMineRed, x, y, 1, angle,
+				255 * math_max(0, math_sign(math_cos(_time * 12 * math_pi))), 255, 255, 255, not facingRight)
 		end
 	end,
 	customSpriteNames = {
@@ -17849,7 +17937,7 @@
 		if object.itemRef.armed then
 			object:destroy()
 		end
-		
+
 		return true
 	end,
 	ai = {
@@ -17886,49 +17974,49 @@
 	asArmedObjectUpdate = function(self, object, time)
 		if math_random() < time * 5 and object:isInView(100) then
 			local obj = object:emitSpark("orangeFireSpark")
-			
+
 			obj:setSpeed(math_random() * math_pi * 2, math_random() * 4)
 			obj:addSpeedXY(object.dx / 2, object.dy / 2)
-			
+
 			obj.time = 1.2
 		end
-		
+
 		object.map.physics:applyEntityTorque(object.body, time * 2 * facingToFlipFactor(not object.flipped))
 	end,
 	asObjectVisualReactionMethod = function(object, x, y, angle)
 		if object:isInView(100) then
 			local detail = _config.graphicsFx
-			
+
 			if detail > 0 then
 				for i = 1, 4 * detail do
 					local obj = object:emitFxDebris("rockDebris", i)
-					
+
 					obj:setAngle(object.angle)
 					obj:setSpeed(math_random() * math_pi * 2, math_random() * 12)
 					obj:addSpeed(angle, 5)
 					obj:setLifeTime(15)
 					obj:addSpeedXY(object.dx, object.dy)
 				end
-				
+
 				for i = 1, (3 + math_random(3)) * detail do
 					object:emitFx("plasmaSmoke"):setSpeed(math_pi * 2 * math_random(), math_random(155))
 				end
 			end
-			
+
 			object:emitFx("plasmaGlow")
-			
+
 			if detail > 0 then
 				for i = 1, 1 * detail + math_random(5) * detail do
 					local obj = object:emitSparkAt("orangeFireSpark", x, y)
-					
+
 					obj:setSpeed(math_random() * math_pi * 2, 8)
 					obj:addSpeedXY(object.dx, object.dy)
 				end
 			end
-			
+
 			object:emitFx("rockFlash")
 		end
-		
+
 		object:emitSound("rockHit", 0.5, 1, 450)
 		object:remove()
 	end,
@@ -17938,16 +18026,16 @@
 	asObjectCollision = function(object, impact)
 		if object.itemRef.hitActive then
 			object:performReaction(impact)
-			
+
 			if object:isInView(100) then
 				object:emitFx("rockFlash")
-				
+
 				local detail = _config.graphicsFx
-				
+
 				if detail > 0 then
 					for i = 1, (2 + math_random(5)) * detail do
 						local obj = object:emitSparkAt("orangeFireSpark", impact.x, impact.y)
-						
+
 						obj:setSpeed(math_random() * math_pi * 2, 12)
 						obj:addSpeedXY(object.dx, object.dy)
 					end
@@ -17957,13 +18045,13 @@
 	end,
 	asObjectHitSensor = function(object, impact)
 		local damage_mod = object:getStartSpeed() / 18
-		
+
 		if damage_mod > 1 then
 			impact.damageModifier = math_sqrt(damage_mod)
 		else
 			impact.damageModifier = damage_mod * damage_mod
 		end
-		
+
 		if impact.target:hit(impact, ATTACKS.rock) then
 			object:performReaction(impact)
 			object:setAllowPickup(false)
@@ -17974,12 +18062,13 @@
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		local bad = 255 * (1 - self.dieOff)
 		local good = 255 * math_max(0, 1 - self.dieOff * 16)
 		local cusprites = self.def.customSprites
-		
-		video.renderSpriteState(cusprites.rock_light, x, y, 1, angle, 255, glow * good, glow * good, glow * bad, not facingRight)
+
+		video.renderSpriteState(cusprites.rock_light, x, y, 1, angle, 255, glow * good, glow * good, glow * bad,
+			not facingRight)
 		video.renderSpriteState(cusprites.rock_glow, x, y, 1, angle, glow * bad, good, good, 255, not facingRight)
 	end,
 	customSpriteNames = {
@@ -18044,10 +18133,10 @@
 
 local function armSpawnActorObject(self, object)
 	object:setLifeTime(self.def.lifeTime or 0.75)
-	
+
 	self.glowTimer = 0
 	self.blinkTimer = 0
-	
+
 	object:setAllowPickup(false)
 end
 
@@ -18056,27 +18145,27 @@
 		if self.glowTimer > 0 then
 			self.glowTimer = math_max(0, self.glowTimer - time * 5)
 		end
-		
+
 		self.blinkTimer = self.blinkTimer + time * (self.def.blinkSpeed or 8) / math_max(0.01, object.lifeTime - object.time)
-		
+
 		if self.blinkTimer >= 1 then
 			self.glowTimer = 1
 			self.blinkTimer = 0
-			
+
 			local fx = object:emitPpFx(self.def.smokeFx)
-			
+
 			fx:setSpeed(math_randomAngle(), math_random() * 120)
 			fx:addSpeed(-math_pi * 0.5, 55)
-			
+
 			local amt = math.min(1, object.time / object.lifeTime)
-			
+
 			object:flashWhite(amt / 4)
 		end
-		
+
 		if object.time > object.lifeTime and not object.husk then
 			local owner = object:getHelperOwner()
 			local actor
-			
+
 			if owner and owner:getNumberOfHelpers() >= owner:getMaxHelpers() then
 				object:returnToOwner()
 			else
@@ -18085,21 +18174,21 @@
 				else
 					actor = self:spawnActorHelper(object)
 				end
-				
+
 				if actor then
 					if actor.ai then
 						actor.ai:removeConcept("communicate")
 					end
-					
+
 					actor:setSpeedXY(object.dx, object.dy)
 					actor:setDefaultAi()
 					actor:materialize(object, 0.25)
-					
+
 					if owner and owner.team then
 						actor:setTeam(owner.team)
 						actor:setFacing(owner.x < object.x)
 						actor:setMaster(owner)
-						
+
 						if owner.aimedAtTarget and owner.aimedAtTarget._category == "actor" then
 							actor.ai:assumeConfirmed(actor, owner.aimedAtTarget)
 						end
@@ -18109,9 +18198,9 @@
 				else
 					print("missing actor def")
 				end
-				
+
 				local fx = object:emitPpFx(self.def.glowFx)
-				
+
 				fx:setReference(object)
 				object:destroy()
 			end
@@ -18131,17 +18220,19 @@
 	local cusprites = def.customSprites
 	local flipped = not facingRight
 	local xo, yo = math_cos(angle - math_pi * 0.5), math_sin(angle - math_pi * 0.5)
-	
-	video.renderSpriteState(cusprites.stick1, x + xo * (ext * 14 - 12), y + yo * (ext * 14 - 12), 1, angle, 255, r, g, b, flipped)
-	video.renderSpriteState(cusprites.stick2, x + xo * (ext * 24 - 12), y + yo * (ext * 24 - 12), 1, angle, 255, r, g, b, flipped)
+
+	video.renderSpriteState(cusprites.stick1, x + xo * (ext * 14 - 12), y + yo * (ext * 14 - 12), 1, angle, 255, r, g, b,
+		flipped)
+	video.renderSpriteState(cusprites.stick2, x + xo * (ext * 24 - 12), y + yo * (ext * 24 - 12), 1, angle, 255, r, g, b,
+		flipped)
 	video.renderSpriteState(def.sprite, x, y, 1, angle, 255, r, g, b, flipped)
-	
+
 	local tx, ty = x + xo * (ext * 22 + 7), y + yo * (ext * 22 + 7)
-	
+
 	video.renderSpriteState(cusprites.top, tx, ty, 1, angle, 255, r, g, b, flipped)
-	
+
 	local blinkTimer = self.blinkTimer
-	
+
 	if blinkTimer > 0 then
 		video.renderSpriteState(cusprites.light, tx, ty, 1, angle, 255 * blinkTimer, 255, 255, 255, flipped)
 		video.renderSpriteState(cusprites.glow, tx, ty, 1, angle, 255 * blinkTimer, 255, 255, 255, flipped)
@@ -18412,28 +18503,28 @@
 			local owner = object:getOwner()
 			local spawnLevel = 1
 			local actorClass = self:getSpawnedActorClass(owner)
-			
+
 			if actorClass then
 				local actor = actorClasses.getActor(actorClass, spawnLevel, true, not self.flipped)
-				
+
 				if actor then
 					local facing = not object.flipped
-					
+
 					actor:adaptToUpwardsAngle(facing, angle)
 					actor:setSync("Actor")
 					actor:setDefaultAi()
 					actor:setIsSimpleHelper(true)
-					
+
 					local new_item = actor:copySelectedItemBy(owner)
-					
+
 					if new_item then
 						actor:addItem(new_item)
 					end
-					
+
 					actor:moveToEnt(object)
-					
+
 					self.spawned = true
-					
+
 					if owner and owner.team then
 						actor:setMaster(owner)
 					else
@@ -18442,17 +18533,17 @@
 				end
 			end
 		end
-		
+
 		object:remove()
-		
+
 		return true
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if self.armed then
 			local cusprites = self.def.customSprites
-			
+
 			video.renderSpriteState(cusprites.glow, x, y, 1, angle, 255, 255, 255, 255, not facingRight)
 		end
 	end,
@@ -18591,21 +18682,21 @@
 		local dist = exp * 5
 		local dn = angle + math.pi * 0.5
 		local rx, ry = x + math_cos(dn) * dist, y + math_sin(dn) * dist
-		
+
 		r, g, b = colors.fadeVariables(r, g, b, COLORS.white, exp * 0.75)
-		
+
 		video.renderSpriteState(cusprites.foot, rx, ry, 1, angle, 255, r, g, b, flipped)
 		video.renderSpriteState(def.sprite, x, y, 1, angle, 255, r, g, b, flipped)
-		
+
 		local col = self.def.color
-		
+
 		if self.active then
 			local glow_sprite = cusprites.glows[math.normalize(math.floor(self.blinkTimer * 6), 1, 3)]
-			
+
 			video.renderSpriteState(glow_sprite, x, y, 1, angle, 255, col.r, col.g, col.b, flipped)
 		else
 			local glows = cusprites.glows
-			
+
 			for i = 1, 3 do
 				video.renderSpriteState(glows[i], x, y, 1, angle, exp * 255, col.r, col.g, col.b, flipped)
 			end
@@ -18770,9 +18861,10 @@
 	initMethod = initSpawnActor,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if self.glowTimer then
-			video.renderSpriteState(self.def.customSprites.glow, x, y, 1, angle, math_min(255 * self.glowTimer, 255), 255, 255, 255, not facingRight)
+			video.renderSpriteState(self.def.customSprites.glow, x, y, 1, angle, math_min(255 * self.glowTimer, 255), 255, 255,
+				255, not facingRight)
 		end
 	end,
 	customSpriteNames = {
@@ -18786,7 +18878,7 @@
 				end
 			end
 		end
-		
+
 		return "myceliaMilitia"
 	end,
 	asObjectPhysics = {
@@ -18939,27 +19031,28 @@
 	asObjectCollision = function(object, impact)
 		if object.itemRef.hitActive then
 			local owner = object:getHelperOwner()
-			
+
 			if owner and owner:getNumberOfHelpers() >= owner:getMaxHelpers() then
 				object:returnToOwner()
 			else
 				if not object.husk then
 					local bird = object:spawnActor("bird")
-					
+
 					if owner and owner.team then
 						bird:setTeam(owner.team)
 						bird:setMaster(owner)
 					else
 						bird:setTeam(object.map:getGame():getOrCreateTeam("monster"))
 					end
-					
+
 					bird:setDropsAll(true)
 					bird:setFacing(object.dx > 0)
 					bird:setSpeedXY(object.dx, object.dy)
 				end
-				
+
 				object:emitSound("eggHatch", 1, 1, 450)
-				helpers.fxGenerator("eggShells", object.map, object.x, object.y, 1, 1, impact.angle, impact.impulse, nil, object:getOwner())
+				helpers.fxGenerator("eggShells", object.map, object.x, object.y, 1, 1, impact.angle, impact.impulse, nil,
+					object:getOwner())
 				object:remove()
 			end
 		end
@@ -19116,10 +19209,10 @@
 	end,
 	asObjectCollision = function(object, impact)
 		local itemRef = object.itemRef
-		
+
 		if itemRef.hitActive then
 			local collide, hit = genericCheckHitOnlyCollideSelf(object, impact, itemRef:getAttack())
-			
+
 			if collide and hit then
 				object:destroy()
 			end
@@ -19127,27 +19220,28 @@
 	end,
 	asObjectDestroy = function(object, self)
 		local detail = _config.graphicsFx
-		
+
 		if detail > 0 then
 			for i = 1, (4 + math_random(6)) * detail do
 				object:emitFx("vialSmoke"):setSpeed(math_pi * 2 * math_random(), math_random(200))
 			end
 		end
-		
+
 		object:emitFx("vialFlash")
 		object:emitSound("vialHit", 1, 1, 200)
 		object:remove()
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local cusprites = self.def.customSprites
-		
+
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(cusprites.vial_light, x, y, 1, angle, 255 * glow, 255, 255, 255, not facingRight)
 		video.renderSpriteState(cusprites.vial_glass, x, y, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(cusprites.vial_glow, x, y, 1, angle, 255 * glow, 255, 255, 255, not facingRight)
-		
+
 		if self.armed then
-			video.renderSpriteState(cusprites.vial_glow, x, y, 1.2, angle, (128 + math_cos(_time * 15) * 127) * glow, 255, 255, 255, not facingRight)
+			video.renderSpriteState(cusprites.vial_glow, x, y, 1.2, angle, (128 + math_cos(_time * 15) * 127) * glow, 255, 255,
+				255, not facingRight)
 		end
 	end,
 	customSpriteNames = {
@@ -19226,10 +19320,10 @@
 	},
 	asObjectCollision = function(object, impact)
 		local item = object.itemRef
-		
+
 		if item.hitActive then
 			local collide, hit = genericCheckHitOnlyCollideSelf(object, impact, item:getAttack())
-			
+
 			if collide and hit then
 				object:emitReaction((impact.angle or math.randomAngle()) + math.pi)
 			end
@@ -19237,13 +19331,13 @@
 	end,
 	asObjectDestroy = function(object, self)
 		local detail = _config.graphicsFx
-		
+
 		if detail > 0 then
 			for i = 1, (4 + math_random(6)) * detail do
 				object:emitFx("chemicalSmoke"):setSpeed(math_pi * 2 * math_random(), math_random(200))
 			end
 		end
-		
+
 		object:emitFx("chemicalFlash")
 		object:emitSound("chemicalShot", 1, 1, RANGES.medium)
 		object:emitSound("vialHit", 1, 1, 200)
@@ -19251,14 +19345,15 @@
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local cusprites = self.def.customSprites
-		
+
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(cusprites.vialRad_light, x, y, 1, angle, 255 * glow, 255, 255, 255, not facingRight)
 		video.renderSpriteState(cusprites.vialRad_glass, x, y, 1, angle, 255, r, g, b, not facingRight)
 		video.renderSpriteState(cusprites.vialRad_glow, x, y, 1, angle, 255 * glow, 255, 255, 255, not facingRight)
-		
+
 		if self.armed then
-			video.renderSpriteState(cusprites.vialRad_glow, x, y, 1.2, angle, (128 + math_cos(_time * 15) * 127) * glow, 255, 255, 255, not facingRight)
+			video.renderSpriteState(cusprites.vialRad_glow, x, y, 1.2, angle, (128 + math_cos(_time * 15) * 127) * glow, 255,
+				255, 255, not facingRight)
 		end
 	end,
 	customSpriteNames = {
@@ -19814,7 +19909,9 @@
 	color = COLORS.stunShield,
 	effect_color = COLORS.shieldEffect,
 	getEffectRange = function(self)
-		return 150 + (self.upgrades.effect and self.upgrades.effect.level or 0) * math_max(25, 50 - (self.upgrades.range and self.upgrades.range.level or 0) * 5)
+		return 150 +
+		(self.upgrades.effect and self.upgrades.effect.level or 0) *
+		math_max(25, 50 - (self.upgrades.range and self.upgrades.range.level or 0) * 5)
 	end,
 	getEffectIntensity = function(self)
 		return 1 + (self.upgrades.effect and self.upgrades.effect.level or 0)
@@ -20718,34 +20815,38 @@
 	stackable = true,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		local intensity = math_heartPulse(_time / 0.85)
 		local glowing = 0.6 + math_cos(_time * math_pi * 2 / 0.85) * 0.33
 		local cusprites = self.def.customSprites
-		
-		video.renderSpriteState(cusprites.respawnCellLight, x, y, 1, angle, 255, math_min(255, r / 3 + 255 * intensity), math_min(255, g / 3 + 255 * intensity), math_min(255, b / 3 + 255 * intensity), not facingRight)
-		video.renderSpriteState(cusprites.respawnCellDiod, x, y, 1, angle, 255, math_min(255, r / 3 + 255 * glowing), math_min(255, g / 3 + 255 * glowing), math_min(255, b / 3 + 255 * glowing), not facingRight)
-		video.renderSpriteState(cusprites.respawnCellGlow, x, y, 1, angle, math_min(255 * intensity, 255), 255, 255, 255, not facingRight)
-		video.renderSpriteState(cusprites.respawnCellDiodGlow, x, y, 1, angle, math_min(255 * glowing, 255), 255, 255, 255, not facingRight)
+
+		video.renderSpriteState(cusprites.respawnCellLight, x, y, 1, angle, 255, math_min(255, r / 3 + 255 * intensity),
+			math_min(255, g / 3 + 255 * intensity), math_min(255, b / 3 + 255 * intensity), not facingRight)
+		video.renderSpriteState(cusprites.respawnCellDiod, x, y, 1, angle, 255, math_min(255, r / 3 + 255 * glowing),
+			math_min(255, g / 3 + 255 * glowing), math_min(255, b / 3 + 255 * glowing), not facingRight)
+		video.renderSpriteState(cusprites.respawnCellGlow, x, y, 1, angle, math_min(255 * intensity, 255), 255, 255, 255,
+			not facingRight)
+		video.renderSpriteState(cusprites.respawnCellDiodGlow, x, y, 1, angle, math_min(255 * glowing, 255), 255, 255, 255,
+			not facingRight)
 	end,
 	asObjectUpdate = function(self, object, time)
 		if object:isInView(500) then
 			local pulse = _time * math_pi * 2 / 0.85
-			
+
 			if math_abs(math_cos(math_min(0.5 * math_pi, math_abs(math_angleDifference(1.12 * math_pi, pulse)) / 0.06))) > 0.2 then
 				if not self.pulse1 then
 					object:emitSound("respawnCell2", 0.2, 1.2)
-					
+
 					self.pulse1 = true
 				end
 			else
 				self.pulse1 = false
 			end
-			
+
 			if math_abs(math_cos(math_min(0.5 * math_pi, math_abs(math_angleDifference(1.7 * math_pi, pulse)) / 0.51))) > 0.2 then
 				if not self.pulse2 then
 					object:emitSound("respawnCell", 0.3, 1.2)
-					
+
 					self.pulse2 = true
 				end
 			else
@@ -20789,7 +20890,7 @@
 
 local function renderAmmoBox(self, x, y, angle, r, g, b, facingRight)
 	video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, facingRight)
-	
+
 	if self.ammoText then
 		video.renderBubbleTextSprites(self.ammoText, x, y - 29, 1, "small", 191.25, 128, 255, 32, nil, 0.65)
 	end
@@ -20800,21 +20901,26 @@
 	local scale = (0.9 + math_cos(_time * math_pi * 2) * 0.1) * self.fade * self.def.scale
 	local li = 25 + 200 * self.blink
 	local alp = 200 - 100 * self.fade
-	
-	video.renderSpriteState(self.def.customSprites.bg, x, y, scale, 0, alp, li * ti.r, li * ti.g, li * ti.b, not facingRight)
-	
+
+	video.renderSpriteState(self.def.customSprites.bg, x, y, scale, 0, alp, li * ti.r, li * ti.g, li * ti.b,
+		not facingRight)
+
 	if self.item then
-		local rx, ry = x + math_cos(self.seed + _time * 0.6 * math_pi) * 1, y + math_sin(self.seed + _time * 0.9511 * math_pi + math_cos(self.seed + _time * 0.2 * math_pi)) * 2
-		
+		local rx, ry = x + math_cos(self.seed + _time * 0.6 * math_pi) * 1,
+				y + math_sin(self.seed + _time * 0.9511 * math_pi + math_cos(self.seed + _time * 0.2 * math_pi)) * 2
+
 		self.item:renderAligned(rx, ry, 1, 1, 0, 255 * self.fade, 255 * self.fade, 255 * self.fade, facingRight)
-		
+
 		local st = self.item:getStack()
-		
+
 		if st > 1 then
-			video.renderShadowedTextSprites(st, rx, ry - 20 + fonts.alignY("small"), 1, "small", self.fade * 200, ti.r * 255, ti.g * 255, ti.b * 255)
+			video.renderShadowedTextSprites(st, rx, ry - 20 + fonts.alignY("small"), 1, "small", self.fade * 200, ti.r * 255,
+				ti.g * 255, ti.b * 255)
 		end
 	elseif self.cooldown > 0 then
-		video.renderSpriteState(self.def.customSprites.fg, x, y, scale * (self.startCooldown - self.cooldown) / self.startCooldown, 0, 30, 255 * ti.r, 255 * ti.g, 255 * ti.b, not facingRight)
+		video.renderSpriteState(self.def.customSprites.fg, x, y,
+			scale * (self.startCooldown - self.cooldown) / self.startCooldown, 0, 30, 255 * ti.r, 255 * ti.g, 255 * ti.b,
+			not facingRight)
 	end
 end
 
@@ -20822,11 +20928,13 @@
 	if self.cooldown <= 0 then
 		local ti = self.def.tint
 		local scale = (0.9 + math_cos(_time * math_pi * 2) * 0.1) * self.fade * self.def.scale
-		local rx, ry = x + math_cos(self.seed + _time * 0.6 * math_pi) * 1, y + math_sin(self.seed + _time * 0.9511 * math_pi + math_cos(self.seed + _time * 0.2 * math_pi)) * 2
+		local rx, ry = x + math_cos(self.seed + _time * 0.6 * math_pi) * 1,
+				y + math_sin(self.seed + _time * 0.9511 * math_pi + math_cos(self.seed + _time * 0.2 * math_pi)) * 2
 		local op = 1 - self.blink
 		local rr, gg, bb = ti.r * 255, ti.g * 255, ti.b * 255
-		
-		video.renderSpriteState(self.def.customSprites.main, rx, ry, 1 * scale * 1.4, 0, op * 255 * self.fade, rr * 0.65, gg * 0.65, bb * 0.65)
+
+		video.renderSpriteState(self.def.customSprites.main, rx, ry, 1 * scale * 1.4, 0, op * 255 * self.fade, rr * 0.65,
+			gg * 0.65, bb * 0.65)
 		video.renderSpriteState(self.def.customSprites.icon, rx, ry, 1 * scale, 0, op * 255 * self.fade, rr, gg, bb)
 	end
 end
@@ -20840,31 +20948,31 @@
 local function tryToUpgrade(item, inventory, object, actor)
 	if item:isUpgradableWithAnyType() then
 		local list = item:getFittingUpgrades()
-		
+
 		if #list > 0 then
 			local upg = list[math_random(1, #list)]
 			local upgrade = Item:new(upg)
 			local level = item:getUpgradeLevel(upgrade.def.upgrade)
-			
+
 			upgrade:setLevel(level + 1)
-			
+
 			local ok, blocking, reason = inventory:canAdd(upgrade)
-			
+
 			if ok then
 				inventory:add(upgrade, object)
-				
+
 				if actor then
 					actor.upgrades = (actor.upgrades or 0) + 1
-					
+
 					actor:emitUpgradeFx(item, upg)
 					actor:flashWhite(0.5)
 					actor:heal(0.5)
 				end
-				
+
 				if object then
 					object:remove()
 				end
-				
+
 				return true
 			else
 				return false
@@ -20880,25 +20988,25 @@
 local function giveUpgradeSpaceMethod(self, inventory)
 	if self.def.upgradeCurrent then
 		local item = inventory:getItem()
-		
+
 		if item and item:anyFittingUpgrades() then
 			return true
 		end
 	end
-	
+
 	if self.def.upgradeItems then
 		local items = inventory:getItems()
-		
+
 		for index, item in pairs(items) do
 			if item:anyFittingUpgrades() then
 				return true
 			end
 		end
 	end
-	
+
 	if self.def.upgradeEquipment then
 		local eqs = inventory:getEquipmentSlots()
-		
+
 		for index, slot in pairs(eqs) do
 			for index, item in pairs(slot.items) do
 				if item:anyFittingUpgrades() then
@@ -20907,7 +21015,7 @@
 			end
 		end
 	end
-	
+
 	return false
 end
 
@@ -20915,25 +21023,25 @@
 	if self.cooldown <= 0 then
 		if self.def.upgradeCurrent then
 			local item = inventory:getItem()
-			
+
 			if item and canUpgrade(item) then
 				return true
 			end
 		end
-		
+
 		if self.def.upgradeItems then
 			local items = inventory:getItems()
-			
+
 			for index, item in pairs(items) do
 				if item and canUpgrade(item) then
 					return true
 				end
 			end
 		end
-		
+
 		if self.def.upgradeEquipment then
 			local eqs = inventory:getEquipmentSlots()
-			
+
 			for index, slot in pairs(eqs) do
 				for index, item in pairs(slot.items) do
 					if canUpgrade(item) then
@@ -20943,20 +21051,20 @@
 			end
 		end
 	end
-	
+
 	return false, nil, "nothing_to_upgrade"
 end
 
 local function giveUpgrade(self, inventory, object, actor)
 	local main_reason = "nothing_to_upgrade"
-	
+
 	if self.cooldown <= 0 then
 		if self.def.upgradeCurrent then
 			local item = inventory:getItem()
-			
+
 			if item then
 				local ok, reason = tryToUpgrade(item, inventory, object, actor)
-				
+
 				if ok then
 					return true
 				else
@@ -20964,14 +21072,14 @@
 				end
 			end
 		end
-		
+
 		if self.def.upgradeItems then
 			local items = inventory:getItems()
-			
+
 			for index, item in pairs(items) do
 				if item then
 					local ok, reason = tryToUpgrade(item, inventory, object, actor)
-					
+
 					if ok then
 						return true
 					else
@@ -20980,14 +21088,14 @@
 				end
 			end
 		end
-		
+
 		if self.def.upgradeEquipment then
 			local eqs = inventory:getEquipmentSlots()
-			
+
 			for index, slot in pairs(eqs) do
 				for index, item in pairs(slot.items) do
 					local ok, reason = tryToUpgrade(item, inventory, object, actor)
-					
+
 					if ok then
 						return true
 					else
@@ -20997,7 +21105,7 @@
 			end
 		end
 	end
-	
+
 	return false, nil, main_reason
 end
 
@@ -21009,16 +21117,16 @@
 	else
 		self.fade = obj.fade
 		self.blinkDelay = self.blinkDelay + time
-		
+
 		if self.blinkDelay > self.fade then
 			self.blinkDelay = 0
 			self.blink = 1 - self.fade * 0.75
 		end
 	end
-	
+
 	if self.blink > 0 then
 		self.blink = self.blink - time * (2 + 2 * (1 - (obj.fade or 0)))
-		
+
 		if self.blink <= 0 then
 			self.blink = 0
 		end
@@ -21030,7 +21138,7 @@
 		self.cooldown = self.cooldown - time
 		self.fade = 0.5
 	end
-	
+
 	crateUpdateVisual(self, obj, time)
 end
 
@@ -21038,27 +21146,27 @@
 	if not obj.fading then
 		if self.cooldown <= 0 and self.def.spawnItem and not self.item and self.spawnedItem then
 			local item = Item:newCopy(self.spawnedItem)
-			
+
 			if item then
 				item:setStack(self.spawnedItem:getStack() or 1)
 				item:setDefaultUpgrades(self.spawnedItem:getTotalUpgrades())
-				
+
 				if self.def.requireUnique then
 					item:setDestroyOnDrop()
-					
+
 					item.requireUnique = true
 				end
 			end
-			
+
 			self:setItem(item)
 		end
-		
+
 		if self.cooldown > 0 then
 			self.cooldown = self.cooldown - time
 			self.fade = 0.5
 		end
 	end
-	
+
 	crateUpdateVisual(self, obj, time)
 end
 
@@ -21080,11 +21188,13 @@
 	local ti = self.tintLight or self.def.tintLight
 	local fade = self.fade
 	local blink = self.blink
-	
-	video.renderSpriteState(FX.itemShine.sprite, x, y, fade * 1 * math_max(0, 1 + 0.15 * math_cos(_time + self.seed)) + 0.1 * blink, 0, 50 + 40 * blink, 255 * ti.r, 255 * ti.g, 255 * ti.b)
-	
+
+	video.renderSpriteState(FX.itemShine.sprite, x, y,
+		fade * 1 * math_max(0, 1 + 0.15 * math_cos(_time + self.seed)) + 0.1 * blink, 0, 50 + 40 * blink, 255 * ti.r,
+		255 * ti.g, 255 * ti.b)
+
 	local scale = (0.9 + math_cos(_time * math_pi * 2) * 0.1) * fade * def.scale
-	
+
 	video.renderSpriteState(self.def.customSprites.bg, x, y, scale, 0, 200 * fade, 15, 15, 15, not obj.flipped)
 end
 
@@ -21092,7 +21202,7 @@
 	self.shader = self.broken and SHADERS.dashifyBroken or SHADERS.dashify
 	self.tint = self.broken and TINTS.brokenCrate or self.def.tint
 	self.tintLight = self.broken and TINTS.brokenCrateLight or self.def.tintLight
-	
+
 	self:setCrate(object)
 	self:refreshCrate()
 end
@@ -21112,7 +21222,7 @@
 		self:setCooldown(self:getSpawnCooldown() * self.item:getSpawnCooldown())
 		self:setItem(nil)
 	end
-	
+
 	return true
 end
 
@@ -21405,7 +21515,7 @@
 local function ammoBoxAsObject(self, object)
 	if self.ammoType then
 		local ammo = self.ammo or 0
-		
+
 		self.ammoText = ammo .. " " .. localize.get(Item.getLocalizedNameId(self.ammoType) .. string.ifPlural(ammo))
 	end
 end
@@ -21621,16 +21731,16 @@
 		if not self.target then
 			self.def.findTarget(self, actor)
 		end
-		
+
 		if self.target then
 			actor:activateItem(self)
 			actor:emitSound("hackDevice", 1, 1, 350)
 		else
 			actor:deactivateItem(self)
-			
+
 			self.controlProgress = 0
 		end
-		
+
 		return self.def.cooldown
 	end,
 	initRuntimeMethod = function(self)
@@ -21641,39 +21751,41 @@
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if self.target then
 			local cusprites = self.def.customSprites
-			
-			video.renderSpriteState(cusprites.led, x, y, 1, angle, 175 + 50 * math_cos(_time * math_pi * 5), hackColor.r, hackColor.g, hackColor.b, not facingRight)
-			
+
+			video.renderSpriteState(cusprites.led, x, y, 1, angle, 175 + 50 * math_cos(_time * math_pi * 5), hackColor.r,
+				hackColor.g, hackColor.b, not facingRight)
+
 			if self.active then
-				video.renderSpriteState(cusprites.glow, x, y, 1, angle, 90 * (1 + 0.45 * math_cos(_time * math_pi * 5)), hackColor.r, hackColor.g, hackColor.b, not facingRight)
+				video.renderSpriteState(cusprites.glow, x, y, 1, angle, 90 * (1 + 0.45 * math_cos(_time * math_pi * 5)),
+					hackColor.r, hackColor.g, hackColor.b, not facingRight)
 			end
 		end
 	end,
 	findTarget = function(self, actor)
 		local bestAngleDiff = math_pi * 0.45
-		
+
 		if self.active then
 			bestAngleDiff = math_pi * 2
 		end
-		
+
 		local bestDist = 400
 		local bestEnemy
-		
+
 		if not self.active and actor.map then
 			for index, enemy in pairs(actor.map.actors.all) do
 				if enemy:isHackable() and (actor:isThreatened(enemy) or enemy == self.target) then
 					local dist = math_distance(actor.x, actor.y, enemy.x, enemy.y)
-					
+
 					if dist <= bestDist then
 						local ang = math_angleBetweenPoints(actor.x, actor.y, enemy.x, enemy.y)
 						local angDiff = math_angleDifference(actor:getAbsoluteWeaponAngle(), ang)
-						
+
 						if bestAngleDiff >= math_abs(angDiff) then
 							local result, impact = actor:losCheck(enemy, 400, false, nil, true)
-							
+
 							if impact and impact.target and impact.target == enemy then
 								bestEnemy = enemy
 								bestDist = dist
@@ -21685,18 +21797,18 @@
 			end
 		elseif self.target then
 			local dist = math_distance(actor.x, actor.y, self.target.x, self.target.y)
-			
+
 			if dist < 1000 then
 				bestEnemy = self.target
 			end
 		end
-		
+
 		if bestEnemy then
 			if not self.active then
 				if self.target then
 					actor:setHackingTarget(nil)
 				end
-				
+
 				self.target = bestEnemy
 			end
 		else
@@ -21707,15 +21819,15 @@
 		if actor then
 			actor:releaseHackingTarget()
 		end
-		
+
 		for index, big in pairs(self.bigBolts) do
 			big:remove()
 		end
-		
+
 		if self.hackObject then
 			self.hackObject:remove()
 		end
-		
+
 		self.controlProgress = 0
 		self.target = nil
 	end,
@@ -21727,62 +21839,62 @@
 				self.checkDelay = self.checkDelay - time
 			elseif not self.active then
 				self.def.findTarget(self, actor, time)
-				
+
 				self.checkDelay = 0.1
 			end
 		end
-		
+
 		local target = self.target
-		
+
 		if target and self.active then
 			if target._remove then
 				actor:deactivateItem(self)
 			end
-			
+
 			if self.controlProgress >= 1 then
 				target:blockAiForThisLoop()
-				
+
 				if self.hackObject then
 					self.hackObject:remove()
 				end
-				
+
 				for index, input in pairs(cancelControls) do
 					if actor.input[input] then
 						actor:deactivateItem(self)
 						actor.input:blockSenderAction(input)
-						
+
 						break
 					end
 				end
 			else
 				local hackObject = self.hackObject
-				
+
 				if not hackObject then
 					hackObject = actor:emitObject("hackBolt")
 					hackObject.hackDevice = self
 					self.hackObject = hackObject
 				end
-				
+
 				self.controlProgress = math_min(1, self.controlProgress + time / 0.5)
-				
+
 				if self.controlProgress >= 1 then
 					if target.inputTarget == actor or actor:isChanging() then
 						actor:emitSound("hackDeviceFail", 1, 1, 100)
-						
+
 						local detail = _config.graphicsFx
-						
+
 						for i = 1, 2 + 8 * detail do
 							local fx = hackObject:emitFx("hackSpark")
 							local ang = math_randomAngle()
-							
+
 							fx:setAngle(ang)
 							fx:setSpeed(ang, 5 + math_random() * 3250)
 						end
-						
+
 						for index, big in pairs(self.bigBolts) do
 							big:remove()
 						end
-						
+
 						hackObject:emitFx("hackFailGlow")
 						hackObject:setSpeed(math_angleBetweenPoints(actor.x, actor.y, target.x, target.y) + math_pi, 20)
 						actor:deactivateItem(self)
@@ -21794,16 +21906,16 @@
 		elseif self.controlProgress > 0 and self.active then
 			actor:deactivateItem(self)
 		end
-		
+
 		if self.feedbackDelay > 0 then
 			self.feedbackDelay = self.feedbackDelay - time
 		else
 			local fx
-			
+
 			if self.target then
 				if self.active then
 					fx = actor:emitFx("hackBoltBig")
-					
+
 					table.insert(self.bigBolts, fx)
 				else
 					fx = actor:emitFx("hackBoltSmall")
@@ -21811,14 +21923,14 @@
 			else
 				fx = actor:emitFx("hackBoltTiny")
 			end
-			
+
 			fx:setOwner(actor)
 			fx:setNode("weapon")
-			
+
 			local ang = math_randomAngle()
 			local dist = math_random() * 40 + 10
 			local wx, wy = actor:getWeaponX(), actor:getWeaponY()
-			
+
 			if self.target then
 				if not self.active then
 					fx:setTarget(self.target)
@@ -21826,57 +21938,57 @@
 			else
 				fx:setEnd(wx + math_cos(ang) * dist, wy + math_sin(ang) * dist)
 			end
-			
+
 			local fx = actor:emitFxAt("hackDotSpark", wx, wy)
-			
+
 			if self.target then
 				self.feedbackDelay = 0.5 - 0.3 * _config.graphicsFx + math_random() * 0.05
-				
+
 				fx:setSpeed(math_angleBetweenPoints(actor.x, actor.y, self.target.x, self.target.y), dist * 5)
 			else
 				self.feedbackDelay = 0.13 - 0.1 * _config.graphicsFx + math_random() * 0.09
-				
+
 				fx:setSpeed(ang, dist * 5)
-				
+
 				fx.speed = 1800
 			end
-			
+
 			fx:setNode("weapon")
 			fx:setOwner(self.target or actor)
 		end
-		
+
 		if self.target then
 			local removed = true
 			local deb = 0
-			
+
 			while removed do
 				removed = false
-				
+
 				for index, big in pairs(self.bigBolts) do
 					if big._remove then
 						table.remove(self.bigBolts, index)
-						
+
 						removed = true
-						
+
 						break
 					end
 				end
-				
+
 				deb = deb + 1
-				
+
 				if deb > 1000 then
 					print("while hack dot error")
-					
+
 					break
 				end
 			end
-			
+
 			if self.active then
 				local visualProgress = self.controlProgress * self.controlProgress
-				
+
 				if visualProgress >= 1 then
 					local prox = actor:getTargetProximity(self.target, 1800)
-					
+
 					if prox then
 						for index, big in pairs(self.bigBolts) do
 							big:setTarget(self.target)
@@ -21885,7 +21997,7 @@
 						end
 					else
 						actor:deactivateItem(self)
-						
+
 						for index, view in pairs(states.get("game").views) do
 							if view:tracks(actor) then
 								view:resetTrackingDelay()
@@ -21896,18 +22008,21 @@
 					local wx, wy = actor:getWeaponX(), actor:getWeaponY()
 					local angleTo = math_angleBetweenPoints(wx, wy, self.target.x, self.target.y)
 					local distance = math_distance(wx, wy, self.target.x, self.target.y)
-					
+
 					for index, big in pairs(self.bigBolts) do
-						big:setEnd(wx + math_cos(angleTo) * distance * visualProgress, wy + math_sin(angleTo) * distance * visualProgress)
-						
+						big:setEnd(wx + math_cos(angleTo) * distance * visualProgress,
+							wy + math_sin(angleTo) * distance * visualProgress)
+
 						big.rescanDelay = 0
 					end
-					
-					self.hackObject:setPosition(wx + math_cos(angleTo) * distance * visualProgress, wy + math_sin(angleTo) * distance * visualProgress)
-					
+
+					self.hackObject:setPosition(wx + math_cos(angleTo) * distance * visualProgress,
+						wy + math_sin(angleTo) * distance * visualProgress)
+
 					if math_random() < time * 40 then
-						local fx = actor:emitPpFxAt("hackSpark", wx + math_cos(angleTo) * distance * visualProgress, wy + math_sin(angleTo) * distance * visualProgress)
-						
+						local fx = actor:emitPpFxAt("hackSpark", wx + math_cos(angleTo) * distance * visualProgress,
+							wy + math_sin(angleTo) * distance * visualProgress)
+
 						fx:setTime(-math_random() * 0.07)
 						fx:setSpeed(math_random() * 2 * math_pi, math_random() * 400 + 200)
 						fx:setAngle(math_random() * 2 * math_pi)
@@ -21952,24 +22067,28 @@
 	useMethod = function(self, actor, angle)
 		if self.currentGrab == nil then
 			local x, y = actor:getSafeWeaponXY()
-			local result, hitx, hity, nx, ny, userData, id = actor.map.physics:raycastPoints(x * actor.map.resolution, y * actor.map.resolution, (x + math_cos(angle) * 40) * actor.map.resolution, (y + math_sin(angle) * 40) * actor.map.resolution, false, _collisionCategory.objectSensor, _collisionFilter.notIdleObjects, actor.bodyFilter)
-			
+			local result, hitx, hity, nx, ny, userData, id = actor.map.physics:raycastPoints(x * actor.map.resolution,
+				y * actor.map.resolution, (x + math_cos(angle) * 40) * actor.map.resolution,
+				(y + math_sin(angle) * 40) * actor.map.resolution, false, _collisionCategory.objectSensor,
+				_collisionFilter.notIdleObjects, actor.bodyFilter)
+
 			if result then
 				local target = actor.map.bodyLookup[id]
-				
+
 				if target then
 					local t = target
-					
+
 					if t._category == "actor" and (not t.isAble or t:setDamaged()) then
 						self.currentGrab = t
-						
+
 						local tx, ty = t:getVisualPosition()
-						
-						self.meAngle = -math_angleDifference(actor.angle - math_pi * 0.5, math_angleDifference(actor:getAbsoluteWeaponAngle(), math_angleBetweenPoints(x, y, tx, ty)))
+
+						self.meAngle = -math_angleDifference(actor.angle - math_pi * 0.5,
+							math_angleDifference(actor:getAbsoluteWeaponAngle(), math_angleBetweenPoints(x, y, tx, ty)))
 						self.meDist = math_max(0, math_distance(x, y, tx, ty) - 20)
 						self.angleDiff = math_angleDifference(actor.aimAngle, t.angle)
 						self.sameFacing = t.facingRight == actor.facingRight
-						
+
 						t:setEquipageSubLayer("fg")
 					end
 				end
@@ -21977,7 +22096,7 @@
 		else
 			self.def.switchedFromMethod(self, actor)
 		end
-		
+
 		return true
 	end,
 	initMethod = function(self)
@@ -21996,38 +22115,39 @@
 	updateMethod = function(self, actor, time)
 		if self.currentGrab then
 			actor:requireAiming(6)
-			
+
 			if self.currentGrab._category == "actor" then
 				if not self.currentGrab.isAble then
 					local x, y = actor:getSafeWeaponXY()
 					local ng = actor:getAbsoluteWeaponAngle()
-					
+
 					x = x + math_cos(actor.angle - math_pi * 0.5 + ng + self.meAngle) * self.meDist
 					y = y + math_sin(actor.angle - math_pi * 0.5 + ng + self.meAngle) * self.meDist
-					
+
 					local tx, ty = self.currentGrab:getVisualPosition()
 					local txo, tyo = self.currentGrab:getVisualPositionOffset()
 					local nx, ny = x - txo, y - tyo
-					
+
 					if self.sameFacing then
 						self.currentGrab.facingRight = actor.facingRight
 					else
 						self.currentGrab.facingRight = not actor.facingRight
 					end
-					
+
 					local maxForce = 115
 					local maxDist = 100
-					
+
 					self.lastGrabDx = (nx - tx) / time * actor.map.resolution / 4
 					self.lastGrabDy = (ny - ty) / time * actor.map.resolution / 4
-					
+
 					if math_length(self.lastGrabDx, self.lastGrabDy) > 120 or maxDist < math_distance(x, y, tx, ty) then
 						self.def.switchedFromMethod(self, actor)
 					else
-						self.currentGrab:setSpeedXY(math_max(-maxForce, math_min(maxForce, self.lastGrabDx)), math_max(-maxForce, math_min(maxForce, self.lastGrabDy)))
-						
+						self.currentGrab:setSpeedXY(math_max(-maxForce, math_min(maxForce, self.lastGrabDx)),
+							math_max(-maxForce, math_min(maxForce, self.lastGrabDy)))
+
 						self.currentGrab.onGround = false
-						
+
 						self.currentGrab:setAbsoluteAngle(actor.aimAngle - self.angleDiff + math_pi)
 					end
 				else
@@ -22035,14 +22155,14 @@
 				end
 			end
 		end
-		
+
 		if false then
 		end
 	end,
 	switchedFromMethod = function(self, actor)
 		if self.currentGrab then
 			self.currentGrab:setEquipageSubLayer()
-			
+
 			self.currentGrab = nil
 		end
 	end,
@@ -22164,17 +22284,17 @@
 		local def = self.def
 		local cusprites = def.customSprites
 		local flipped = not facingRight
-		
+
 		video.renderSpriteState(def.sprite, x, y, 1, angle, 255, r, g, b, flipped)
-		
+
 		local utimer = self.useTimer
 		local iu = 1 - utimer / def.cooldown
 		local col = COLORS.white
-		
+
 		if utimer > 0 then
 			col = COLORS.red
 		end
-		
+
 		video.renderSpriteState(cusprites.light, x, y, 1, angle, 255, col.r * iu, col.g * iu, col.b * iu, flipped)
 		video.renderSpriteState(cusprites.glow, x, y, 1, angle, 255 * iu, col.r, col.g, col.b, flipped)
 	end,
@@ -22252,14 +22372,16 @@
 		local spin = self.spin
 		local rx, ry = math.getOffsetPosition(x, y, -2, -9, angle, 1, flipped)
 		local spin_angle = spin * (flipped and -1 or 1)
-		
-		video.renderSpriteState(cusprites.disc, rx, ry, 1, angle + spin_angle, 255, col.r * iu, col.g * iu, col.b * iu, flipped)
+
+		video.renderSpriteState(cusprites.disc, rx, ry, 1, angle + spin_angle, 255, col.r * iu, col.g * iu, col.b * iu,
+			flipped)
 		video.renderSpriteState(cusprites.hook, x, y, 1, angle, 255, r, g, b, flipped)
-		
+
 		if active then
-			video.renderSpriteState(cusprites.glow, rx, ry, 1, angle + spin_angle, glow * 64 * iu * (1 + 0.25 * math_sin(spin * 2 * math_pi)), col.r, col.g, col.b, flipped)
+			video.renderSpriteState(cusprites.glow, rx, ry, 1, angle + spin_angle,
+				glow * 64 * iu * (1 + 0.25 * math_sin(spin * 2 * math_pi)), col.r, col.g, col.b, flipped)
 		end
-		
+
 		video.renderSpriteState(def.sprite, x, y, 1, angle, 255, r, g, b, flipped)
 	end,
 	ai = {
@@ -22310,13 +22432,13 @@
 		if actor:isInView(400) then
 			local def = self.def
 			local fx = actor:emitFx(def.hit_bolt_fx)
-			
+
 			fx:setOwner(actor)
 			fx:setNode("weapon")
 			fx:setTarget(target)
 			fx:setEnd(target.x, target.y)
 			target:emitSound("klonkDischarge", 1, 1, 700)
-			
+
 			local fx = actor:emitFxAt(def.hit_flash_fx, target.x, target.y)
 		end
 	end,
@@ -22333,19 +22455,19 @@
 		local hitList = actor:emitArcPushAt(x, y, range, 0, abs_weapon_angle, arc, min_factor)
 		local any = false
 		local any_hit = false
-		
+
 		if #hitList > 0 then
 			local attack = self:getAttack()
-			
+
 			for index, target in pairs(hitList) do
 				local sx, sy = actor:getSafeWeaponXY()
 				local ang = math_angleBetweenPoints(sx, sy, target.x, target.y)
-				
+
 				if target._category == "actor" then
 					if actor:isThreatened(target) then
 						any = true
 						any_hit = true
-						
+
 						local impact = {
 							impulse = 1,
 							angle = ang,
@@ -22355,7 +22477,7 @@
 							owner = actor,
 							target = target
 						}
-						
+
 						target:hit(impact, attack, nil, self)
 						actor:emitWeaponHitFeedback(self, target)
 						target:propelReach(ang, control / (1 + target:getMass() * mass_factor), force)
@@ -22370,55 +22492,56 @@
 						owner = target,
 						target = actor
 					}
-					
+
 					any = true
 					any_hit = true
-					
+
 					target:deflect(impact, attack)
 					target:propelReach(ang, control / (1 + target:getMass() * mass_factor), force)
-					
+
 					target.boosted = true
 				end
 			end
-			
+
 			if any_hit then
 				if actor:isInView(300) then
 					for i = 1, 6 do
 						local fx = actor:emitFx(def.hit_emit_fx)
-						
+
 						fx:setOwner(actor)
 						fx:setNode("weapon")
-						
+
 						local ang = abs_weapon_angle + math_random() * math_pi * 0.25 - math_random() * math_pi * 0.25
 						local dist = math_random() * 75 + 75
-						
-						fx:setEnd(actor.x + actor.rig.weapon.rx + math_cos(ang) * dist, actor.y + actor.rig.weapon.ry + math_sin(ang) * dist)
+
+						fx:setEnd(actor.x + actor.rig.weapon.rx + math_cos(ang) * dist,
+							actor.y + actor.rig.weapon.ry + math_sin(ang) * dist)
 					end
 				end
-				
+
 				self:applyRandomRecoil(actor, 1)
 				actor:emitSound("shieldDischarge", 1, 1, 700)
 			else
 				local reactor_transfer = def.transfer_reactor_amount
-				
+
 				if reactor_transfer and reactor_transfer > 0 and actor:getReactor() then
 					local consumed = 0
-					
+
 					for index, target in pairs(hitList) do
 						if target._category == "actor" and not actor:isThreatened(target) and target:getReactor() then
 							local ang = math_angleBetweenPoints(actor.x, actor.y, target.x, target.y)
 							local cap = target:getReactorRemainingCapacity()
 							local amount = math_min(cap, math_min(reactor_transfer, actor:getReactorCharge()))
-							
+
 							if amount > 0 then
 								any = true
 								consumed = math_max(consumed, amount)
-								
+
 								target:assistReactor(amount, actor)
-								
+
 								if actor:isInView(400) then
 									local fx = actor:emitFx(def.transfer_bolt_fx)
-									
+
 									fx:setMasterScale(math_min(amount / reactor_transfer, 1))
 									fx:setOwner(actor)
 									fx:setNode("weapon")
@@ -22428,40 +22551,41 @@
 							end
 						end
 					end
-					
+
 					if consumed > 0 then
 						actor:consumeReactor(consumed)
 					end
 				end
-				
+
 				if any then
 					self:applyRandomRecoil(actor, 1)
 					actor:emitSound("powerOnFast", 0.75, 1.5, 250)
 				end
 			end
 		end
-		
+
 		self.didHit = any
-		
+
 		if not any then
 			if actor:isInView(300) then
 				local fx = actor:emitFxAt(def.discharge_fx, x, y)
-				
+
 				fx:setReference(actor, "weapon")
 			end
-			
+
 			self:applyRandomRecoil(actor, 0.25)
 			actor:emitSound("fizzle", 0.33, 1.25, 300)
 		end
-		
+
 		return true
 	end,
 	initMethod = initPhaser,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		if self.useTimer > 0 then
-			video.renderSpriteState(self.def.customSprites.loadGlow, x, y, 1, angle, self.useTimer * 255 / self.def.cooldown * glow, 255, 255, 255, not facingRight)
+			video.renderSpriteState(self.def.customSprites.loadGlow, x, y, 1, angle,
+				self.useTimer * 255 / self.def.cooldown * glow, 255, 255, 255, not facingRight)
 		else
 			video.renderSpriteState(self.def.customSprites.tipGlow, x, y, 1, angle, 255 * glow, 255, 255, 255, not facingRight)
 		end
@@ -24168,45 +24292,45 @@
 	onActivatedMethod = function(self, actor)
 		if actor.map then
 			local fx = actor:emitPpFx("selfDestructWave")
-			
+
 			fx:setReference(actor)
 		end
-		
+
 		self.time = 0
 	end,
 	updateMethod = function(self, actor, time)
 		if self.active then
 			self.time = self.time + time
-			
+
 			if self.time >= self.def.armDuration then
 				if not self.executed then
 					self.executed = true
-					
+
 					actor:executeItem(self)
 					actor:kill()
 				end
 			else
 				self.blinkTimer = self.blinkTimer + time * 7
-				
+
 				local limit = math_max(self.def.armDuration - self.time, 0)
-				
+
 				if self.blinkTimer > limit + 0.07 then
 					actor:flashHit(1)
-					
+
 					local fx = actor:emitPpFx("selfDestructBlink")
-					
+
 					fx:setReference(actor)
 					fx:setNode(actor:getWeaponNode())
 					fx:setMasterScale(0.75 + 0.75 * self.time / self.def.armDuration)
-					
+
 					self.blinkTimer = 0
-					
+
 					actor:emitSound("selfDestructBeep", 0.6, 0.9 + 0.5 * self.time / self.def.armDuration, 400)
 				end
 			end
 		elseif self.blinkTimer <= 0 then
 			actor:flashHit(1)
-			
+
 			self.blinkTimer = 1
 		else
 			self.blinkTimer = self.blinkTimer - time
@@ -24245,31 +24369,31 @@
 	special = true,
 	useMethod = function(self, actor, angle)
 		local target = actor.map:findClosestInClassification(actor.x, actor.y, "virusTarget")
-		
+
 		if target then
 			if not self.active then
 				self:setTarget(target)
 				actor:activateItem(self)
 			end
-			
+
 			return true
 		else
 			self:emitSound("BtnDenial")
-			
+
 			return true
 		end
 	end,
 	onExecutedVisualMethod = function(self, actor)
 		local target = self.target
-		
+
 		if target then
 			local x, y = target:getBestLockPosition(actor.x, actor.y)
-			
+
 			target:emitFxAt("radioHackFlash", x, y)
 			target:emitFxAt("radioHackEnd", x, y)
-			
+
 			local lock = target.lock
-			
+
 			if lock then
 				lock:hurt(10)
 			end
@@ -24278,69 +24402,69 @@
 	onActivatedMethod = function(self, actor)
 		if actor.map then
 			local fx = actor:emitPpFx("hackDestructWave")
-			
+
 			fx:setReference(actor)
 		end
-		
+
 		self.time = 0
 	end,
 	updateMethod = function(self, actor, time)
 		if self.active then
 			self.time = self.time + time
-			
+
 			local dur = self.def.armDuration
 			local prg = self.time / dur
 			local target = self.target
-			
+
 			if target then
 				if not self.targetFx then
 					local fx = actor:emitFx("virusHackBolt")
-					
+
 					fx:setOwner(actor)
 					fx:setNode(actor:getWeaponNode())
 					fx:setEnd(self.target:getBestLockPosition(actor.x, actor.y))
-					
+
 					self.targetFx = fx
 				else
 					local fx = self.targetFx
-					
+
 					fx:setTime(math.min(0.5, fx.time))
 					fx:setMasterScale(1 + prg * prg * 2)
 				end
-				
+
 				local lock = target.lock
-				
+
 				if lock then
 					lock:hurt(1 / dur * time)
 				end
 			end
-			
+
 			actor:setSpeed(math.randomAngle(), prg * prg * 10)
 			actor:emitLoop("radio_hack_loop", 1, 2.25 - 0.75 * prg)
-			
+
 			if self.time >= self.def.armDuration then
 				if not self.executed then
 					self.executed = true
-					
+
 					actor:executeItem(self)
 					actor:kill()
 				end
 			else
 				self.blinkTimer = self.blinkTimer + time * 5
-				
+
 				local limit = math_max(self.def.armDuration - self.time, 0)
-				
+
 				if self.blinkTimer > limit + 0.07 then
 					actor:flashHit(1)
-					
+
 					local fx = actor:emitPpFx("hackDestructBlink")
-					
+
 					fx:setReference(actor)
 					fx:setNode(actor:getWeaponNode())
 					fx:setMasterScale(0.75 + 0.75 * prg)
-					
+
 					self.blinkTimer = 0
-					
+
 					actor:emitSound("hackDestructBeep", 0.6, 0.9 + 0.7 * prg, 400)
 				end
 			end
@@ -24397,7 +24521,7 @@
 	end,
 	getEffect = function(self)
 		if self.upgrades.superCharger then
-			return 
+			return
 		end
 	end,
 	getAttackForce = function(self)
@@ -24408,7 +24532,7 @@
 				return 40
 			end
 		end
-		
+
 		return 12
 	end,
 	getUseSoundVolume = function(self)
@@ -24431,45 +24555,46 @@
 	useMethod = function(self, actor, angle)
 		local x, y = actor:getWeaponX(), actor:getWeaponY()
 		local obj = actor:shootBullet(x, y, angle, 0, self.bullet, self)
-		
+
 		if obj then
 			obj:setAngle(angle)
 			obj:setOwner(actor)
 			actor:emitSound(self:getUseSound(), self:getUseSoundVolume(), self:getUseSoundMod(), self:getSoundRange())
-			actor:setStealthPenalty(self:getSoundRange() * soundToVisFactor)
-			
+			actor:setStealthPenalty(self:getSoundRange() * SoundToVisFactor)
+
 			obj.hitForce = self:getAttackForce()
 			obj.griplessForce = self:getGriplessAmount()
 			obj.damageModifier = self:getPower()
 			obj.travelDistance = self:getAttackRange()
 		end
-		
+
 		local recoilAng = actor:getRelativeWeaponAngle()
-		
+
 		self:applyRandomRecoil(actor)
-		
+
 		if actor:getWeaponHoldingNode() then
 			actor.rig:setNodeSpeed(actor:getWeaponHoldingNode(), math_cos(recoilAng) * 1500, math_sin(recoilAng) * 1500)
 		end
-		
+
 		if actor:getNode("head") then
 			actor.rig:setNodeSpeed(actor:getNode("head"), math_cos(recoilAng) * 350, math_sin(recoilAng) * 350)
 		end
-		
+
 		return true
 	end,
 	initMethod = initPhaser,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		local cusprites = self.def.customSprites
-		
+
 		if self.useTimer > 0 then
-			video.renderSpriteState(cusprites.phasergun_red, x, y, 1, angle, glow * self.useTimer * 255 / self.def.cooldown, 255, 255, 255, not facingRight)
+			video.renderSpriteState(cusprites.phasergun_red, x, y, 1, angle, glow * self.useTimer * 255 / self.def.cooldown,
+				255, 255, 255, not facingRight)
 		else
 			video.renderSpriteState(cusprites.phasergun_green, x, y, 1, angle, glow * 255, 255, 255, 255, not facingRight)
 		end
-		
+
 		for index, upgrade in pairs(self.upgrades) do
 			upgrade.def.renderMethod(upgrade, x, y, angle, r, g, b, facingRight, glow)
 		end
@@ -24526,14 +24651,15 @@
 	if self.hitActive and self.feedback < 1 then
 		self.feedback = math_min(1, self.feedback + time / self.def.feedbackTime)
 		self.feedbackDelay = self.feedbackDelay - time
-		
+
 		if self.feedbackDelay <= 0 then
 			self.feedbackDelay = math_max(0.02, 0.12 - 0.1 * _config.graphicsFx)
-			
+
 			local dist = math_random(20)
 			local wAng = actor:getWeaponAngle() - math_pi * 0.5
-			
-			actor:emitFxAt("batonSparkLight", actor:getWeaponNodeX() + math_cos(wAng) * dist, actor:getWeaponNodeY() + math_sin(wAng) * dist)
+
+			actor:emitFxAt("batonSparkLight", actor:getWeaponNodeX() + math_cos(wAng) * dist,
+				actor:getWeaponNodeY() + math_sin(wAng) * dist)
 		end
 	end
 end
@@ -24564,14 +24690,15 @@
 		if self.hitActive and self.feedback < 1 then
 			self.feedback = math_min(1, self.feedback + time / self.def.feedbackTime)
 			self.feedbackDelay = self.feedbackDelay + time
-			
+
 			if self.feedbackDelay > 0.02 then
 				self.feedbackDelay = 0
-				
+
 				local dist = math_random(20)
 				local wAng = actor:getWeaponAngle() - math_pi * 0.5
-				
-				actor:emitFxAt("batonSparkLight", actor:getWeaponNodeX() + math_cos(wAng) * dist, actor:getWeaponNodeY() + math_sin(wAng) * dist)
+
+				actor:emitFxAt("batonSparkLight", actor:getWeaponNodeX() + math_cos(wAng) * dist,
+					actor:getWeaponNodeY() + math_sin(wAng) * dist)
 			end
 		end
 	end,
@@ -24584,14 +24711,16 @@
 	end,
 	lightMapRenderMethod = function(self, object, x, y)
 		if self.hitActive then
-			video.renderSpriteState(self.def.customSprites.energybaton_glow, x, y, 1, object.angle, 128, 255, 255, 255, object.flipped)
+			video.renderSpriteState(self.def.customSprites.energybaton_glow, x, y, 1, object.angle, 128, 255, 255, 255,
+				object.flipped)
 			video.renderAdditiveSpriteState(FX.glow.sprite, x, y, 0.5, object.angle, 50.400000000000006, 34.2, 4.4)
 		end
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		if self.hitActive then
 			video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-			video.renderSpriteState(self.def.customSprites.energybaton_glow, x, y, 1, angle, 255 * glow, 255, 255, 255, not facingRight)
+			video.renderSpriteState(self.def.customSprites.energybaton_glow, x, y, 1, angle, 255 * glow, 255, 255, 255,
+				not facingRight)
 		else
 			video.renderSpriteState(self.def.customSprites.energybaton_off, x, y, 1, angle, 255, r, g, b, not facingRight)
 		end
@@ -24637,13 +24766,13 @@
 		if object.itemRef.hitActive then
 			local x = impact.x or object.x
 			local x, y = x, impact.y or object.y
-			
+
 			if object:isInView(100) then
 				for i = 1, math_random(3) + 4 do
 					object:emitFxAt("batonSpark", x, y):setSpeed(math_random() * math_pi * 2, math_random() * 300)
 				end
 			end
-			
+
 			object:emitSoundAt("batonClash", x, y, 1, 1, 300)
 			object:setHitActive(false)
 			object:setIgnore(nil)
@@ -24654,17 +24783,17 @@
 		if impact.target:hit(impact, ATTACKS.baton) then
 			local x = impact.x or object.x
 			local x, y = x, impact.y or object.y
-			
+
 			for i = 1, math_random(3) + 4 do
 				object:emitFxAt("batonSpark", x, y):setSpeed(math_random() * math_pi * 2, math_random() * 300)
 			end
-			
+
 			object:emitFxAt("batonFlash", x, y)
 			object:emitSoundAt("batonHit", x, y, 1, 1, 450)
 			object:setHitActive(false)
 			object:setIgnore(nil)
 		end
-		
+
 		object:setHitActive(false)
 		object.itemRef:disarm(object)
 	end,
@@ -24711,11 +24840,11 @@
 	asObjectHitSensor = function(object, impact)
 		if object.itemRef.hitActive then
 			impact.damageModifier = math_min(1, math_abs(object:getAngleSpeed() / math_pi / 5) + object:getSpeed() / 15)
-			
+
 			if impact.target ~= object.lastHit and impact.target:hit(impact, ATTACKS.boomerang) then
 				object.lastHit = impact.target
 				object.lastHitDelay = 0.2
-				
+
 				if not object.autoPickup then
 					object:setAutopickup(true)
 				end
@@ -24734,7 +24863,7 @@
 	asObjectCollision = function(object, impact)
 		if object.itemRef.hitActive then
 			local rotation = object.map.physics:getEntityAngleSpeed(object.body)
-			
+
 			if math_abs(rotation) < 10 then
 				object:disableHit()
 			else
@@ -24744,53 +24873,62 @@
 	end,
 	asObjectUpdate = function(self, object, time)
 		local gravity = 36
-		
+
 		self.blur = 0
-		
+
 		if not object.sleeping then
 			local rotation = 0
 			local moveAngle = math_angleBetweenPoints(0, 0, object.dx, object.dy)
-			
+
 			if self.hitActive and not object.sleeping then
 				if object.lastHitDelay and object.lastHitDelay > 0 then
 					object.lastHitDelay = object.lastHitDelay - time
-					
+
 					if object.lastHitDelay <= 0 then
 						object.lastHit = nil
 					end
 				end
-				
+
 				rotation = object.map.physics:getEntityAngleSpeed(object.body)
-				
+
 				local speed = object:getSpeed()
-				
+
 				if not object.startAngle then
 					object.builtMotion = 0
 					object.startAngle = math_angleBetweenPoints(0, 0, object.dx, object.dy)
 				end
-				
+
 				if not object.onGround and not object.autoPickup and not object.isPickupable and math_abs(math_angleDifference(moveAngle, object.startAngle)) > math_pi * 0.5 then
 					object:setAutopickup(true)
 				end
-				
-				local returnSpeed = math_abs(rotation) * 28 / (1 + math_sqrt(speed) * 7) * math_min(1, object.time * 2 - 0.2) * math_max(0, math_min(1, 3 - object.time))
-				
-				object:addSpeedXY(math_cos(object.startAngle + math_pi) * time * returnSpeed, math_sin(object.startAngle + math_pi) * time * returnSpeed)
-				object.map.physics:setEntityAngleSpeed(object.body, math_approach(rotation, 0, time * 5 * math_max(math_min(2, object.time * 1.5), math_abs(math_angleDifference(moveAngle, object.startAngle)) / math_pi) + math_abs(rotation * rotation * rotation * 0.0008) * time))
-				
+
+				local returnSpeed = math_abs(rotation) * 28 / (1 + math_sqrt(speed) * 7) * math_min(1, object.time * 2 - 0.2) *
+				math_max(0, math_min(1, 3 - object.time))
+
+				object:addSpeedXY(math_cos(object.startAngle + math_pi) * time * returnSpeed,
+					math_sin(object.startAngle + math_pi) * time * returnSpeed)
+				object.map.physics:setEntityAngleSpeed(object.body,
+					math_approach(rotation, 0,
+						time * 5 *
+						math_max(math_min(2, object.time * 1.5),
+							math_abs(math_angleDifference(moveAngle, object.startAngle)) / math_pi) +
+						math_abs(rotation * rotation * rotation * 0.0008) * time))
+
 				rotation = object.map.physics:getEntityAngleSpeed(object.body)
-				
+
 				object:stopSpeedXY(speed * speed * 0.001, speed * speed * 0.001, time)
-				
+
 				if math_abs(rotation) <= 3 then
 					object:disableHit()
 				end
 			else
 				object.autoPickup = false
 			end
-			
+
 			self.blur = rotation * 1.5 * time
-			object.dy = object.dy + (gravity - math_min(gravity, math_abs(math_cos(moveAngle)) * gravity / 200 * math_abs(rotation * rotation) * math_abs(math_cos(moveAngle)))) * time / math_abs(1 + math_abs(rotation) * 0.01)
+			object.dy = object.dy +
+			(gravity - math_min(gravity, math_abs(math_cos(moveAngle)) * gravity / 200 * math_abs(rotation * rotation) * math_abs(math_cos(moveAngle)))) *
+			time / math_abs(1 + math_abs(rotation) * 0.01)
 		end
 	end,
 	asObjectPhysics = {
@@ -25012,12 +25150,12 @@
 	end,
 	onExecutedVisualMethod = function(self, actor)
 		self.chargeDelay = self:getCooldown()
-		
+
 		actor:emitSound("activateComplete", 1, 1)
-		
+
 		if actor.map then
 			local x, y = actor:getAbsoluteNodePosition("backpack")
-			
+
 			helpers.fxGenerator("sentrySpawn", actor.map, actor.x, actor.y, 1, 1, -math.pi * 0.5, 1, nil, actor)
 		end
 	end,
@@ -25031,32 +25169,32 @@
 	onExecutedMethod = function(self, actor)
 		local actorClass = self:getSpawnedActorClass(actor)
 		local spawnLevel = 1
-		
+
 		if actorClass then
 			local spawned_actor = actorClasses.getActor(actorClass, spawnLevel, true, actor.facingRight)
-			
+
 			if spawned_actor then
 				local x, y = actor:getAbsoluteNodePosition("backpack")
-				
+
 				spawned_actor:setIsSimpleHelper(true)
 				spawned_actor:setSync("Actor")
 				spawned_actor:setDefaultAi()
 				spawned_actor:setAngle(actor.angle)
 				spawned_actor:setAimAngle(actor.aimAngle)
-				
+
 				local new_item = spawned_actor:copySelectedItemBy(actor)
-				
+
 				if new_item then
 					spawned_actor:addItem(new_item)
 				end
-				
+
 				if actor.team then
 					spawned_actor:setTeam(actor.team)
 					spawned_actor:setMaster(actor)
 				else
 					spawned_actor:setTeam(actor.map:getGame():getOrCreateTeam("monster"))
 				end
-				
+
 				spawned_actor:moveToEntAt(actor, x, y)
 				spawned_actor:addSpeed(actor:getUpAngle(), 13)
 				spawned_actor:addSpeedXY(actor.dx, actor.dy)
@@ -25072,39 +25210,39 @@
 		if not self.active then
 			if self.chargeDelay > 0 then
 				self.chargeDelay = math_max(0, self.chargeDelay - time)
-				
+
 				if self.chargeDelay <= 0 then
 					local owner = actor:getHelperOwner()
-					
+
 					if owner then
 						local max = owner:getMaxHelpers()
-						
+
 						if owner and max > actor:getNumberOfHelpers() then
 							self:addAmmo(1, actor)
-							
-							return 
+
+							return
 						end
 					end
-					
+
 					self.chargeDelay = 1
 				end
 			end
 		else
 			actor:emitLoop("sentryBackpack", 0.75 + 0.25 * self.chargeTimer, 0.25 + 0.5 * self.chargeTimer)
-			
+
 			self.chargeTimer = self.chargeTimer + time / 2
 			self.blinkTimer = self.blinkTimer + time * self.chargeTimer * 12
-			
+
 			if self.blinkTimer >= 1 then
 				self.blinkTimer = 0
 			end
-			
+
 			if self.chargeTimer >= 1 then
 				local owner = actor:getHelperOwner()
-				
+
 				if owner then
 					local max = owner:getMaxHelpers()
-					
+
 					if max > actor:getNumberOfHelpers() then
 						actor:executeItem(self)
 						self:useAmmo(actor, 1)
@@ -25112,9 +25250,9 @@
 						actor:emitHelperErrorAt(actor.x, actor.y - 50)
 					end
 				end
-				
+
 				actor:deactivateItem(self)
-				
+
 				self.chargeTimer = 0
 			end
 		end
@@ -25123,18 +25261,18 @@
 		local col = self.color
 		local def = self.def
 		local flipped = not facingRight
-		
+
 		video.renderSpriteState(def.sprite, x, y, 1, angle, 255, r, g, b, flipped)
-		
+
 		local blop = 1
-		
+
 		if self.active then
 			blop = self.blinkTimer
 		elseif self.chargeDelay > 0 then
 			blop = 0.5 + 0.4 * math_cos(self.chargeDelay * math.pi * 2)
 			col = COLORS.power
 		end
-		
+
 		video.renderSpriteState(def.customSprites.glow, x, y, 1, angle, 255 * blop, col.r, col.g, col.b, flipped)
 	end,
 	customSpriteNames = {
@@ -25176,21 +25314,21 @@
 		if self.itemSpawnDelay > 0 then
 			self.itemSpawnDelay = self.itemSpawnDelay - time
 		end
-		
+
 		for index, owned in pairs(self.ownedActors) do
 			if owned.killed then
 				table.remove(self.ownedActors, index)
-				
+
 				break
 			end
-			
+
 			if owned.groundRef and owned.groundRef == actor and owned:getNumberOfItem("spike") <= 0 and self.itemSpawnDelay <= 0 then
 				owned:addItem(Item:new("spike"))
-				
+
 				self.itemSpawnDelay = 3
 			end
 		end
-		
+
 		if self.upgrades.birdEgg then
 			if #self.ownedActors < self.upgrades.birdEgg.level then
 				if self.spawnDelayBlock <= 0 then
@@ -25198,19 +25336,24 @@
 				else
 					self.spawnDelayBlock = self.spawnDelayBlock - time
 				end
-				
+
 				if actor.rig["egg" .. self.spawningEgg].hidden then
 					actor.rig["egg" .. self.spawningEgg].hidden = false
-					
+
 					actor:emitSound("eggGrowth", 1, 1, 200)
 				end
-				
-				actor.rig["egg" .. self.spawningEgg].scale = 1 - math_min(1, math_max(0, math_easeOut(self.spawnDelay) - 0.5) * 2)
+
+				actor.rig["egg" .. self.spawningEgg].scale = 1 -
+				math_min(1, math_max(0, math_easeOut(self.spawnDelay) - 0.5) * 2)
 			end
-			
+
 			if self.spawnDelay <= 0 and #self.ownedActors < self.upgrades.birdEgg.level then
-				local bird = actor:spawnActorAt("bird", (actor:getAbsoluteNodeX("egg" .. self.spawningEgg) + actor:getAbsoluteNodeX("egg" .. self.spawningEgg .. "Bob")) / 2, (actor:getAbsoluteNodeY("egg" .. self.spawningEgg) + actor:getAbsoluteNodeY("egg" .. self.spawningEgg .. "Bob")) / 2)
-				
+				local bird = actor:spawnActorAt("bird",
+					(actor:getAbsoluteNodeX("egg" .. self.spawningEgg) + actor:getAbsoluteNodeX("egg" .. self.spawningEgg .. "Bob")) /
+					2,
+					(actor:getAbsoluteNodeY("egg" .. self.spawningEgg) + actor:getAbsoluteNodeY("egg" .. self.spawningEgg .. "Bob")) /
+					2)
+
 				bird:setTeam(actor.team)
 				bird:setAi(Ai:new(ACTORS[bird.type].defaultAi))
 				bird.ai:addConcept("followMaster")
@@ -25219,19 +25362,21 @@
 				bird:setActionDelay(1)
 				actor.rig:setNodeVisible("egg" .. self.spawningEgg, false)
 				bird:emitSound("eggHatch", 1, 1, 450)
-				
-				local angleTo = math_angleBetweenPoints(actor.rig["egg" .. self.spawningEgg].rx, actor.rig["egg" .. self.spawningEgg].ry, actor.rig["egg" .. self.spawningEgg .. "Bob"].rx, actor.rig["egg" .. self.spawningEgg .. "Bob"].ry)
-				
+
+				local angleTo = math_angleBetweenPoints(actor.rig["egg" .. self.spawningEgg].rx,
+					actor.rig["egg" .. self.spawningEgg].ry, actor.rig["egg" .. self.spawningEgg .. "Bob"].rx,
+					actor.rig["egg" .. self.spawningEgg .. "Bob"].ry)
+
 				helpers.fxGenerator("eggShells", actor.map, bird.x, bird.y, 1, 1, angleTo, 1, nil, actor)
 				table.insert(self.ownedActors, bird)
-				
+
 				if actor.ai and bird.ai then
 					actor.ai:shareCustomConcepts(bird.ai)
 				end
-				
+
 				self.spawnDelay = 1
 				self.spawningEgg = self.spawningEgg + 1
-				
+
 				if self.spawningEgg > self.upgrades.birdEgg.level then
 					self.spawningEgg = 1
 				end
@@ -25808,34 +25953,34 @@
 	end,
 	updateMethod = function(self, actor, time)
 		if not actor.isAble or not actor.canSee then
-			return 
+			return
 		end
-		
+
 		if self.sendDelay > 0 then
 			self.sendDelay = self.sendDelay - time
 		else
 			if not self.alarming and actor and actor.map and actor.ai and actor.ai.confirmedThreat and not actor.oldTeam then
 				self.alarming = true
-				
+
 				local ok, reason = actor:canCallReinforcements()
 				local locId = "alarm"
-				
+
 				if ok then
 					locId = "requesting_reinforcements"
 				elseif reason then
 					locId = "reinforcements_" .. reason
 				end
-				
+
 				actor:adaptiveSay(localize.get(locId), nil, actor.ai.targetActor)
 			end
-			
+
 			if self.alarming and self.sendTimer < 1 then
 				self.sendTimer = self.sendTimer + time
-				
+
 				if self.sendTimer >= 1 then
 					actor:emitAlarm(RANGES.ultra)
 					actor:callReinforcements()
-					
+
 					self.sendTimer = 0
 					self.sendDelay = 5
 					self.alarming = false
@@ -26296,15 +26441,15 @@
 	specialAddMethod = function(item, inventory, object, actor)
 		if actor and actor.map and RENDERING then
 			actor:emitSound(ITEMS[item.type].pickupSound, 1, 1, 400)
-			
+
 			local angle = actor.aimAngle - math_pi * 0.5 - math_pi * 0.15 * actor.flipFactor
 			local piece = actor:emitItemDebris(item.type, false, angle)
-			
+
 			piece:setSpeed(angle, 11 + math_random() * 7)
 		end
-		
+
 		actor:getVolts():add(item.def.energyValue)
-		
+
 		return true
 	end,
 	customSpriteNames = {
@@ -26314,12 +26459,14 @@
 	ai = {},
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
-		local glow = 0.8 + 0.2 * math_sin(self.countId / math_pi / 2 + _time * 3) * math_cos(self.countId / math_pi / 2 + _time * 5)
+
+		local glow = 0.8 +
+		0.2 * math_sin(self.countId / math_pi / 2 + _time * 3) * math_cos(self.countId / math_pi / 2 + _time * 5)
 		local cusprites = self.def.customSprites
-		
+
 		video.renderSpriteState(cusprites.powerplug_light, x, y, 1, angle, 255 * glow, 255, 255, 255, not facingRight)
-		video.renderSpriteState(cusprites.powerplug_glow, x, y, 0.5 + 0.5 * glow, angle, 255 * glow, 255, 255, 255, not facingRight)
+		video.renderSpriteState(cusprites.powerplug_glow, x, y, 0.5 + 0.5 * glow, angle, 255 * glow, 255, 255, 255,
+			not facingRight)
 	end
 }
 ITEMS.energy = {
@@ -26336,10 +26483,10 @@
 
 local function multiEnergy(item, inventory, object, actor)
 	local addItem = Item:new("energy")
-	
+
 	addItem:setStack(item.def.energyValue)
 	inventory:addToOwner(addItem)
-	
+
 	return true
 end
 
@@ -26733,9 +26880,11 @@
 		local t = self.tint or TINTS.white
 		local l = self.tint or TINTS.green
 		local blink = math_heartPulse(_time / 0.85)
-		
-		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r * 0.5 + 0.5 * r * t.r, g * 0.5 + 0.5 * g * t.g, b * 0.5 + 0.5 * b * t.b, not facingRight)
-		video.renderSpriteState(self.def.customSprites.light, x, y, 1, angle, math_min(255 * blink, 255), 255 * l.r, 255 * l.g, 255 * l.b, not facingRight)
+
+		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r * 0.5 + 0.5 * r * t.r, g * 0.5 + 0.5 * g * t.g,
+			b * 0.5 + 0.5 * b * t.b, not facingRight)
+		video.renderSpriteState(self.def.customSprites.light, x, y, 1, angle, math_min(255 * blink, 255), 255 * l.r,
+			255 * l.g, 255 * l.b, not facingRight)
 	end,
 	onActorSet = function(self, a)
 		self.tint = a and a:getIdentityTint() or TINTS.white
@@ -27152,7 +27301,7 @@
 		if item.data then
 			actor:addData(item.data, true, true)
 		end
-		
+
 		return true
 	end,
 	initRuntimeMethod = function(self)
@@ -27161,16 +27310,16 @@
 	end,
 	asObjectUpdate = function(self, object, time)
 		self.glowTimer = self.glowTimer + time
-		
+
 		if self.fxTimer <= 0 then
 			local ang = math_randomGaussian() * math_pi * 0.5 - math_pi * 0.5 + object.angle
 			local dist = 8 + math_random() * 18
 			local x, y = object.x + math_cos(ang) * dist, object.y + math_sin(ang) * dist
 			local fx = object:emitPpFxAt("dataSpark", x, y)
-			
+
 			fx:setTarget(object)
 			fx:setSpeed(ang + math_randomGaussian() * math_pi * 0.5, math_random() * 50 + 3)
-			
+
 			self.fxTimer = math_random() * 0.4 + 0.2
 		else
 			self.fxTimer = self.fxTimer - time
@@ -27179,12 +27328,12 @@
 	onPickedUpMethod = function(self, actor, object)
 		if object then
 			local fx = object:emitPpFx("dataFlash")
-			
+
 			fx:setMasterScale(1)
-			
+
 			for i = 1, 4 do
 				local fx = object:emitFx("dataBolt")
-				
+
 				fx:setTarget(actor)
 				actor:flashWhite(1)
 			end
@@ -27192,22 +27341,25 @@
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, not facingRight)
-		
+
 		local cusprites = self.def.customSprites
 		local glow1 = math_cos(self.glowTimer * math_pi * 4) * 0.25 + 0.75
 		local col = COLORS.data
-		
-		video.renderSpriteState(cusprites.light, x, y, 1, angle, 255, col.r * glow1, col.g * glow1, col.b * glow1, not facingRight)
+
+		video.renderSpriteState(cusprites.light, x, y, 1, angle, 255, col.r * glow1, col.g * glow1, col.b * glow1,
+			not facingRight)
 		video.renderSpriteState(cusprites.glow, x, y, 1, angle, glow1 * 255, col.r, col.g, col.b, not facingRight)
-		video.renderSpriteState(cusprites.topLight, x, y, 1, angle, 255, col.r * glow1, col.g * glow1, col.b * glow1, not facingRight)
+		video.renderSpriteState(cusprites.topLight, x, y, 1, angle, 255, col.r * glow1, col.g * glow1, col.b * glow1,
+			not facingRight)
 		video.renderSpriteState(cusprites.topGlow, x, y, 1, angle, glow1 * 255, col.r, col.g, col.b, not facingRight)
-		
+
 		if self.data then
 			local glow2 = math_cos(self.glowTimer * math_pi * 1) * 0.25 + 0.75
 			local icon = self.data:getIconSprite()
 			local dist = 21 + glow2 * 3
-			
-			video.renderSpriteState(icon, x + math_cos(angle - math_pi * 0.5) * dist, y + math_sin(angle - math_pi * 0.5) * dist, 0.15 + glow2 * 0.06, angle, glow2 * 200, col.r, col.g, col.b)
+
+			video.renderSpriteState(icon, x + math_cos(angle - math_pi * 0.5) * dist,
+				y + math_sin(angle - math_pi * 0.5) * dist, 0.15 + glow2 * 0.06, angle, glow2 * 200, col.r, col.g, col.b)
 		end
 	end,
 	behaviours = {
@@ -27283,7 +27435,7 @@
 	iconName = "prism_icon",
 	initMethod = function(self)
 		self.expanded = false
-		
+
 		self:setAmmo(100)
 	end,
 	initRuntimeMethod = function(self)
@@ -27307,20 +27459,20 @@
 				local dx, dy = math_cos(angle) * dist, math_sin(angle) * dist
 				local x, y = object.x + dx, object.y + dy
 				local fx = object:emitDebrisAt(spr, x, y)
-				
+
 				fx:addSpeedXY(dx * 3, dy * 3 - 20)
 				object:emitPpFxAt("deformingHitFlash", x, y)
 			end
-			
+
 			object:emitFx("sparkSourceFlash")
 			object:emitOmniForce(750, 40)
 		end
-		
+
 		object:emitSound("captureFail", 1, 0.6, RANGES.long)
 	end,
 	onAsObject = function(self, object)
 		self:setExpanded(false)
-		
+
 		if self:getAmmo() <= 0 then
 			object:destroy()
 		end
@@ -27331,45 +27483,46 @@
 	updateMethod = function(self, ent, time, object)
 		if self.expanded then
 			self.expandedTimer = math_min(1, self.expandedTimer + time / 0.5)
-			
+
 			if ent and ent._category == "tile" then
 				local computer = ent.computer
-				
+
 				if computer and computer:isJoltable() then
 					self.spinTimer = self.spinTimer + time * 4 * self.joltAnim
 					self.joltAnim = math_min(1, self.joltAnim + time)
 					self.joltTimer = self.joltTimer + time * self.joltAnim * 2
-					
+
 					if self.joltTimer >= 1 then
 						if self:getAmmo() > 0 then
 							computer:jolt(0.25)
 							self:useAmmo(nil, 1)
-							
+
 							self.joltTimer = 0
-							
+
 							local x, y = ent:getNodeXY("item")
 							local dist = 20 + math.randomGaussian() * 15
 							local ang = math.randomAngle()
 							local x = x + math_cos(ang) * dist
 							local y = y + math_sin(ang) * dist
-							
+
 							ent:emitSoundAt("repair", x, y, 1, 0.5 + math_random() * 0.4, 550)
-							
+
 							local fx = ent:emitFxAt("joltSourceFlash", x, y)
 							local detail = _config.graphicsFx
-							
+
 							for i = 1, 2 + math_random(1, 3) * detail * 2 do
 								local obj = ent:emitSparkAt("repairSpark", x, y)
-								
-								obj:setSpeed(-math_pi * 0.5 + math_random() * math_pi * 0.25 - math_random() * math_pi * 0.25, math_random() * 7.5 + 7)
+
+								obj:setSpeed(-math_pi * 0.5 + math_random() * math_pi * 0.25 - math_random() * math_pi * 0.25,
+									math_random() * 7.5 + 7)
 							end
-							
+
 							local ammoprg = self:getAmmo() / self:getMaxAmmo()
-							
+
 							if ammoprg < 0.1 then
 								local prg = ammoprg / 0.1
 								local vol = math.clamp(0.5 - prg * 0.4, 0, 1)
-								
+
 								ent:emitSound("nanoDispenserBeep", vol, 1.1 - prg * 0.4, 200)
 							end
 						else
@@ -27380,23 +27533,25 @@
 					self.joltAnim = math_max(0, self.joltAnim - time * 2)
 				end
 			end
-			
+
 			if self.expandedTimer >= 1 then
 				if self.angleDelay <= 0 and self.joltAnim > 0 then
 					if self.angleTimer < 1 then
-						local ang = math_approachAngle(self.angleStart, self.angleTarget, math.abs(self.angleTarget - self.angleStart) * self.angleTimer)
-						
+						local ang = math_approachAngle(self.angleStart, self.angleTarget,
+							math.abs(self.angleTarget - self.angleStart) * self.angleTimer)
+
 						self.angleTimer = self.angleTimer + time * 6
-						
+
 						local index = self.angleIndex
-						
+
 						if index > 4 then
 							self.angleOffset = ang
-							self.angleLegOffset = math_approachAngle(self.angleLegOffset, math.angleDifference(self.angleStart, ang), math_pi * 4 * time)
+							self.angleLegOffset = math_approachAngle(self.angleLegOffset, math.angleDifference(self.angleStart, ang),
+								math_pi * 4 * time)
 						else
 							self.expandedAngles[index] = ang
 						end
-						
+
 						self.adjustAnim = math_min(1, self.adjustAnim + time * 15)
 					else
 						self.angleDelay = 0.15 + math_random() * 1.25
@@ -27405,18 +27560,18 @@
 					if self.angleLegOffset ~= 0 then
 						self.angleLegOffset = math_approachAngle(self.angleLegOffset, 0, math_pi * 4 * time)
 					end
-					
+
 					if self.adjustAnim > 0 then
 						self.adjustAnim = math_max(0, self.adjustAnim - self.adjustAnim * time * 3 - time * 10)
 					elseif self.angleDelay > 0 then
 						self.angleDelay = self.angleDelay - time
-						
+
 						if self.angleDelay <= 0 then
 							self.angleTimer = 0
 							self.angleIndex = math_random(1, 5)
-							
+
 							local index = self.angleIndex
-							
+
 							if index > 4 then
 								self.angleStart = self.angleOffset
 								self.angleTarget = self.angleStart + math.randomGaussian() * math.pi * 0.5
@@ -27430,7 +27585,7 @@
 			end
 		else
 			self.expandedTimer = math_max(0, self.expandedTimer - time / 0.5)
-			
+
 			if self.angleOffset ~= 0 then
 				self.angleOffset = math.approachAngle(self.angleOffset, 0, math_pi * 4)
 			end
@@ -27488,9 +27643,9 @@
 		local cusprites = def.customSprites
 		local total_flip = not facingRight
 		local adjustAngle = self.adjustAnim * self.angleTarget * 0.5
-		
+
 		angle = angle + adjustAngle * 0.5 + self.angleOffset
-		
+
 		local up_angle = angle - math_pi * 0.5
 		local down_angle = angle + math_pi * 0.5
 		local exp = math.easeOut(self.expandedTimer)
@@ -27498,13 +27653,13 @@
 		local hull_expand = 3
 		local hull_rdx, hull_rdy = math_cos(up_angle) * hull_off * hull_expand, math_sin(up_angle) * hull_off * hull_expand
 		local hull_dx, hull_dy = math_cos(up_angle) * exp * hull_expand, math_sin(up_angle) * exp * hull_expand
-		
+
 		video.renderSpriteState(cusprites.frameTop, x + hull_rdx, y + hull_rdy, 1, angle, 255, r, g, b, total_flip)
 		video.renderSpriteState(cusprites.frameBottom, x - hull_rdx, y - hull_rdy, 1, angle, 255, r, g, b, total_flip)
-		
+
 		local arm_len = 15
 		local arms = def.arm_offsets
-		
+
 		for i = 1, 4 do
 			local offset = arms[i]
 			local ox = offset[1]
@@ -27514,65 +27669,70 @@
 			local flip = offset[5]
 			local arm_flip = total_flip
 			local hull_factor = offset[6]
-			
+
 			if flip then
 				arm_flip = not total_flip
 			end
-			
+
 			local arm_angle = base_angle - adjustAngle + self.angleLegOffset
 			local hand_angle = arm_angle - adjustAngle * 0.25 * afactor + self.angleLegOffset * 0.5
-			
+
 			if exp > 0 then
 				local exp_angle = self.expandedAngles[i]
-				
+
 				arm_angle = arm_angle + afactor * exp * (math_pi * 0.25 + exp_angle)
 				hand_angle = hand_angle - exp * exp_angle * 0.5
 			end
-			
-			local rx, ry = math.getOffsetPosition(x + hull_dx * hull_factor, y + hull_dy * hull_factor, ox, oy, angle, 1, total_flip)
-			
+
+			local rx, ry = math.getOffsetPosition(x + hull_dx * hull_factor, y + hull_dy * hull_factor, ox, oy, angle, 1,
+				total_flip)
+
 			video.renderSpriteState(cusprites.leg, rx, ry, 1, arm_angle, 255, r, g, b, arm_flip)
-			
+
 			local aff = arm_flip and -1 or 1
 			local hand_x = rx + math_cos(arm_angle) * arm_len * aff
 			local hand_y = ry + math_sin(arm_angle) * arm_len * aff
-			
+
 			video.renderSpriteState(cusprites.foot, hand_x, hand_y, 1, hand_angle, 255, r, g, b, arm_flip)
 		end
-		
+
 		local jolt = self.joltAnim
 		local drill_angle = self.spinTimer * math_pi * 2
-		local tele_expand = 15 * jolt - self.adjustAnim * math.abs(self.angleTarget) * 4 + 3 * exp - math_max(0, math_cos(self.joltTimer * math.pi * 2)) * 8 * jolt
+		local tele_expand = 15 * jolt - self.adjustAnim * math.abs(self.angleTarget) * 4 + 3 * exp -
+		math_max(0, math_cos(self.joltTimer * math.pi * 2)) * 8 * jolt
 		local tele_dx, tele_dy = math_cos(up_angle) * exp * tele_expand, math_sin(up_angle) * exp * tele_expand
 		local drill_off = 10 + 3 * exp
-		local drill_dx, drill_dy = math_cos(up_angle) * (drill_off + exp * tele_expand), math_sin(up_angle) * (drill_off + exp * tele_expand)
-		
+		local drill_dx, drill_dy = math_cos(up_angle) * (drill_off + exp * tele_expand),
+				math_sin(up_angle) * (drill_off + exp * tele_expand)
+
 		video.renderSpriteState(cusprites.drill, x + drill_dx, y + drill_dy, 1, drill_angle, 255, r, g, b, total_flip)
-		
+
 		if jolt > 0 then
-			video.renderSpriteState(cusprites.drillGlow, x + drill_dx, y + drill_dy, 1, drill_angle, jolt * 255, 255, 255, 255, total_flip)
-			video.renderSpriteState(cusprites.drillGlowRing, x + drill_dx, y + drill_dy, 1, drill_angle * 0.5, math.clamp(jolt * 1000 - 800, 0, 255), 255, 255, 255, total_flip)
+			video.renderSpriteState(cusprites.drillGlow, x + drill_dx, y + drill_dy, 1, drill_angle, jolt * 255, 255, 255, 255,
+				total_flip)
+			video.renderSpriteState(cusprites.drillGlowRing, x + drill_dx, y + drill_dy, 1, drill_angle * 0.5,
+				math.clamp(jolt * 1000 - 800, 0, 255), 255, 255, 255, total_flip)
 		end
-		
+
 		video.renderSpriteState(cusprites.tele3, x + tele_dx, y + tele_dy, 1, angle, 255, r, g, b, total_flip)
 		video.renderSpriteState(cusprites.tele2, x + tele_dx * 0.85, y + tele_dy * 0.85, 1, angle, 255, r, g, b, total_flip)
 		video.renderSpriteState(cusprites.tele1, x + tele_dx * 0.4, y + tele_dy * 0.4, 1, angle, 255, r, g, b, total_flip)
 		video.renderSpriteState(def.sprite, x, y, 1, angle, 255, r, g, b, total_flip)
-		
+
 		local bat_offset = -10
 		local bat_step = 5
 		local ammo_factor = self:getAmmo() / self:getMaxAmmo()
-		
+
 		for i = 0, 3 do
 			local poff = bat_offset + bat_step * (i + 0.5)
 			local rx, ry = math_cos(angle) * poff, math_sin(angle) * poff
 			local alp = math.clamp(ammo_factor * 4 - i, 0, 1) * 255
-			
+
 			if alp > 0 then
 				video.renderSpriteState(cusprites.batteryGlow, x + rx, y + ry, 1, angle, alp, 255, 0, 0, not total_flip)
 			end
 		end
-		
+
 		video.renderSpriteState(cusprites.hullTop, x + hull_rdx, y + hull_rdy, 1, angle, 255, r, g, b, total_flip)
 		video.renderSpriteState(cusprites.hullBottom, x - hull_rdx, y - hull_rdy, 1, angle, 255, r, g, b, total_flip)
 	end,
@@ -27699,34 +27859,34 @@
 		if not object.attached then
 			object:setSpeed(0, 0)
 			object:setAngle(angle + math_pi * 0.5)
-			
+
 			local wx, wy, normal, wall = object:findAgainstWallPosition()
-			
+
 			if wx and wall then
 				object:moveTo(wx, wy)
 				object:setAngle(normal + math_pi * 0.5)
-				
+
 				target = wall
 			end
-			
+
 			if target then
 				object:setAttached(target)
 				self:setExpanded(true)
 				object:setPhysicsType("idle")
-				
+
 				return true
 			end
 		end
 	end,
 	onFullyExpanded = function(self, object)
 		object:emitSound("bounceCrystal", 1, 1.5, 200)
-		
+
 		local fx = object:emitFx("prismBlinkActivate")
-		
+
 		fx:setReference(object)
-		
+
 		self.glowAnim = 1
-		
+
 		object:classify("prism")
 	end,
 	nodes = {
@@ -27738,9 +27898,9 @@
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight)
 		local flipped = not facingRight
 		local cusprites = self.def.customSprites
-		
+
 		video.renderSpriteState(cusprites.back, x, y, 1, angle, 255, r, g, b, flipped)
-		
+
 		local anim = self.expandedTimer
 		local up_angle = angle - math_pi * 0.5
 		local ianim = 1 - anim
@@ -27753,29 +27913,30 @@
 		local ff = flipped and -1 or 1
 		local angle_anim = math_min(1, anim * anim * 1.1)
 		local iangle_anim = 1 - angle_anim
-		
+
 		video.renderSpriteState(cusprites.marm, kx, ky, 0.1 + 0.9 * angle_anim, angle, 255, r, g, b, flipped)
 		video.renderSpriteState(cusprites.larm, kx, ky, 1, angle - iangle_anim * math_pi * 0.6 * ff, 255, r, g, b, flipped)
 		video.renderSpriteState(cusprites.rarm, kx, ky, 1, angle + iangle_anim * math_pi * 0.6 * ff, 255, r, g, b, flipped)
-		
+
 		local glow = self.glowAnim
 		local col = COLORS.crystalHack
 		local cr, cg, cb = col.r, col.g, col.b
 		local cglow = 0.25 + 0.75 * glow
-		
+
 		video.renderSpriteState(cusprites.crystal, ux, uy, 1, angle, 255, cr * cglow, cg * cglow, cb * cglow, flipped)
-		
+
 		if glow > 0 then
 			video.renderSpriteState(cusprites.glow, ux, uy, 1, angle, 255 * glow * 0.5, cr, cg, cb, flipped)
-			
+
 			for i = 1, 2 do
 				local shine = math_max(0, math_cos(math_pi * i + _time * 0.1 + ux * 0.02)) * glow
-				local ccr, ccg, ccb = colors.fadeVariables(cr, cg, cb, COLORS.crystalHackHighlight, math_max(0, shine - 0.8) / 0.2)
-				
+				local ccr, ccg, ccb = colors.fadeVariables(cr, cg, cb, COLORS.crystalHackHighlight,
+					math_max(0, shine - 0.8) / 0.2)
+
 				video.renderSpriteState(cusprites.shine[i], ux, uy, 1, angle, shine * 255, ccr, ccg, ccb, flipped)
 			end
 		end
-		
+
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, flipped)
 	end,
 	logic = {
@@ -27896,18 +28057,18 @@
 	end,
 	deployMethod = function(self, object, angle, x, y, target)
 		self:setExpanded(true)
-		
+
 		return true
 	end,
 	onFullyExpanded = function(self, object)
 		object:emitSound("bounceCrystalBig", 1, 1.25, 200)
-		
+
 		local fx = object:emitFx("prismBlinkActivate")
-		
+
 		fx:setReference(object)
-		
+
 		self.glowAnim = 1
-		
+
 		object:classify("prism")
 		object:classify("antenna")
 	end,
@@ -27924,23 +28085,24 @@
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight)
 		local flipped = not facingRight
 		local cusprites = self.def.customSprites
-		
+
 		video.renderSpriteState(self.def.sprite, x, y, 1, angle, 255, r, g, b, flipped)
-		
+
 		local glow = self.glowAnim
 		local col = COLORS.crystalHack
 		local cr, cg, cb = col.r, col.g, col.b
 		local cglow = 0.25 + 0.75 * glow
-		
+
 		video.renderSpriteState(cusprites.crystal, x, y, 1, angle, 255, cr * cglow, cg * cglow, cb * cglow, flipped)
-		
+
 		if glow > 0 then
 			video.renderSpriteState(cusprites.glow, x, y, 1, angle, 255 * glow * 0.5, cr, cg, cb, flipped)
-			
+
 			for i = 1, 2 do
 				local shine = math_max(0, math_cos(math_pi * i + _time * 0.1 + x * 0.02)) * glow
-				local ccr, ccg, ccb = colors.fadeVariables(cr, cg, cb, COLORS.crystalHackHighlight, math_max(0, shine - 0.8) / 0.2)
-				
+				local ccr, ccg, ccb = colors.fadeVariables(cr, cg, cb, COLORS.crystalHackHighlight,
+					math_max(0, shine - 0.8) / 0.2)
+
 				video.renderSpriteState(cusprites.shine[i], x, y, 1, angle, shine * 255, ccr, ccg, ccb, flipped)
 			end
 		end
@@ -28044,78 +28206,83 @@
 	if self.team then
 		local color = self.team:getColor("text")
 		local g_factor = 0.8 + 0.2 * math_cos(self.blinkTimer * math_pi * 2) * math_sin(self.blinkTimer * math_pi * 2.123241)
-		
+
 		g_factor = (g_factor * 0.2 + 0.8 * math_min(1, math_max(0, math_cos(_time * math_pi * 3) * 1))) * glow
-		
-		video.renderSpriteState(self.def.customSprites.light, x, y, 1, angle, 255, math_min(255, r / 5 * (1 - g_factor) + g_factor * color.r), math_min(255, g / 5 * (1 - g_factor) + g_factor * color.g), math_min(255, b / 5 * (1 - g_factor) + g_factor * color.b), facingRight)
-		video.renderSpriteState(self.def.customSprites.glow, x, y, 1, angle, math_min(255, math_max(0, g_factor * 255 * 1.1 - 65)), color.r, color.g, color.b, facingRight)
+
+		video.renderSpriteState(self.def.customSprites.light, x, y, 1, angle, 255,
+			math_min(255, r / 5 * (1 - g_factor) + g_factor * color.r),
+			math_min(255, g / 5 * (1 - g_factor) + g_factor * color.g),
+			math_min(255, b / 5 * (1 - g_factor) + g_factor * color.b), facingRight)
+		video.renderSpriteState(self.def.customSprites.glow, x, y, 1, angle,
+			math_min(255, math_max(0, g_factor * 255 * 1.1 - 65)), color.r, color.g, color.b, facingRight)
 	else
-		video.renderSpriteState(self.def.customSprites.light, x, y, 1, angle, 255, 255 * glow, 255 * glow, 255 * glow, facingRight)
+		video.renderSpriteState(self.def.customSprites.light, x, y, 1, angle, 255, 255 * glow, 255 * glow, 255 * glow,
+			facingRight)
 	end
 end
 
 local function superPlugUpdate(self, actor, time, object)
 	self.blinkTimer = self.blinkTimer + time
-	
+
 	if self.blockExpansionTimer > 0 then
 		self.blockExpansionTimer = self.blockExpansionTimer - time
 	end
-	
+
 	if self.expanded then
 		self.expandedTimer = math_min(1, self.expandedTimer + time / 0.25)
-		
+
 		if self.twigglyFx then
 			self.twigglyFx:remove()
-			
+
 			self.twigglyFx = nil
 		end
-		
+
 		if object and object._physics then
 			object._physics = nil
-			
+
 			object:recreatePhysics()
 		end
 	else
 		local posTo = object or actor
-		
+
 		if self.team then
 			if not self.twigglyFx or self.twigglyFx._remove then
 				self.twigglyFx = posTo:emitPpFx("plugTrailMaker")
-				
+
 				if self.team then
 					local c = self.team:getColor("text")
-					
+
 					self.twigglyFx:applyColor(c)
 				end
-				
+
 				self.twigglyFx:setOwner(posTo)
 			else
 				if self.twigglyFx then
 					self.twigglyFx:setOwner(posTo)
 				end
-				
+
 				if self.twigglyFx.owner == posTo then
 					if object then
 						self.twigglyFx:setPosition(object.x, object.y)
 					else
 						self.twigglyFx:setPosition(actor:getWeaponX(), actor:getWeaponY())
 					end
-					
+
 					self.twigglyFx:setTime(0)
 				else
 					self.twigglyFx:remove()
-					
+
 					self.twigglyFx = nil
 				end
 			end
 		end
-		
+
 		if object and not object._physics then
 			object._physics = self.def.compact_physics
-			
+
 			object:recreatePhysics()
 		end
-		
+
 		self.expandedTimer = math_max(0, self.expandedTimer - time / 0.25)
 	end
 end
@@ -28145,19 +28312,19 @@
 		if self.origin then
 			Behaviours.action(self.origin, "tile", "destroyed", self)
 		end
-		
+
 		object:emitOmniExplosiveForce(300, 100)
-		
+
 		local color = self.team and self.team:getColor("text") or COLORS.white
 		local detail = _config.graphicsFx
-		
+
 		if detail > 0 then
 			for i = 1, 6 * detail + math_random(8, 12) * detail do
 				local obj = object:emitSpark("plugExplodeSpark")
-				
+
 				obj:setSpeed(math_randomAngle(), 2 + math_random() * 22)
 				obj:addSpeed(math_random() * math_pi * 2, math_random() * 42)
-				
+
 				obj.airFriction = 0
 				obj.gravity = 28
 				obj.dieOnCollision = false
@@ -28169,15 +28336,15 @@
 				obj.myFx.blue = color.b
 			end
 		end
-		
+
 		local fx = object:emitPpFx("plugExplodeGlow")
-		
+
 		fx.red = color.r
 		fx.green = color.g
 		fx.blue = color.b
-		
+
 		local fx = object:emitPpFx("plugExplodeGlow")
-		
+
 		object:emitSound("captureFail", 1, 1)
 	end,
 	updateMethod = superPlugUpdate,
@@ -28189,56 +28356,57 @@
 	end,
 	renderMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local def = self.def
-		
+
 		video.renderSpriteState(def.customSprites.smallOutline, x, y, 1, angle, 255, r, g, b, facingRight)
-		
+
 		if self.expandedTimer > 0 then
-			video.renderSpriteState(def.customSprites.outline, x, y, 1 * math_easeOut(self.expandedTimer), angle, 255, r, g, b, facingRight)
+			video.renderSpriteState(def.customSprites.outline, x, y, 1 * math_easeOut(self.expandedTimer), angle, 255, r, g, b,
+				facingRight)
 			video.renderSpriteState(def.sprite, x, y, 1 * math_easeOut(self.expandedTimer), angle, 255, r, g, b, facingRight)
 		end
-		
+
 		video.renderSpriteState(def.customSprites.small, x, y, 1, angle, 255, r, g, b, facingRight)
 		renderPlug(self, x, y, angle, r, g, b, facingRight, glow)
 	end,
 	renderLiteMethod = function(self, x, y, angle, r, g, b, facingRight, glow)
 		local def = self.def
-		
+
 		if self.expanded then
 			video.renderSpriteState(def.sprite, x, y, 1, angle, 255, r, g, b, facingRight)
 		end
-		
+
 		renderPlug(self, x, y, angle, r, g, b, facingRight, glow)
 	end,
 	asObjectCollision = function(object, impact)
 		if not object.itemRef.expanded and object.pickupable and object.itemRef.blockExpansionTimer <= 0 then
 			object.itemRef:setExpanded(true)
-			
+
 			local x = impact.x or object.x
 			local x, y = x, impact.y or object.y
-			
+
 			object:superBounce(impact.angle, x, y)
 		end
 	end,
 	superBounceMethod = function(object, impact_angle, x, y)
 		if object.map then
 			object:emitSound("expandPlug", 0.6, 1)
-			
+
 			local detail = _config.graphicsFx
-			
+
 			if detail > 0 then
 				for i = 1, 4 * detail do
 					local obj = object:emitSparkAt("captureSpark", x, y)
-					
+
 					obj:setSpeed(impact_angle + math_pi * 0.5 * math_random(), math_random() * 2 + 1 + math_random() * 27 + 5)
 					obj:addSpeedXY(object.dx, object.dy)
 				end
 			end
-			
+
 			object:flashWhite(1)
 			object:bounceStartSpeedWithVector(impact_angle, 0.5)
-			
+
 			local speed = object:getSpeed()
-			
+
 			object:emitShake(RANGES.medium + speed * 2.5, speed / 30, speed * 0.25)
 			object:emitPpFx("bounceBlast")
 		end
@@ -28583,29 +28751,29 @@
 	refreshStateMethod = function(self, actor)
 		if actor and actor:hasEquipment(self.def.equipment) and not self.off and actor.map then
 			local light = actor:emitOwnedFx("lightEnhancerLight")
-			
+
 			self.light = light
-			
+
 			light:setReference(actor)
 			light:setAngle(actor:getAbsoluteNodeAngle("reye"))
 			self:updateColors(actor)
 		elseif self.light then
 			self.light:remove()
-			
+
 			self.light = nil
 		end
 	end,
 	updateColors = function(self, actor)
 		if self.light then
 			local col = actor and actor:getIdentityColor() or COLORS.white
-			
+
 			self.light:setColor(col.r, col.g, col.b)
 		end
 	end,
 	updateMethod = function(self, actor, time)
 		if not self.off then
 			local light = self.light
-			
+
 			if light then
 				local x, y = actor:getAbsoluteNodePosition("reye")
 				local ang = actor:getAbsoluteNodeAngle("reye")
@@ -28614,7 +28782,7 @@
 				local distDown = actor:distanceToWall(ang + math_pi * 0.15, 150)
 				local size = math_min(1.5, dist / 150)
 				local vsize = 0.5 + 0.5 * math_min(1, math_min(distUp, distDown) / 150)
-				
+
 				light:setPosition(x, y)
 				light:setAngle(ang)
 				light:setScale(size)
@@ -28652,22 +28820,25 @@
 local DESTROY_METHODS = {
 	valuablePickupFx = function(self, actor, object)
 		if not RENDERING then
-			return 
+			return
 		end
-		
+
 		if object then
 			local fx = object:emitFx("itemShine")
-			
+
 			fx:setMasterScale(0.01)
-			
+
 			local details = _config.graphicsFx
-			
+
 			if details > 0 then
 				for i = 1, 3 + self.def.credits / 3 * details do
-					local fx = object:emitFxAt("itemPickupSpark", object.x + math_randomGaussian() * math_cos(math_randomAngle()) * (5 + self.def.credits / 5), object.y + math_randomGaussian() * math_sin(math_randomAngle()) * (5 + self.def.credits / 5))
-					
+					local fx = object:emitFxAt("itemPickupSpark",
+						object.x + math_randomGaussian() * math_cos(math_randomAngle()) * (5 + self.def.credits / 5),
+						object.y + math_randomGaussian() * math_sin(math_randomAngle()) * (5 + self.def.credits / 5))
+
 					fx:setTime(-i / 15)
-					fx:setSpeed(math_angleBetweenPoints(fx.x, fx.y, object.x, object.y) + math_pi, math_distance(fx.x, fx.y, object.x, object.y) * 10)
+					fx:setSpeed(math_angleBetweenPoints(fx.x, fx.y, object.x, object.y) + math_pi,
+						math_distance(fx.x, fx.y, object.x, object.y) * 10)
 					fx:setTarget(actor)
 				end
 			end
@@ -28675,35 +28846,35 @@
 	end,
 	destroyWeapon = function(object, self)
 		if not RENDERING then
-			return 
+			return
 		end
-		
+
 		local p = self:addAsDebris(object.x, object.y, object.map, object.angle, object.flipped)
-		
+
 		p:setBurn(1 + math_random() * 0.5)
 		p:setGlow(1, 2.5)
-		
+
 		if _config.graphicsFx > 0 then
 			p:setSparkShoot(2.5)
 		end
-		
+
 		p:bringToBackground()
 		p.map.physics:setEntityAngleSpeed(p.body, -math_pi * (math_random() * 1 + 1) / 2 * facingToFlipFactor(object.flipped))
 		p:setSpeed(-math_pi * 0.5 + math_randomGaussian() * math_pi * 0.1, math_random() * 10 + 15)
 		p:addSpeedXY(object.dx, object.dy)
 		object:emitSound("destroyWeapon", 1, 1)
 		object:emitPpFx("destroyFlash")
-		
+
 		local details = _config.graphicsFx
-		
+
 		if details > 0 then
 			for i = 1, 3 * details + math_random(3) * details do
 				local offAng = math_randomAngle()
 				local obj = object:emitSpark("destroySpark")
-				
+
 				obj:setSpeed(offAng, math_random() * 9 + 10)
 				obj:addSpeedXY(object.dx, object.dy)
-				
+
 				obj.dieOnCollision = false
 				obj.deathFxName = "postTinyDestroySpark"
 				obj.collisionSound = "fizzleSpark"
@@ -28713,27 +28884,27 @@
 	end,
 	destroyValuable = function(object, self)
 		if not RENDERING then
-			return 
+			return
 		end
-		
+
 		object:emitSound("destroyConvertable", 1, 1)
 		object:emitPpFx("destroyConvertableFlash")
-		
+
 		local obj = object:emitSpark("destroyMark")
-		
+
 		obj.dieOnCollision = false
-		
+
 		local cred = math_max(1, math_floor(self.def.credits / 40))
 		local details = _config.graphicsFx
-		
+
 		if details > 0 then
 			for i = 1, cred + math_random(cred) * details do
 				local offAng = math_randomAngle()
 				local obj = object:emitSpark("destroySpark")
-				
+
 				obj:setSpeed(offAng, math_random() * 12 + 15)
 				obj:addSpeedXY(object.dx, object.dy)
-				
+
 				obj.dieOnCollision = false
 				obj.deathFxName = "postTinyDestroySpark"
 				obj.collisionSound = "fizzleSpark"
@@ -28743,26 +28914,26 @@
 	end,
 	destroyGeneric = function(object, self)
 		if not RENDERING then
-			return 
+			return
 		end
-		
+
 		object:emitSound("destroyGeneric", 1, 1)
 		object:emitPpFx("destroyFlash")
-		
+
 		local obj = object:emitSpark("destroyMark")
-		
+
 		obj.dieOnCollision = false
-		
+
 		local details = _config.graphicsFx
-		
+
 		if details > 0 then
 			for i = 1, 3 * details + math_random(3) * details do
 				local offAng = math_randomAngle()
 				local obj = object:emitSpark("destroySpark")
-				
+
 				obj:setSpeed(offAng, math_random() * 12 + 10)
 				obj:addSpeedXY(object.dx, object.dy)
-				
+
 				obj.dieOnCollision = false
 				obj.deathFxName = "postTinyDestroySpark"
 				obj.collisionSound = "fizzleSpark"
@@ -28777,289 +28948,291 @@
 
 local defs_items = DEFS.items
 
-function defs_items.pre_init()
-	for index, item in pairs(ITEMS) do
+function defs_items.pre_init(table)
+	for index, item in pairs(table) do
 		if item.spriteName and item.droppable == nil then
 			item.droppable = true
 		end
 	end
 end
 
-function defs_items.init()
-	for index, item in pairs(ITEMS) do
-		def_logic.defs_apply_key(ITEMS, index)
-		
-		if not item.aimsAtActorsMethod then
-			item.aimsAtActorsMethod = defaultAimsAtActors
-		end
-		
-		if item.valuable or item.botanic or item.artifact or item.electronics then
-			item.bounty = true
-			item.onPickedUpMethod = DESTROY_METHODS.valuablePickupFx
-			item.reservedForPlayer = true
-		end
-		
-		item.bulletTimeDistanceFactor = item.bulletTimeDistanceFactor or 1
-		item.bulletTimeFactor = item.bulletTimeFactor or 1
-		item.getBulletTimeFactor = item.getBulletTimeFactor or defaultGetBulletTimeFactor
-		item.getBulletTimeDistanceFactor = item.getBulletTimeDistanceFactor or defaultGetBulletTimeDistanceFactor
-		
-		if item.legend then
-			item.indestructable = true
-		end
-		
-		if item.spriteName and item.droppable == nil then
-			item.droppable = true
-		end
-		
-		if item.weapon or item.carried or item.ability then
-			if item.aimsAtObjects == nil then
-				item.aimsAtObjects = true
-			end
-			
-			if item.aimsAtBullets == nil then
-				item.aimsAtBullets = false
-			end
-		end
-		
-		if item.weapon and not item.melee then
-			item.ranged = true
-		end
-		
-		if item.weapon then
-			item.listing = true
-		end
-		
-		if item.carried then
-			item.listing = true
-		end
-		
-		if item.weapon or item.hull or item.throwAttack or item.legend or item.carried or item.melee then
-			ITEMS_RACKABLE[index] = item
-		end
-		
-		if item.carried and not item.huge then
-			item.thrown = true
-		end
-		
-		if item.equipment or item.hull then
-			item.equipped = true
-		end
-		
-		if item.consumable and not item.ammo and not item.energyValue then
-			item.singleUse = true
-		end
-		
-		if not item.equipment and not item.hull then
-			item.general = true
-		end
-		
-		if item.equipment and not item.hull then
-			item.gear = true
-		end
-		
-		if item.ammoType then
-			item.supplyType = "ammo"
-		end
-		
-		if item.stackable then
-			item.stackIndex = item.stackIndex or 1
-		end
-		
-		if item.onUsedSemiMethod then
-			item.semi = true
-		end
-		
-		if item.reloadSequence then
-			ANIMATIONS[index .. "Reload"] = {
-				fade = 0.15,
-				pose = "fiddle",
-				isReload = true,
-				time = item.reloadTime,
-				sequence = item.reloadSequence
-			}
-			item.reloadAnimation = index .. "Reload"
-		end
-		
-		if item.useSequence then
-			ANIMATIONS[index .. "Use"] = {
-				pose = item.usePose,
-				time = item.useTime or item.cooldown,
-				sequence = item.useSequence,
-				fade = item.useFade or 0.15
-			}
-			item.useAnimation = index .. "Use"
-		end
-		
-		if item.upgradeSequence then
-			ANIMATIONS[index .. "Upgrade"] = {
-				fade = 0.15,
-				time = 2,
-				pose = item.upgradePose or "fiddle",
-				sequence = item.upgradeSequence
-			}
-			item.upgradeAnimation = index .. "Upgrade"
-		end
-		
-		if item.disarmSequence then
-			ANIMATIONS[index .. "Disarm"] = {
-				pose = item.disarmPose,
-				time = item.disarmTime or item.cooldown,
-				sequence = item.disarmSequence,
-				fade = item.disarmFade or 0.15
-			}
-			item.disarmAnimation = index .. "Disarm"
-		end
-		
-		if item.rackable and not item.rack then
-			item.rack = "other"
-		end
-		
-		if item.rack then
-			DEFS.ITEM_RACKS[item.rack] = true
-		end
-		
-		item.health = item.health or 0.5
-		item.flip_offset = item.flip_offset or math.pi * 0.5
-		
-		if item.rack or item.hull then
-			item.blueprint = true
-		end
-		
-		if item.upgrades and not item.hidden then
-			assert(item.upgrade, "upgrade missing from item", index)
-			
-			if type(item.upgrades) == "table" then
-				for _, upg in pairs(item.upgrades) do
-					addUpgrade(upg, index)
-					
-					local udef = ITEMS[upg]
-					
+function defs_items.init(table)
+	for index, item in pairs(table) do
+		if not item.logic_applied then
+			def_logic.defs_apply_key(table, index)
+
+			if not item.aimsAtActorsMethod then
+				item.aimsAtActorsMethod = defaultAimsAtActors
+			end
+
+			if item.valuable or item.botanic or item.artifact or item.electronics then
+				item.bounty = true
+				item.onPickedUpMethod = DESTROY_METHODS.valuablePickupFx
+				item.reservedForPlayer = true
+			end
+
+			item.bulletTimeDistanceFactor = item.bulletTimeDistanceFactor or 1
+			item.bulletTimeFactor = item.bulletTimeFactor or 1
+			item.getBulletTimeFactor = item.getBulletTimeFactor or defaultGetBulletTimeFactor
+			item.getBulletTimeDistanceFactor = item.getBulletTimeDistanceFactor or defaultGetBulletTimeDistanceFactor
+
+			if item.legend then
+				item.indestructable = true
+			end
+
+			if item.spriteName and item.droppable == nil then
+				item.droppable = true
+			end
+
+			if item.weapon or item.carried or item.ability then
+				if item.aimsAtObjects == nil then
+					item.aimsAtObjects = true
+				end
+
+				if item.aimsAtBullets == nil then
+					item.aimsAtBullets = false
+				end
+			end
+
+			if item.weapon and not item.melee then
+				item.ranged = true
+			end
+
+			if item.weapon then
+				item.listing = true
+			end
+
+			if item.carried then
+				item.listing = true
+			end
+
+			if item.weapon or item.hull or item.throwAttack or item.legend or item.carried or item.melee then
+				ITEMS_RACKABLE[index] = item
+			end
+
+			if item.carried and not item.huge then
+				item.thrown = true
+			end
+
+			if item.equipment or item.hull then
+				item.equipped = true
+			end
+
+			if item.consumable and not item.ammo and not item.energyValue then
+				item.singleUse = true
+			end
+
+			if not item.equipment and not item.hull then
+				item.general = true
+			end
+
+			if item.equipment and not item.hull then
+				item.gear = true
+			end
+
+			if item.ammoType then
+				item.supplyType = "ammo"
+			end
+
+			if item.stackable then
+				item.stackIndex = item.stackIndex or 1
+			end
+
+			if item.onUsedSemiMethod then
+				item.semi = true
+			end
+
+			if item.reloadSequence then
+				ANIMATIONS[index .. "Reload"] = {
+					fade = 0.15,
+					pose = "fiddle",
+					isReload = true,
+					time = item.reloadTime,
+					sequence = item.reloadSequence
+				}
+				item.reloadAnimation = index .. "Reload"
+			end
+
+			if item.useSequence then
+				ANIMATIONS[index .. "Use"] = {
+					pose = item.usePose,
+					time = item.useTime or item.cooldown,
+					sequence = item.useSequence,
+					fade = item.useFade or 0.15
+				}
+				item.useAnimation = index .. "Use"
+			end
+
+			if item.upgradeSequence then
+				ANIMATIONS[index .. "Upgrade"] = {
+					fade = 0.15,
+					time = 2,
+					pose = item.upgradePose or "fiddle",
+					sequence = item.upgradeSequence
+				}
+				item.upgradeAnimation = index .. "Upgrade"
+			end
+
+			if item.disarmSequence then
+				ANIMATIONS[index .. "Disarm"] = {
+					pose = item.disarmPose,
+					time = item.disarmTime or item.cooldown,
+					sequence = item.disarmSequence,
+					fade = item.disarmFade or 0.15
+				}
+				item.disarmAnimation = index .. "Disarm"
+			end
+
+			if item.rackable and not item.rack then
+				item.rack = "other"
+			end
+
+			if item.rack then
+				DEFS.ITEM_RACKS[item.rack] = true
+			end
+
+			item.health = item.health or 0.5
+			item.flip_offset = item.flip_offset or math.pi * 0.5
+
+			if item.rack or item.hull then
+				item.blueprint = true
+			end
+
+			if item.upgrades and not item.hidden then
+				assert(item.upgrade, "upgrade missing from item", index)
+
+				if type(item.upgrades) == "table" then
+					for _, upg in pairs(item.upgrades) do
+						addUpgrade(upg, index)
+
+						local udef = table[upg]
+
+						udef.maxUpgrades = (udef.maxUpgrades or 0) + (item.maxLevel or 1)
+
+						if udef.rackable or udef.hull then
+							item.blueprint = true
+						end
+					end
+				else
+					addUpgrade(item.upgrades, index)
+
+					local udef = table[item.upgrades]
+
 					udef.maxUpgrades = (udef.maxUpgrades or 0) + (item.maxLevel or 1)
-					
+
 					if udef.rackable or udef.hull then
 						item.blueprint = true
 					end
 				end
-			else
-				addUpgrade(item.upgrades, index)
-				
-				local udef = ITEMS[item.upgrades]
-				
-				udef.maxUpgrades = (udef.maxUpgrades or 0) + (item.maxLevel or 1)
-				
-				if udef.rackable or udef.hull then
-					item.blueprint = true
+			end
+
+			for index, cat in pairs(Item.convertableCategories) do
+				if item[cat] then
+					item.convertable = true
 				end
 			end
-		end
-		
-		for index, cat in pairs(Item.convertableCategories) do
-			if item[cat] then
-				item.convertable = true
+
+			if item.levelCredits or item.credits then
+				item.buyable = true
 			end
-		end
-		
-		if item.levelCredits or item.credits then
-			item.buyable = true
-		end
-		
-		if not item.asObjectDestroy then
-			if item.weapon then
-				item.asObjectDestroy = DESTROY_METHODS.destroyWeapon
-			elseif item.convertable then
-				item.asObjectDestroy = DESTROY_METHODS.destroyValuable
+
+			if not item.asObjectDestroy then
+				if item.weapon then
+					item.asObjectDestroy = DESTROY_METHODS.destroyWeapon
+				elseif item.convertable then
+					item.asObjectDestroy = DESTROY_METHODS.destroyValuable
+				else
+					item.asObjectDestroy = DESTROY_METHODS.destroyGeneric
+				end
+			end
+
+			if item.getHitAbsorbationBonus and not item.defenceFactor then
+				item.defenceFactor = 0.1
+			end
+
+			if (item.credits or item.levelCredits) and not item.interact and not item.ability then
+				item.sellable = true
+			end
+
+			if item.interact or item.personal then
+				item.ability = true
+			end
+
+			if item.cooldownReductionSemi or item.getCooldownReductionSemi then
+				item.hasSemiCooldown = true
+			end
+
+			if item.ammo or item.usedBy then
+				item.supplies = true
+			end
+
+			if not item.ammo and not item.equipment and not item.hull and not item.weapon and not item.consumable and not item.upgrade and not item.thrown then
+				item.other = true
+			end
+
+			if item.bounceSound and not SOUNDS[item.bounceSound] then
+				D.p(1, "items", item.bounceSound .. " not a defined sound")
+			end
+
+			if item.getAimAbove or item.aimAbove then
+				item.aimsAbove = true
+			end
+
+			if item.equipment then
+				EQUIPMENT[item.equipment] = true
+			end
+
+			if item.upgrade then
+				ITEMS_UPGRADES[index] = item
+			end
+
+			if item.predictable == nil then
+				item.predictable = true
+			end
+
+			item.index = index
+			item.editName = item.name
+
+			if item.maxLevel then
+				item.editName = item.editName .. " (max " .. item.maxLevel .. ")"
+			end
+
+			item.feedbackTime = item.feedbackTime or 0.33
+
+			if item.hull then
+				item.classification = "hull"
+			elseif item.specialAddMethod then
+				item.classification = "special"
+			elseif item.upgrades then
+				item.classification = "upgrade"
+			elseif item.huge then
+				item.classification = "huge"
+			elseif item.weapon or item.carried or item.ability or item.peace or item.deployable then
+				item.classification = "active"
+			elseif item.equipment then
+				item.classification = "equipment"
 			else
-				item.asObjectDestroy = DESTROY_METHODS.destroyGeneric
+				item.classification = "general"
 			end
+
+			if item.huge then
+				item.neverIgnore = true
+			end
+
+			if item.recoilSpeed or item.recoilAngle or item.recoilFatigue or item.recoilControl then
+				item.hasRecoil = true
+
+				assert(item.recoilSpeed, index)
+				assert(item.recoilAngle, index)
+				assert(item.recoilFatigue, index)
+				assert(item.recoilControl, index)
+			end
+
+			item.localizedNameId = "item_" .. (item.localizedId or index)
 		end
-		
-		if item.getHitAbsorbationBonus and not item.defenceFactor then
-			item.defenceFactor = 0.1
-		end
-		
-		if (item.credits or item.levelCredits) and not item.interact and not item.ability then
-			item.sellable = true
-		end
-		
-		if item.interact or item.personal then
-			item.ability = true
-		end
-		
-		if item.cooldownReductionSemi or item.getCooldownReductionSemi then
-			item.hasSemiCooldown = true
-		end
-		
-		if item.ammo or item.usedBy then
-			item.supplies = true
-		end
-		
-		if not item.ammo and not item.equipment and not item.hull and not item.weapon and not item.consumable and not item.upgrade and not item.thrown then
-			item.other = true
-		end
-		
-		if item.bounceSound and not SOUNDS[item.bounceSound] then
-			D.p(1, "items", item.bounceSound .. " not a defined sound")
-		end
-		
-		if item.getAimAbove or item.aimAbove then
-			item.aimsAbove = true
-		end
-		
-		if item.equipment then
-			EQUIPMENT[item.equipment] = true
-		end
-		
-		if item.upgrade then
-			ITEMS_UPGRADES[index] = item
-		end
-		
-		if item.predictable == nil then
-			item.predictable = true
-		end
-		
-		item.index = index
-		item.editName = item.name
-		
-		if item.maxLevel then
-			item.editName = item.editName .. " (max " .. item.maxLevel .. ")"
-		end
-		
-		item.feedbackTime = item.feedbackTime or 0.33
-		
-		if item.hull then
-			item.classification = "hull"
-		elseif item.specialAddMethod then
-			item.classification = "special"
-		elseif item.upgrades then
-			item.classification = "upgrade"
-		elseif item.huge then
-			item.classification = "huge"
-		elseif item.weapon or item.carried or item.ability or item.peace or item.deployable then
-			item.classification = "active"
-		elseif item.equipment then
-			item.classification = "equipment"
-		else
-			item.classification = "general"
-		end
-		
-		if item.huge then
-			item.neverIgnore = true
-		end
-		
-		if item.recoilSpeed or item.recoilAngle or item.recoilFatigue or item.recoilControl then
-			item.hasRecoil = true
-			
-			assert(item.recoilSpeed, index)
-			assert(item.recoilAngle, index)
-			assert(item.recoilFatigue, index)
-			assert(item.recoilControl, index)
-		end
-		
-		item.localizedNameId = "item_" .. (item.localizedId or index)
 	end
-	
-	for index, item in pairs(ITEMS) do
+
+	for index, item in pairs(table) do
 		if not item.renderMethod then
 			if item.upgradable then
 				item.renderMethod = genericRenderUpgrades
@@ -29067,37 +29240,35 @@
 				item.renderMethod = genericRender
 			end
 		end
-		
+
 		if item.renderMethod then
 			item.rigRenderMethod = item.rigRenderMethod or item.renderMethod
 		end
-		
+
 		if item.hasRecoil then
 			math.randomseed(item.recoilSeed or 1)
-			
+
 			local maxRecoilSteps = (item.maxAmmo or 1) + (item.maxAmmoUpgrade or 0)
 			local recoilAngle = item.recoilAngle or 1
-			
+
 			item.maxRecoilSteps = maxRecoilSteps
-			
+
 			local recoilTable = {}
-			
+
 			item.recoilTable = recoilTable
-			
+
 			for i = 1, maxRecoilSteps do
 				if item.recoilExponent then
 					local prg = i / maxRecoilSteps
 					local recoil = recoilAngle
-					
+
 					recoilTable[i] = -math.pow(prg, item.recoilExponent) * recoil
 				else
 					local random_part = math_random() * math_pi * recoilAngle - math_random() * math_pi * recoilAngle
-					
+
 					recoilTable[i] = random_part
 				end
 			end
 		end
 	end
-	
-	math.initRandom()
 end
diff -X exclude -ruN daisyMoon/mainApp.lua moddedDaisyMoon/mainApp.lua
--- daisyMoon/mainApp.lua	2023-11-30 02:17:06.622108480 +0100
+++ moddedDaisyMoon/mainApp.lua	2023-12-06 20:40:43.531099524 +0100
@@ -856,7 +856,8 @@
 	mod = true,
 	galaxy = true,
 	talk = true,
-	asset = true
+	asset = true,
+	alloy = true,
 }
 
 function app.isModeEditor(mode)
@@ -871,9 +872,10 @@
 	"world",
 	"mod",
 	"asset",
+	"alloy",
 	"stageSet",
 	"talk",
-	"team"
+	"team",
 }
 
 function app.disableEditStates()
@@ -900,6 +902,8 @@
 		dofile("stageEdit.lua")
 		dofile("worldEdit.lua")
 		dofile("modEdit.lua")
+		dofile("alloyEdit.lua")
+		dofile("asset.lua")
 		dofile("stageSetEdit.lua")
 		dofile("adventureEdit.lua")
 		dofile("talkEdit.lua")
@@ -1173,6 +1177,12 @@
 			
 			states.disable("asset")
 		end
+
+		if not states.get("alloy") then
+			local al = states.addNewOfClass(AlloyEdit, "alloy")
+
+			states.disable("alloy")
+		end
 		
 		if states.get("edit") and states.isEnabled("edit") then
 			states.disable("edit")
@@ -1211,6 +1221,24 @@
 		states.destroy("game")
 		app.disableEditStatesExcept("galaxy")
 		states.enable("galaxy")
+	elseif toMode == "alloy" then
+		app.verifyEditors()
+		states.enable("input")
+		states.get("music"):stopCurrentMusic()
+		
+		if not states.get("alloy") then
+			local al = states.addNewOfClass(AlloyEdit, "alloy")
+
+			if _devState.alloy and _devState.alloy ~= "" then
+				resources.load("alloy", _devState.alloy, al, true)
+			end
+
+			states.disable("alloy")
+		end
+		states.set_mouse_visible_locked("alloy", true, false)
+		states.destroy("game")
+		app.disableEditStatesExcept("alloy")
+		states.enable("alloy")
 	elseif toMode == "game" then
 		app.runtime.showMouse = false
 		
diff -X exclude -ruN daisyMoon/mainConstants.lua moddedDaisyMoon/mainConstants.lua
--- daisyMoon/mainConstants.lua	2023-11-30 02:17:06.624108474 +0100
+++ moddedDaisyMoon/mainConstants.lua	2023-12-06 20:40:43.531099524 +0100
@@ -207,6 +207,19 @@
 		r = 130
 	}
 }
+RESOURCES.alloy = {
+	variable = "alloy",
+	editor = "alloy",
+	localization = true,
+	meta = "alloy",
+	list = "alloys",
+	folder = "alloys",
+	color = {
+		g = 32,
+		b = 128,
+		r = 128
+	}
+}
 PREFIXES = {
 	slot = "slot"
 }
@@ -247,6 +260,7 @@
 	workshop = "workshop",
 	ircuser = "irc",
 	mod = "mods",
+	alloy = "alloys",
 	betstats = "irc_stats",
 	slot = "slots",
 	log = "logs",
diff -X exclude -ruN daisyMoon/main.lua moddedDaisyMoon/main.lua
--- daisyMoon/main.lua	2023-11-30 02:17:06.629108459 +0100
+++ moddedDaisyMoon/main.lua	2023-12-06 20:40:43.531099524 +0100
@@ -73,10 +73,14 @@
 local math = math
 
 sorting = {}
-app.developerMode = daisy.isDeveloperModeEnabled()
+--app.developerMode = daisy.isDeveloperModeEnabled()
+app.developerMode = true
 
 dofile("gameDependencies.lua")
 
+-- testing and debug
+--AlloyCustomTest()
+
 function drequire(v)
 	local preload = package.preload[v]
 	
@@ -214,7 +218,8 @@
 
 local function defsInit()
 	DEFS.hint_layouts.verify()
-	DEFS.items.pre_init()
+	AlloyPreInitItems()
+	--DEFS.items.pre_init()
 end
 
 function DEFS.load()
@@ -517,8 +522,9 @@
 	colors.init()
 	profiles.init()
 	attacks.init()
-	DEFS.items.init()
-	DEFS.objects.init()
+	AlloyInit()
+	--DEFS.items.init()
+	--DEFS.objects.init()
 	
 	if DEDICATED then
 		return 
@@ -547,8 +553,9 @@
 			return 
 		end
 	end
-	
-	DEBUG.showDebug = false
+
+	-- additional debug data if needed
+	DEBUG.showDebug = true
 	
 	if DEBUG.minimalMode then
 		states.add(MenuState:new(), "menu")
diff -X exclude -ruN daisyMoon/objects.lua moddedDaisyMoon/objects.lua
--- daisyMoon/objects.lua	2023-11-30 02:17:06.631108453 +0100
+++ moddedDaisyMoon/objects.lua	2023-12-06 20:40:43.535099516 +0100
@@ -85,14 +85,14 @@
 	hash = true,
 	onInserted = function(map, ent)
 		local player = ent.player
-		
+
 		if player then
 			player:setHealedObject(ent)
 		end
 	end,
 	onRemoved = function(map, ent)
 		local player = ent.player
-		
+
 		if player and player.healedObject == ent then
 			player:setHealedObject(nil)
 		end
@@ -115,7 +115,7 @@
 OBJECT_CLASSIFICATIONS.objective = {
 	onInserted = function(map, ent)
 		local g = map:getGame()
-		
+
 		if g then
 			g.mode:onObjectiveObjectAdded(ent)
 		end
@@ -124,7 +124,7 @@
 OBJECT_CLASSIFICATIONS.track = {
 	onInserted = function(map, ent)
 		local g = map:getGame()
-		
+
 		if g then
 			for index, view in pairs(g.views) do
 				if not view:tracks(ent) then
@@ -135,7 +135,7 @@
 	end,
 	onRemoved = function(map, ent)
 		local g = map:getGame()
-		
+
 		if g then
 			for index, view in pairs(g.views) do
 				if view:tracks(ent) then
@@ -163,18 +163,18 @@
 
 local function bs_render_inserted(self, ent, classification)
 	local def = ent.def
-	
+
 	if def.renderMethod then
 		local linearObjects = self.linearObjects or {}
-		
+
 		self.linearObjects = linearObjects
-		
+
 		local classifiedObjects = linearObjects[classification] or {}
-		
+
 		linearObjects[classification] = classifiedObjects
-		
+
 		local idSortedObjects = classifiedObjects[def] or {}
-		
+
 		classifiedObjects[def] = idSortedObjects
 		idSortedObjects[ent] = ent
 		ent.idSortedObjects = idSortedObjects
@@ -183,16 +183,16 @@
 
 local function bs_render_removed(self, ent, classification)
 	local def = ent.def
-	
+
 	if def.renderMethod then
 		local linearObjects = self.linearObjects
-		
+
 		if linearObjects then
 			local classifiedObjects = linearObjects[classification]
-			
+
 			if classifiedObjects then
 				local idSortedObjects = classifiedObjects[def]
-				
+
 				if idSortedObjects then
 					idSortedObjects[ent] = nil
 				end
@@ -252,10 +252,10 @@
 OBJECT_CLASSIFICATIONS.story = {
 	onInserted = function(map, ent)
 		local g = map:getGame()
-		
+
 		if g then
 			g:setStoryPotentialItem(ent.itemRef, ent)
-			
+
 			if ent.generator then
 				ent.generator:onChildPromotedToStory(ent)
 			end
@@ -263,7 +263,7 @@
 	end,
 	onRemoved = function(map, ent)
 		local g = map:getGame()
-		
+
 		if g then
 			g:removeStoryPotentialItem(ent.itemRef, ent)
 		end
@@ -325,7 +325,7 @@
 
 function Object:updateHidden(time)
 	self.hidden_duration = self.hidden_duration - time
-	
+
 	if self.hidden_duration <= 0 then
 		self:removeHidden()
 	end
@@ -341,9 +341,9 @@
 	self.timeFactor = 1
 	self.pingTimeFactor = 1
 	self.physicsTimeFactor = 1
-	
+
 	self:setType(type)
-	
+
 	if DEBUG.logObjects then
 		D.logObject(self)
 	end
@@ -359,7 +359,7 @@
 
 function Object.getLocalizedNameId(type)
 	local def = OBJECTS[type]
-	
+
 	return def.localizedId
 end
 
@@ -391,7 +391,7 @@
 	if self.itemRef then
 		return self.itemRef:getDescription()
 	end
-	
+
 	return localize.get(Object.getLocalizedNameId(self.type))
 end
 
@@ -403,11 +403,11 @@
 	if owner ~= self.owner then
 		self:setOwner(owner)
 		self:setTime(0)
-		
+
 		if self.map then
 			local fx = self:emitFx("ownerRing")
 			local color = owner and owner:getIdentityColor() or COLORS.white
-			
+
 			fx:applyColor(color)
 			fx:setReference(self)
 			helpers.fxGenerator("bioHack", self.map, self.x, self.y, 1, 1, 1, 0, nil, nil)
@@ -417,7 +417,7 @@
 
 function Object:getHelperOwner()
 	local owner = self.owner
-	
+
 	if owner and owner._category == "actor" then
 		return owner:getHelperOwner()
 	end
@@ -428,28 +428,28 @@
 		if not self.fluidType and self:getGravity() then
 			self:classify("inFluid")
 		end
-		
+
 		if self.fluidType ~= fluidType then
 			local entered_o = self.def.fluidEntered
-			
+
 			if entered_o and entered_o(self, fluidType) then
 			else
 				local fluidDef = fluidCluster.fluidDef
-				
+
 				if fluidDef.onEntered then
 					fluidDef.onEntered(self, fluidCluster)
 				end
 			end
-			
+
 			if self.itemRef then
 				local entered = self.itemRef.def.asObjectFluidEntered
-				
+
 				if entered then
 					entered(self, self.itemRef)
 				end
 			end
 		end
-		
+
 		self.fluidSet = true
 		self.fluidType = fluidType
 		self.fluidCluster = fluidCluster
@@ -462,37 +462,37 @@
 	for obj, _ in pairs(list) do
 		if not obj.fluidSet then
 			obj:declassify("inFluid")
-			
+
 			obj.fluidType = nil
 			obj.fluidCluster = nil
 		else
 			local time = obj.pingTimeFactor * time
-			
+
 			obj.fluidSet = false
-			
+
 			local fluidCluster = obj.fluidCluster
 			local surfaceY = fluidCluster:getTopAt(obj.x, obj.y)
 			local actorRadius = obj.def.bounds:getRadius()
 			local fluidDef = fluidCluster.fluidDef
 			local density = fluidDef.density
 			local submersion = math.min(1, (obj.y + actorRadius - surfaceY) / (actorRadius * 2))
-			
+
 			obj.submersion = submersion
-			
+
 			local force = -(density * (submersion / obj:getDensity()) * obj:getGravity())
-			
+
 			if force < 0 then
 				obj:addSpeedXY(0, force * time)
 			end
-			
+
 			local speed = obj:getSpeed()
 			local amt = fluidDef.friction
-			
+
 			obj:stopSpeedXY(amt, amt, time)
 			obj:stopAngleSpeed(1, time * submersion)
-			
+
 			local up = obj.fluidCluster.fluidDef.objectUpdate
-			
+
 			if up then
 				up(obj, submersion, time)
 			end
@@ -502,9 +502,9 @@
 
 function Object:setTeam(t)
 	self.team = t
-	
+
 	local def = self.def
-	
+
 	if def.onTeamSet then
 		def.onTeamSet(self, t)
 	end
@@ -512,7 +512,7 @@
 
 function Object:initRender(booker)
 	sprites.requireDefsKey(booker, OBJECTS, self.type)
-	
+
 	if self.itemRef then
 		self.itemRef:initRender(booker)
 	end
@@ -520,41 +520,41 @@
 
 function Object:onAdded(booker)
 	self:initRender(self.map)
-	
+
 	local def = self.def
-	
+
 	if def.sensorMethod then
 		self.sensors = {}
 	end
-	
+
 	if not self.prediction then
 		local ren_cla = def.render_classifications
-		
+
 		if ren_cla then
 			for index, classi in pairs(ren_cla) do
 				self:classify(classi)
 			end
 		end
-		
+
 		if self:generatesWarning() then
 			self:classify("warning")
 		end
-		
+
 		if def.isTarget and (not self.physicsType or self.physicsType == "normal") then
 			self:classify("target")
 		end
-		
+
 		if self:getActor() then
 			self:classify("hud")
 		end
 	end
-	
+
 	self:onAwake()
-	
+
 	if def.onAddedMethod then
 		def.onAddedMethod(self)
 	end
-	
+
 	if def.classifications then
 		for index, classi in pairs(def.classifications) do
 			self:classify(classi)
@@ -570,7 +570,7 @@
 	elseif self:is("background") then
 		self:declassify("background")
 	end
-	
+
 	if self:is("light") then
 		self:declassify("light")
 	end
@@ -579,7 +579,7 @@
 function Object:setHiddenFor(dur)
 	if not self.hidden_duration then
 		self.hidden_duration = dur
-		
+
 		if self:is("foreground") then
 			self:declassify("foreground")
 		elseif self:is("middleground") then
@@ -587,47 +587,47 @@
 		elseif self:is("background") then
 			self:declassify("background")
 		end
-		
+
 		self:declassify("awake")
 		self:declassify("update")
 		self:declassify("warning")
 		self:classify("hidden")
-		
+
 		local def = self.def
-		
+
 		if def.classifications then
 			for index, classi in pairs(self.def.classifications) do
 				self:declassify(classi)
 			end
 		end
-		
+
 		if self.def.isTarget then
 			self:declassify("target")
 		end
-		
+
 		if self.teamObjective then
 			local team = self.teamObjectiveTeam
-			
+
 			if team then
 				self:declassifySub("teamObjective", team)
 			end
 		end
-		
+
 		if self:getActor() then
 			self:declassify("hud")
 		end
-		
+
 		if self.body then
 			local physics = self.map.physics
-			
+
 			self.old_angle_speed = physics:getEntityAngleSpeed(self.body)
 			self.old_dx, self.old_dy = self.startDx or self.dx, self.startDy or self.dy
-			
+
 			physics:setEntityAngleSpeed(self.body, 0)
 			physics:setEntitySpeed(self.body, 0, 0)
 			self:forceIdlePhysicsType()
 		end
-		
+
 		return true
 	else
 		return false
@@ -637,55 +637,55 @@
 function Object:removeHidden()
 	if self.hidden_duration then
 		self.hidden_duration = nil
-		
+
 		self:declassify("hidden")
 		self:classify("awake")
-		
+
 		local def = self.def
 		local ren_cla = def.render_classifications
-		
+
 		if ren_cla then
 			for index, classi in pairs(ren_cla) do
 				self:classify(classi)
 			end
 		end
-		
+
 		if self:generatesWarning() then
 			self:classify("warning")
 		end
-		
+
 		if def.classifications then
 			for index, classi in pairs(self.def.classifications) do
 				self:classify(classi)
 			end
 		end
-		
+
 		if self.def.isTarget and (not self.physicsType or self.physicsType == "normal") then
 			self:classify("target")
 		end
-		
+
 		if self.teamObjective then
 			local team = self.teamObjectiveTeam
-			
+
 			if team then
 				self:classifySub("teamObjective", team)
 			end
 		end
-		
+
 		if self:getActor() then
 			self:classify("hud")
 		end
-		
+
 		if self.body then
 			self:restorePhysicsType()
-			
+
 			local physics = self.map.physics
-			
+
 			self.old_angle_speed = physics:setEntityAngleSpeed(self.body, self.old_angle_speed)
 			self.old_angle_speed = nil
-			
+
 			self:setSpeedXY(self.old_dx, self.old_dy)
-			
+
 			self.old_dx, self.old_dy = nil
 		end
 	end
@@ -707,7 +707,7 @@
 
 function Object:getPower()
 	local def = self.def
-	
+
 	if def.power then
 		return def.power
 	elseif def.getPower then
@@ -720,7 +720,7 @@
 	local endSpeedMod = self:getTerminalSpeedDamageModifier(speed)
 	local max_speedMod = math.max(speedMod, endSpeedMod)
 	local powerMod = self:getPowerDamageModifier(power or 1)
-	
+
 	return max_speedMod * powerMod
 end
 
@@ -730,36 +730,36 @@
 	elseif self.def.frictionFactor then
 		return self.def.frictionFactor
 	end
-	
+
 	return 0
 end
 
 function Object:calculateEndSpeed(startSpeed)
 	local speed = startSpeed
 	local steps = math_ceil(self.def.lifeTime / APP.stepTime)
-	
+
 	for i = 0, steps do
 		local any = false
 		local prg = i / steps
 		local acc = self:getLifeProgressAcceleration(prg)
-		
+
 		if acc ~= 0 then
 			speed = speed + self:getLifeProgressAcceleration(prg) * APP.stepTime
 			any = true
 		end
-		
+
 		local frict = self:getFrictionFactor()
-		
+
 		if frict ~= 0 then
 			speed = math_approach(speed, 0, speed * APP.stepTime * self:getFrictionFactor())
 			any = true
 		end
-		
+
 		if not any then
 			break
 		end
 	end
-	
+
 	return speed
 end
 
@@ -767,13 +767,13 @@
 	if self.def.getLifeProgressAcceleration then
 		return self.def.getLifeProgressAcceleration(self, lifeProgress) or 0
 	end
-	
+
 	return 0
 end
 
 function Object:getTerminalSpeedDamageModifier(startSpeed)
 	local endSpeed = self:calculateEndSpeed(startSpeed)
-	
+
 	return self:getSpeedDamageModifier(endSpeed)
 end
 
@@ -799,11 +799,11 @@
 function Object:emitProximityFeedback(target)
 	self:emitSound("proximity", 1, 1)
 	self:emitFx("jetSmoke")
-	
+
 	if target then
 		local prox_fx = self:emitFx("proximityRay")
 		local owner = self:getOwner()
-		
+
 		prox_fx:applyColor(owner and owner:getIdentityColor() or COLORS.red)
 		prox_fx:setEnd(target.x, target.y)
 	end
@@ -812,10 +812,10 @@
 function Object:emitFollowFeedback(target)
 	self:emitSound("proximityFriend", 1, 1)
 	self:emitFx("jetSmoke")
-	
+
 	if target then
 		local prox_fx = self:emitFx("followRay")
-		
+
 		prox_fx:applyFadedColor(target:getIdentityColor() or COLORS.hack, COLORS.white, 0.5)
 		prox_fx:setEnd(target.x, target.y)
 	end
@@ -828,7 +828,7 @@
 function Object:emitAnomaly(scale)
 	if self.map then
 		local obj = self:emitObject("anomalyMarker")
-		
+
 		if obj then
 			obj:setPower(scale)
 			obj:setTeam(self.team)
@@ -839,7 +839,7 @@
 function Object:setGravity(g)
 	self.gravity = g
 	self.gravityCache = nil
-	
+
 	if g and not self:is("gravity") then
 		self:classify("gravity")
 	end
@@ -853,11 +853,11 @@
 	local factor = self.pingTimeFactor / resolution
 	local pixel_dx = dx * factor
 	local pixel_dy = dy * factor
-	
+
 	if gs then
 		local pixel_gravity = gs * factor
 		local gravY = 0.5 * pixel_gravity * duration * duration
-		
+
 		return self.x + pixel_dx * duration, self.y + pixel_dy * duration + gravY
 	else
 		return self.x + pixel_dx * duration, self.y + pixel_dy * duration, 0
@@ -884,10 +884,10 @@
 	local x = self.x
 	local y = self.y
 	local focus = self.visualFocus
-	
+
 	if focus then
 		local s = areaScale or 1
-		
+
 		return x + focus.l * s, x + focus.r * s, y + focus.t * s, y + focus.b * s, self.map
 	else
 		return x - 64, x + 64, y - 64, y + 64, self.map
@@ -896,12 +896,12 @@
 
 function Object:setVisualFocus(scale, steadyY)
 	local focus = self.visualFocus
-	
+
 	if not focus then
 		focus = Focus:new()
 		self.visualFocus = focus
 	end
-	
+
 	focus:setDefaultBounds(-64, 64, -64, 64)
 	focus:setDefaultCore(128, 128)
 	focus:setSpeedFocusFactor(1, 1)
@@ -913,7 +913,7 @@
 
 function Object:updateFocus(time)
 	local focus = self.visualFocus
-	
+
 	focus:updateAbsoluteY(self.y)
 	focus:adjustToSpeed(self.dx, self.dy)
 	focus:update(time)
@@ -927,13 +927,13 @@
 	if self.mc and self.mc[id] then
 		return true
 	end
-	
+
 	return false
 end
 
 function Object:updateFeedback(time)
 	local itemRef = self.itemRef
-	
+
 	if itemRef and itemRef:updateFeedback(time) then
 		self:declassify("updateFeedback")
 	end
@@ -941,7 +941,7 @@
 
 function Object:setItemFeedback(v)
 	local itemRef = self.itemRef
-	
+
 	if itemRef then
 		itemRef:setFeedback(v)
 		self:classify("updateFeedback")
@@ -952,9 +952,9 @@
 	self.fade = self.fade or fade_start
 	self.fadeDelay = f
 	self.fadeDuration = dur or 0.5
-	
+
 	self:classify("fading")
-	
+
 	self.blinkDelay = 0
 	self.blink = 0
 end
@@ -962,7 +962,7 @@
 function Object:updateFading(time)
 	if self.fadeDelay then
 		self.fadeDelay = self.fadeDelay - time
-		
+
 		if self.fadeDelay <= 0 then
 			self.fadeDelay = nil
 			self.fading = true
@@ -970,15 +970,15 @@
 		end
 	elseif self.fading then
 		self.fade = self.fade - time / self.fadeDuration
-		
+
 		if self.fade <= 0 then
 			self.fade = 0
-			
+
 			self:remove()
 		end
 	elseif self.fade < 1 then
 		self.fade = math_min(1, self.fade + time / self.fadeDuration)
-		
+
 		if self.fade >= 1 then
 			self:declassify("fading")
 		end
@@ -988,23 +988,23 @@
 function Object:setRemovable(delay)
 	if not self._removable then
 		self._removable = true
-		
+
 		self:classify("pushable")
 		self:classify("removable")
-		
+
 		self.owner = nil
 		self.ignore = nil
 		self.fadeStart = self.map.time
 		self.fadeDelay = delay or 5
 		self.fade = 1
-		
+
 		self:declassify("warning")
 	end
 end
 
 function Object:declassify(classification)
 	local mc = self.mc
-	
+
 	if mc and mc[classification] then
 		self.map:declassify(self, classification)
 	end
@@ -1027,48 +1027,48 @@
 function Object:getReference(type)
 	if not object_references[type] then
 		local object = instance(self)
-		
+
 		object:initPrimary(type)
-		
+
 		if object.def.itemRefIndex then
 			object.itemRef = Item:new(object.def.itemRefIndex)
 		end
-		
+
 		object:initRuntime()
-		
+
 		object_references[type] = object
 	end
-	
+
 	return object_references[type]
 end
 
 function Object:new(type, x, y, map)
 	local object = instance(self, x, y, map)
-	
+
 	object:initPrimary(type)
-	
+
 	if object.def.itemRefIndex then
 		object.itemRef = Item:new(object.def.itemRefIndex)
 	end
-	
+
 	object:init()
-	
+
 	return object
 end
 
 function Object:newFromType(type)
 	local object = instance(self)
-	
+
 	object:initPrimary(type)
-	
+
 	return object
 end
 
 function Object:newPremade(pre, type, x, y)
 	local object = premade(self, pre, x, y)
-	
+
 	object:initPrimary(type)
-	
+
 	return object
 end
 
@@ -1093,12 +1093,12 @@
 		self.itemRef:repair(amt, self)
 	elseif not self.repaired then
 		self.repairProgress = (self.repairProgress or 0) + amt
-		
+
 		if self.repairProgress >= 1 then
 			self:emitSound("repaired", 1, 1)
 			self:flashWhite(1)
 			self:emitPpFx("repairFlashSmall")
-			
+
 			self.repaired = true
 		end
 	end
@@ -1110,10 +1110,10 @@
 
 function Object:setIsHealing(v)
 	self.healingTimer = 3
-	
+
 	if self.healing ~= v then
 		self.healing = v
-		
+
 		if v then
 			self:classify("beingHealed")
 		else
@@ -1124,7 +1124,7 @@
 
 function Object:updateIsBeingHealed(time)
 	self.healingTimer = self.healingTimer - time
-	
+
 	if self.healingTimer <= 0 then
 		self:setIsHealing(false)
 	end
@@ -1132,11 +1132,11 @@
 
 function Object:isHealableBy(healer)
 	local actor = self:getActor()
-	
+
 	if actor and not healer:isThreatened(actor) then
 		return self:needsRevive()
 	end
-	
+
 	return false
 end
 
@@ -1148,51 +1148,51 @@
 	local was = self.reviveProgress or 0
 	local total_cost = (self.def.revive_cost or 1) * (self.revive_cost or 1)
 	local reviveProgress = math.min(1, was + amt / total_cost)
-	
+
 	self.reviveProgress = reviveProgress
-	
+
 	if (self.reviveProgressFeedback or 0) < reviveProgress - 0.05 then
 		local fx = self:emitPpFxAt("reviveText", self.x, self.y - 25)
-		
+
 		fx.text = string.getPercent(reviveProgress)
-		
+
 		fx:setSpeed(-math.pi * 0.5, 150)
-		
+
 		local actor = self:getActor()
 		local color = actor and actor:getIdentityColor() or COLORS.white
-		
+
 		fx:applyColor(color)
 		self:flashWhite(reviveProgress)
-		
+
 		self.reviveProgressFeedback = reviveProgress
 	end
-	
+
 	if reviveProgress >= 1 then
 		if was < 1 then
 			self:emitSound("repaired", 1, 1, 200)
 			self:emitPpFx("repairFlashSmall")
 		end
-		
+
 		self:performRevive(reviver)
 	end
 end
 
 function Object:performRevive(reviver)
 	local actor = self:getActor()
-	
+
 	if actor then
 		actor:onBeingTakenOver()
 		actor:respawnAt(self, nil, self.def.revive_duration)
-		
+
 		if reviver then
 			local resp = reviver:getResponsibleActor()
-			
+
 			if resp then
 				resp:addStat("revives", 1)
 				resp:addStat("support", 1)
 			end
 		end
-		
+
 		self:setActor(nil)
 		self:remove()
 	end
@@ -1204,10 +1204,10 @@
 
 function Object:newDetachedRigDebris(x, y, map, rigType, compositeType, actor, rootNode)
 	local object = instance(self, x, y, map)
-	
+
 	object:initPrimary("rigDebris")
 	object:init(rigType, compositeType, actor, rootNode)
-	
+
 	return object
 end
 
@@ -1238,10 +1238,10 @@
 		_physics = _physics
 	}
 	local object = premade(self, obj, x, y, map)
-	
+
 	object:setRemovable()
 	object:setGray()
-	
+
 	return object
 end
 
@@ -1269,9 +1269,9 @@
 		itemRef = itemRef
 	}
 	local object = premade(self, obj, x, y, map)
-	
+
 	object:onInit()
-	
+
 	return object
 end
 
@@ -1281,23 +1281,23 @@
 	else
 		self:declassify("hud")
 	end
-	
+
 	if self.itemRef then
 		local ret = self.itemRef:setActor(actor)
-		
+
 		self:triggerHooks("changedActor")
-		
+
 		return ret
 	elseif not actor or not actor._remove or not actor:isBeaten() then
 		if self.actor then
 			self.actor:setPosition(self.x, self.y)
 			self.actor:materialize(self)
 		end
-		
+
 		self.actor = actor
-		
+
 		self:triggerHooks("changedActor")
-		
+
 		return true
 	end
 end
@@ -1320,7 +1320,7 @@
 
 function Object:getBullet()
 	local def = self.def
-	
+
 	if def.bullet then
 		return def.bullet
 	elseif def.getBullet then
@@ -1330,7 +1330,7 @@
 
 function Object:getBullets()
 	local def = self.def
-	
+
 	if def.bullets then
 		return def.bullets
 	elseif def.getBullets then
@@ -1356,110 +1356,110 @@
 
 function Object:newItemDebris(x, y, map, itemType, flip, angle)
 	local object = instance(self, x, y, map)
-	
+
 	object:initPrimary("debris")
-	
+
 	local spr, usedRegular = Item.getDebrisSprite(itemType)
-	
+
 	object:init(spr)
 	object:setFlipped(flip)
-	
+
 	return object
 end
 
 function Object:newFxDebris(x, y, map, fxType, variation, firstPiece)
 	local object = instance(self, x, y, map)
-	
+
 	object:initPrimary("debris")
-	
+
 	local filter
-	
+
 	if firstPiece and firstPiece.body then
 		filter = -firstPiece.body
 	end
-	
+
 	sprites.requireDefsKey(map, FX, fxType)
-	
+
 	local sprite = Fx.getDebrisSprite(fxType, variation)
-	
+
 	object:init(sprite, filter)
-	
+
 	return object
 end
 
 function Object:newTileDebris(x, y, map, scale, angle, flip, tileId)
 	local object = instance(self, x, y, map)
-	
+
 	object:initPrimary("tileDebris")
-	
+
 	object.scale = scale
-	
+
 	object:setFlipped(flip)
 	object:init(tileId)
-	
+
 	return object
 end
 
 function Object:newDebris(x, y, map, sprite, filterGroup)
 	local object = instance(self, x, y, map)
-	
+
 	object:initPrimary("debris")
 	object:init(sprite, filterGroup)
-	
+
 	return object
 end
 
 function Object:newCord(type, x, y, map)
 	local object = instance(self, x, y, map)
-	
+
 	object:initPrimary(type)
 	object:init()
-	
+
 	return object
 end
 
 function Object:newVariableCord(x, y, map, length, variation)
 	local object = instance(self, x, y, map)
-	
+
 	object:initPrimary("cordB")
 	object:init(length, variation)
-	
+
 	return object
 end
 
 function Object:newVariableSurface(x, y, map, length)
 	local object = instance(self, x, y, map)
-	
+
 	object:initPrimary("camouflage")
 	object:init(length)
-	
+
 	return object
 end
 
 function Object:newSpark(x, y, map, fxIndex)
 	local object = instance(self, x, y, map)
-	
+
 	object:initPrimary("miniSpark")
 	object:init(fxIndex)
-	
+
 	return object
 end
 
 function Object:newBubble(x, y, map, scale)
 	local object = instance(self, x, y, map)
-	
+
 	object:initPrimary("bubble")
 	object:init(scale)
-	
+
 	return object
 end
 
 function Object:newPiston(x, y, map, speed)
 	local object = instance(self, x, y, map)
-	
+
 	object:initPrimary("piston")
 	object:init(speed)
-	
+
 	return object
 end
 
@@ -1471,19 +1471,19 @@
 
 function Object:init(...)
 	local def = self.def
-	
+
 	if def.initMethod then
 		def.initMethod(self, ...)
 	end
-	
+
 	if not self.lifeTime then
 		local lifeTime = def.lifeTime
-		
+
 		if lifeTime then
 			self:setLifeTime(lifeTime)
 		end
 	end
-	
+
 	self:onInit()
 end
 
@@ -1497,13 +1497,13 @@
 	self.sleepTimer = 0
 	self.fatigue = 0
 	self.allowPhysicsManipulation = true
-	
+
 	for key, def in pairs(self.valueStates) do
 		self[key] = def.check(self)
 	end
-	
+
 	local runtime_method = self.def.initRuntimeMethod
-	
+
 	if runtime_method then
 		runtime_method(self)
 	end
@@ -1511,7 +1511,7 @@
 
 function Object:getGlowColor(r, g, b)
 	local invG = 1 - self.glowTimer
-	
+
 	return r * invG + 255 * self.glowTimer, g * invG + 255 * self.glowTimer, b * invG + 255 * self.glowTimer
 end
 
@@ -1527,11 +1527,11 @@
 	if self:is("awake") then
 		self:declassify("awake")
 	end
-	
+
 	if self.def.awakeMethod and self:is("updateAwake") then
 		self:declassify("updateAwake")
 	end
-	
+
 	if self:is("gravity") then
 		self:declassify("gravity")
 	end
@@ -1539,11 +1539,11 @@
 
 function Object:onAwake()
 	self:classify("awake")
-	
+
 	if self.def.awakeMethod then
 		self:classify("updateAwake")
 	end
-	
+
 	if self:getGravity() then
 		self:classify("gravity")
 	end
@@ -1564,7 +1564,7 @@
 function Object:onWake()
 	self:onAwake()
 	self:declassify("sleeping")
-	
+
 	self.motionless = 0
 	self.fatigue = 0
 	self.allowPhysicsManipulation = true
@@ -1574,7 +1574,7 @@
 	if self.sleeping then
 		self.map.physics:wakeUpEntity(self.body)
 	end
-	
+
 	self:onAwake()
 	self:declassify("sleeping")
 end
@@ -1585,7 +1585,7 @@
 
 function Object:returnToOrigin()
 	local origin = self.itemRef.origin
-	
+
 	if origin then
 		Behaviours.action(origin, "tile", "deliver", self)
 	end
@@ -1617,15 +1617,15 @@
 
 function Object:needsRevive()
 	local actor = self:getActor()
-	
+
 	if actor and actor:canRespawn() then
 		local item = self.itemRef
-		
+
 		if item and item.revivable then
 			return self:getRepairProgress() < 1
 		end
 	end
-	
+
 	return false
 end
 
@@ -1633,11 +1633,11 @@
 	if self.attached then
 		return false
 	end
-	
+
 	if self.def.fixedRotation then
 		return false
 	end
-	
+
 	return true
 end
 
@@ -1655,12 +1655,12 @@
 
 function Object:triggerHooks(hook)
 	local hooks = Object.valueHooks[hook]
-	
+
 	if hooks then
 		for key, def in pairs(hooks) do
 			local currentValue = self[key]
 			local nextValue = def.check(self)
-			
+
 			self[key] = nextValue
 		end
 	end
@@ -1684,19 +1684,19 @@
 	if self.itemRef then
 		return self.itemRef.active
 	end
-	
+
 	return false
 end
 
 function Object:getTimeActivated()
 	local ref = self.itemRef
-	
+
 	if ref then
 		local armedDur = ref.def.armDuration or 0
-		
+
 		return self.time - armedDur
 	end
-	
+
 	return self.time
 end
 
@@ -1704,7 +1704,7 @@
 	if self.itemRef then
 		return self.itemRef.armed
 	end
-	
+
 	return false
 end
 
@@ -1712,7 +1712,7 @@
 	if self.itemRef then
 		self.itemRef:arm(self)
 	end
-	
+
 	if false then
 	end
 end
@@ -1721,7 +1721,7 @@
 	if self.itemRef then
 		self.itemRef:disarm(self, disarmer)
 	end
-	
+
 	if false then
 	end
 end
@@ -1736,20 +1736,20 @@
 
 function Object:setAttached(target)
 	self:checkPrediction()
-	
+
 	local oldAttached = self.attached
-	
+
 	if self.attached then
 		self:removePhysicsConnectionTo(oldAttached)
-		
+
 		self.attached = nil
-		
+
 		self:recreatePhysics()
 	end
-	
+
 	if target then
 		self.attached = target
-		
+
 		helpers.createAttachedConnection(self, target)
 		target:addAttachmentFrom(self)
 		self:declassify("pushable")
@@ -1762,26 +1762,26 @@
 
 function Object:attackReflect(x, y, angle, factor, src)
 	self:checkPrediction(x, y)
-	
+
 	self.threatFactor = nil
-	
+
 	self:resetPingCompensation()
 	self:emitSoundAt("helmetHit", x, y, math_min(0.7 * factor), 0.9 + 0.3 * factor)
 	self:emitFxAt("bulletHitFlash", x, y)
 	self:bounceWithVector(angle + math_pi, factor)
 	self:setAngle(math_angleBetweenPoints(0, 0, self.dx, self.dy))
-	
+
 	if src then
 		self:setIgnore(src)
 		self:affect(src)
 	end
-	
+
 	if self:isDeflectable() then
 		self:setTime(0)
 	end
-	
+
 	self:setPickupTimer(0.3)
-	
+
 	self.targetAngle = nil
 end
 
@@ -1789,46 +1789,46 @@
 	if self:isDeflectable() then
 		self.deflects = (self.deflects or 0) + 1
 		self.targetAngle = nil
-		
+
 		self:resetPingCompensation()
-		
+
 		local x = impact.x or impact.owner.x
 		local x, y = x, impact.y or impact.owner.y
-		
+
 		if self.deflects < 6 then
 			local angle = impact.angle or self:getSpeedAngle()
 			local tf = impact.target:getTimeRelation(self)
 			local bounceFactor = 0.75 * (factor or 1) * (0.5 + 0.5 * (attack.deflection or 1 - (attack.penetration or 0))) * tf
 			local target = impact.target
-			
+
 			self:bounceWithVector(angle, bounceFactor)
-			
+
 			local new_angle = math_angleBetweenPoints(0, 0, self.dx, self.dy)
-			
+
 			self:setAngle(new_angle)
 			self:doDeflect(x, y, new_angle, math_min(500, self:getSpeed()), target)
 		else
 			self:overDeflected()
 			self:performReaction(impact)
 		end
-		
+
 		return true
 	end
-	
+
 	return false
 end
 
 function Object:doDeflect(x, y, angle, speed, target)
 	self:checkPrediction(x, y)
-	
+
 	self.threatFactor = nil
-	
+
 	local fx_scale = self.def.fxScale
-	
+
 	self:emitSoundAt("helmetHit", x, y, 0.7 * fx_scale, 1.3)
-	
+
 	local fx = self:emitFxAt("bulletHitFlash", x, y)
-	
+
 	fx:setMasterScale(fx_scale)
 	self:setAngle(angle)
 	self:setSpeed(angle, speed)
@@ -1842,65 +1842,65 @@
 	if self.def.reflectable and impact.target ~= self.ignore then
 		self.deflects = (self.deflects or 0) + 1
 		self.targetAngle = nil
-		
+
 		self:resetPingCompensation()
-		
+
 		local x = impact.x or impact.owner.x or self.x
 		local x, y = x, impact.y or impact.owner.y or self.y
 		local angle = impact.angle or self:getSpeedAngle()
-		
+
 		if self.deflects < 6 then
 			local target = impact.target
 			local tf = target:getTimeRelation(self)
 			local v
 			local factor = factor
-			
+
 			if strong then
 				v = factor * 1.1 * tf
 			else
 				v = factor * tf
 			end
-			
+
 			self:doReflect(x, y, angle, v, strong, target)
 		else
 			self:overDeflected()
 			self:performReaction(impact)
 		end
-		
+
 		return true
 	end
-	
+
 	return false
 end
 
 function Object:doReflect(x, y, angle, v, strong, target)
 	self:checkPrediction(x, y)
-	
+
 	self.threatFactor = nil
-	
+
 	if strong then
 		local fx_scale = self.def.fxScale
-		
+
 		self:emitSoundAt("reflect", x, y, 1 * fx_scale, 1)
-		
+
 		local flash = self:emitFxAt("bulletReflectFlash", x, y)
-		
+
 		flash:setMasterScale(fx_scale)
-		
+
 		if fx_scale > math_random() then
 			local fx = self:emitSparkAt("reflectSpark", x, y)
-			
+
 			fx:setSpeed(angle + math_pi + math_randomGaussian() * math_pi * 0.25, math_random() * 40 + 20)
 		end
 	end
-	
+
 	self:affect(target)
 	self:setIgnore(target)
-	
+
 	if self.body then
 		if strong then
 			local new_angle = self:getStartSpeedAngle() + math_pi
-			
+
 			self:setAngle(new_angle)
 			self:setSpeed(new_angle, self:getStartSpeed() * v)
 			self:setAngleSpeed(0)
@@ -1909,7 +1909,7 @@
 			self:setAngle(math_angleBetweenPoints(0, 0, self.dx, self.dy))
 		end
 	end
-	
+
 	self:setTime(0)
 end
 
@@ -1922,14 +1922,14 @@
 	if self.body then
 		self.map:removeEntity(self.body)
 	end
-	
+
 	self.owner = nil
 	self.reference = nil
 end
 
 function Object:setId(id)
 	self.id = id
-	
+
 	if self.itemRef then
 		self.itemRef:setId(id)
 	end
@@ -1964,16 +1964,16 @@
 
 function Object:getImpactVolume(impact, multiplier)
 	local vol = 0
-	
+
 	if self.body then
 		local mass = self:getMass()
-		
+
 		if mass > 0 then
 			impact.impulse = impact.impulse or 1
 			vol = math_min(1, math_max(0, impact.impulse / (mass * 50) * (multiplier or 1)))
 		end
 	end
-	
+
 	return vol
 end
 
@@ -1982,25 +1982,25 @@
 	local sx, sy = sx, self.soundY or 0
 	local soundStamp = self.soundStamp or 0
 	local map_time = self.map and self.map.time or 0
-	
+
 	if soundStamp > map_time - 0.1 then
 		return false
 	end
-	
+
 	if math_abs(sx - self.x) > soundPositionDeltaLimit or math_abs(sy - self.y) > soundPositionDeltaLimit then
 		local target = impact.target
-		
+
 		if target then
 			local material = target.def.material or MATERIALS.default
 			local vol = self:getImpactVolume(impact, multiplier)
-			
+
 			if vol > 0.01 then
 				self:emitSound(material.sounds.hit or "hitDry", vol, 1, 300 * (rangeMultiplier or 1))
-				
+
 				self.soundX = self.x
 				self.soundY = self.y
 				self.soundStamp = map_time
-				
+
 				return true
 			end
 		end
@@ -2009,13 +2009,13 @@
 
 function Object:setPickupTimer(v)
 	self.pickupableTimer = v
-	
+
 	self:setPickupable(false)
 end
 
 function Object:setBody(body, bodyFilter)
 	self.body = body
-	
+
 	if body then
 		self.bodyFilter = bodyFilter or -body
 	else
@@ -2028,13 +2028,13 @@
 	idle = {
 		apply = function(self)
 			local def = self.def
-			
+
 			self._physics = def.idle_physics
 			self.idle = true
-			
+
 			if self.body then
 				self:refilterPhysics()
-				
+
 				if def.isTarget then
 					self:declassify("target")
 				end
@@ -2045,10 +2045,10 @@
 		apply = function(self)
 			self._physics = nil
 			self.idle = false
-			
+
 			if self.body then
 				self:refilterPhysics()
-				
+
 				if self.def.isTarget then
 					self:classify("target")
 				end
@@ -2060,19 +2060,19 @@
 			self.grayFade = 1
 			self.anyShader = true
 			self.idle = false
-			
+
 			local def = self.def
-			
+
 			self._physics = def.debris_physics
-			
+
 			if self.body then
 				self:refilterPhysics()
 				self:bringToBackground()
-				
+
 				if def.isTarget then
 					self:declassify("target")
 				end
-				
+
 				self:classify("pushable")
 			end
 		end
@@ -2080,9 +2080,9 @@
 	prediction = {
 		apply = function(self)
 			local def = self.def
-			
+
 			self._physics = def.prediction_physics
-			
+
 			if self.body then
 				self:refilterPhysics()
 			end
@@ -2097,54 +2097,54 @@
 
 function Object:forcePredictionPhysicsType()
 	self.physicsType = "prediction"
-	
+
 	local apply = OBJECT_PHYSICS_TYPES.prediction.apply
-	
+
 	apply(self)
 end
 
 function Object:forceIdlePhysicsType()
 	local apply = OBJECT_PHYSICS_TYPES.idle.apply
-	
+
 	apply(self)
 end
 
 function Object:restorePhysicsType()
 	local ptype = self.physicsType or "normal"
 	local apply = OBJECT_PHYSICS_TYPES[ptype].apply
-	
+
 	apply(self)
 end
 
 function Object:setPhysicsType(physics_type)
 	self.physicsType = physics_type
-	
+
 	local apply = OBJECT_PHYSICS_TYPES[physics_type].apply
-	
+
 	apply(self)
 end
 
 function Object:refilterPhysics()
 	if self.def.noFilter then
-		return 
+		return
 	end
-	
+
 	local physics = self.map.physics
 	local phys_def = self._physics or self.def.physics
 	local body = self.body
 	local group = self.bodyFilter
-	
+
 	for shape_index, shape in ipairs(phys_def) do
 		assert(shape_index)
 		assert(shape.category)
 		assert(shape.mask)
-		
+
 		local ret = physics:setEntityShapeIndexFilters(body, shape_index, shape.category, shape.mask, group)
-		
+
 		if not ret then
 			print("ERROR", self.type, body, shape_index, shape.category, shape.mask, group)
 		end
-		
+
 		if false then
 		end
 	end
@@ -2152,20 +2152,20 @@
 
 function Object:recreatePhysics(bodyFilter)
 	if self.def.noFilter then
-		return 
+		return
 	end
-	
+
 	local oldAngleSpeed, oldDx, oldDy = 0
-	
+
 	if self.body then
 		oldAngleSpeed = self.map.physics:getEntityAngleSpeed(self.body)
 		oldDx, oldDy = self.map.physics:getEntitySpeed(self.body)
-		
+
 		self.map:removeEntity(self.body)
 	end
-	
+
 	self.map:addPhysicsForObject(self, bodyFilter)
-	
+
 	if self.allowPhysicsManipulation then
 		self.map.physics:setEntityAngleSpeed(self.body, oldAngleSpeed)
 		self.map.physics:setEntitySpeed(self.body, oldDx, oldDy)
@@ -2196,13 +2196,13 @@
 
 function Object:onPickedUp(by)
 	Behaviours.action(self, "onUsed", "perform", by)
-	
+
 	local item = self.itemRef
-	
+
 	if item then
 		if not item:onPickedUpObject(by, self) then
 			self._picked_up = true
-			
+
 			self:remove()
 		end
 	else
@@ -2216,7 +2216,7 @@
 
 function Object:onTeleportedTo(what)
 	local def = self.def
-	
+
 	if def.onTeleportedTo then
 		def.onTeleportedTo(self, what)
 	end
@@ -2224,22 +2224,22 @@
 
 function Object:expire()
 	self:checkPrediction()
-	
+
 	local itemRef = self.itemRef
-	
+
 	if itemRef then
 		local def = itemRef.def
-		
+
 		if def.asObjectExpire then
 			def.asObjectExpire(itemRef, self)
 		end
-		
+
 		itemRef:deactivate(self)
 		self:disarm()
 	end
-	
+
 	local expired = self.def.onExpiredMethod
-	
+
 	if expired then
 		expired(self)
 	end
@@ -2249,7 +2249,7 @@
 	if self.prediction then
 		self.prediction.noFuel = v
 	end
-	
+
 	self.noFuel = v
 end
 
@@ -2257,22 +2257,22 @@
 	if self.prediction then
 		self.prediction.ignited = v
 	end
-	
+
 	self.ignited = v
 end
 
 function Object:activate()
 	self:checkPrediction()
-	
+
 	local itemRef = self.itemRef
-	
+
 	if itemRef then
 		local def = itemRef.def
-		
+
 		if def.asObjectActivate then
 			def.asObjectActivate(itemRef, self)
 		end
-		
+
 		itemRef:activate(self)
 	end
 end
@@ -2286,7 +2286,7 @@
 	if self.ownedFx then
 		self:moveFxInstantly()
 	end
-	
+
 	self:setIgnore()
 end
 
@@ -2295,9 +2295,9 @@
 		self.map:removeObjectPhysics(self)
 		self.map:removeObjectReference(self)
 	end
-	
+
 	self.map = map
-	
+
 	self.map:addObject(self)
 end
 
@@ -2306,9 +2306,9 @@
 		self.map:removeObjectPhysics(self)
 		self.map:removeObjectReference(self)
 	end
-	
+
 	self.map = map
-	
+
 	self:setOwner(nil)
 	self:onMovedInstantly()
 	self:setPosition(x or self.x, y or self.y)
@@ -2318,7 +2318,7 @@
 
 function Object:onRespawnedAt(actor)
 	local itemRef = self.itemRef
-	
+
 	if itemRef and itemRef.def.asObjectRespawnedAt then
 		itemRef.def.asObjectRespawnedAt(itemRef, self, actor)
 	end
@@ -2337,53 +2337,53 @@
 function Object:onRemoved()
 	if not self._removed then
 		local inf = self:getInfluence()
-		
+
 		if inf then
 			inf:removeSpawned(self)
 		end
-		
+
 		if self.family then
 			self:dissolveFamily()
 		end
-		
+
 		local item = self.itemRef
-		
+
 		if item then
 			local removedItemMethod = item.def.asObjectRemoved
-			
+
 			if removedItemMethod then
 				removedItemMethod(item, self)
 			end
 		end
-		
+
 		local removedMethod = self.def.onRemovedMethod
-		
+
 		if removedMethod then
 			removedMethod(self)
 		end
-		
+
 		if self.attached then
 			self.attached:removeAttachmentFrom(self)
-			
+
 			self.attached = nil
 		end
-		
+
 		if self.generator then
 			self.generator:removeSpawned(self)
-			
+
 			self.generator = nil
 		end
-		
+
 		self.map:declassifyAll(self)
-		
+
 		self.owner = nil
 		self.ignore = nil
 		self._removed = true
-		
+
 		if item and self._picked_up then
 			self.itemRef = nil
 		end
-		
+
 		return true
 	end
 end
@@ -2392,7 +2392,7 @@
 	if self.map then
 		self.map:removeObjectPhysics(self)
 		self.map:removeObjectReference(self)
-		
+
 		self.map = nil
 	end
 end
@@ -2408,9 +2408,9 @@
 	self.owner = nil
 	self.attached = nil
 	self.last_responsible = nil
-	
+
 	local itemRef = self.itemRef
-	
+
 	if itemRef then
 		itemRef:verifyLimbo()
 	end
@@ -2418,10 +2418,10 @@
 
 function Object:remove()
 	self._remove = true
-	
+
 	if self.prediction then
 		self.prediction:remove()
-		
+
 		self.prediction = nil
 	end
 end
@@ -2438,7 +2438,7 @@
 	local attack = self:getAttack()
 	local pow = (attack and attack.overall_power or 0.5) * 0.25 + self:getMass() * 0.75
 	local hits = self:emitOmniBlast(RANGES.short + pow * 100, 20 + pow * 40)
-	
+
 	for index, hit in pairs(hits) do
 		if hit._category == "actor" then
 			hit:setDamaged(0.1 + pow * 0.25)
@@ -2446,7 +2446,7 @@
 			hit:gripless(0.5 + 0.5 * math.min(1, pow))
 		end
 	end
-	
+
 	self:emitPpFx("bulletReflectFlash")
 	self:emitSound("deflectDischarge", 1, 1)
 end
@@ -2456,7 +2456,7 @@
 		if self.def.visualExpireMethod then
 			self:performVisualExpire()
 		end
-		
+
 		self:remove()
 	end
 end
@@ -2466,7 +2466,7 @@
 		if self.def.visualHitMethod then
 			self:performVisualHit()
 		end
-		
+
 		if self.def.reactionMethod then
 			self.def.reactionMethod(self, impact)
 		else
@@ -2482,10 +2482,10 @@
 			local y = impact and impact.y or self.y
 			local angle = impact and impact.angle or self.angle
 			local target = impact and impact.target or nil
-			
+
 			self:performVisualReaction(x, y, angle, target)
 		end
-		
+
 		if self.def.reactionMethod then
 			self.def.reactionMethod(self, impact)
 		else
@@ -2496,7 +2496,7 @@
 
 function Object:checkActual()
 	local actual = self.actual
-	
+
 	if actual then
 		actual:checkPrediction(self.x, self.y)
 	end
@@ -2504,25 +2504,25 @@
 
 function Object:checkPrediction(x, y)
 	local prediction = self.prediction
-	
+
 	if prediction then
 		local track = prediction:is("minimap")
-		
+
 		prediction:remove()
-		
+
 		self.prediction = nil
-		
+
 		self:setPosition(x or prediction.x, y or prediction.y)
 		self:setAngle(prediction.angle)
 		self.map:addObject(self)
 		self:replacePrediction(prediction)
-		
+
 		self.correction_fade = 0
-		
+
 		if track then
 			self:classify("minimap")
 		end
-		
+
 		return true
 	else
 		self:removeHidden()
@@ -2539,7 +2539,7 @@
 
 function Object:superBounce(impact_angle, x, y)
 	self:checkPrediction()
-	
+
 	if self.def.superBounceMethod then
 		self.def.superBounceMethod(self, impact_angle, x, y)
 	end
@@ -2549,33 +2549,33 @@
 	for i = -1, 1 do
 		local test_angle = angle + i * math.pi * 0.001
 		local hit, target, x, y, hitAngle = self:getLosTowards(test_angle, maxRange, LOS.ground)
-		
+
 		if not target then
 			return false
 		end
-		
+
 		if not target:isDeploySurface() then
 			return false
 		end
-		
+
 		if math.abs(math.angleDifference(hitAngle + math.pi, angle)) > math.pi * 0.01 then
 			return false
 		end
 	end
-	
+
 	return true
 end
 
 function Object:deployAt(angle, x, y, target)
 	self:checkPrediction(x, y)
-	
+
 	local item = self.itemRef
-	
+
 	if item then
 		self:setPosition(x, y)
-		
+
 		local deployed = item:deploy(self, angle, x, y, target)
-		
+
 		if deployed then
 			self:setDeployed(deployed)
 		end
@@ -2606,7 +2606,7 @@
 
 function Object:performVisualReaction(x, y, angle, target)
 	local visual = self.prediction or self
-	
+
 	self.def.visualReactionMethod(visual, x, y, angle, target)
 end
 
@@ -2621,11 +2621,11 @@
 function Object:getAbsoluteNodeXY(node)
 	if self.def.nodes then
 		local node = node or "main"
-		
+
 		if not self.def.nodes[node] then
 			node = "main"
 		end
-		
+
 		if self.def.nodes[node] then
 			local n = self.def.nodes[node]
 			local faceflipfactor = facingToFlipFactor(not self.flipped)
@@ -2637,7 +2637,7 @@
 			local scaledFlipFactor = ox_scale * faceflipfactor
 			local node_x = self.x + math_cos(angle) * scaledFlipFactor + math_cos(down_angle) * oy_scale
 			local node_y = self.y + math_sin(angle) * scaledFlipFactor + math_sin(down_angle) * oy_scale
-			
+
 			return node_x, node_y
 		else
 			return self.x, self.y
@@ -2649,21 +2649,21 @@
 
 function Object:getHitCauseItem()
 	local item = self.responsibleItem
-	
+
 	if item then
 		return item
 	end
-	
+
 	return self.itemRef
 end
 
 function Object:getResponsibleItem()
 	local item = self.responsibleItem
-	
+
 	if item then
 		return item
 	end
-	
+
 	return self.itemRef
 end
 
@@ -2686,36 +2686,36 @@
 function Object:setGlow(amt, dur)
 	self.glowTimer = amt
 	self.glowDuration = dur or 1
-	
+
 	self:classify("updateGlow")
 end
 
 function Object:setSpark(amt, sparkSmoke)
 	self.sparkTimer = amt
 	self.endSparkSmokeTimer = sparkSmoke
-	
+
 	self:classify("updateSpark")
 end
 
 function Object:setBurn(amt)
 	self.burnTimer = amt
-	
+
 	self:classify("updateBurn")
 end
 
 function Object:setSparkShoot(amt)
 	self.sparkShootTimer = amt
-	
+
 	self:classify("updateSparkShoot")
 end
 
 function Object:changedHealth(new_hp, feedback)
 	self.health = new_hp
-	
+
 	self:flashHit(feedback)
-	
+
 	local def = self.def
-	
+
 	if def.healthFeedbackMethod then
 		def.healthFeedbackMethod(self, feedback)
 	end
@@ -2725,7 +2725,7 @@
 	self.hitTimer = amt or 1
 	self.fullShader = true
 	self.anyShader = true
-	
+
 	self:classify("updateHit")
 end
 
@@ -2733,7 +2733,7 @@
 	self.highlighted = amt or 1
 	self.fullShader = true
 	self.anyShader = true
-	
+
 	self:classify("updateHighlight")
 end
 
@@ -2744,16 +2744,16 @@
 function Object:setHeat(set, delay, heatProtection)
 	local was = self.heat
 	local heat = set or 0
-	
+
 	self.heat = heat
 	self.heatDelay = math.max(self.heatDelay or 0, delay or 0)
 	self.heatProtection = heatProtection or 0
-	
+
 	if heat ~= 0 then
 		if not was or was == 0 then
 			self:classify("updateHeat")
 		end
-		
+
 		self.fullShader = true
 		self.anyShader = true
 	end
@@ -2765,10 +2765,6 @@
 	self.anyShader = true
 end
 
-function Object:getColdResistance()
-	return 0.5
-end
-
 function Object:getHeatResistance()
 	return self.def.heatResistance or 0.5
 end
@@ -2788,9 +2784,9 @@
 function Object:addHeatEffect(add)
 	if self.def.hasHeat and not self.heatProtection then
 		add = add / self:getHeatResistance()
-		
+
 		self:setHeat((self.heat or 0) + add, math_max(add * add, 0.1))
-		
+
 		if self.heat >= 1 then
 			self:destroy()
 		end
@@ -2800,9 +2796,9 @@
 function Object:addColdEffect(add)
 	if self.def.hasCold and not self.heatProtection then
 		add = add / self:getColdResistance()
-		
+
 		self:setHeat((self.heat or 0) - add, math_max(add * add, 0.1))
-		
+
 		if self.heat <= -1 then
 			self:destroy()
 		end
@@ -2813,7 +2809,7 @@
 	local chrono = self.chrono or 1
 	local half_power_point = amount
 	local add = amount * 3 / (1 + chrono / half_power_point)
-	
+
 	self:setChrono(chrono + amount)
 end
 
@@ -2823,13 +2819,13 @@
 
 function Object:setChrono(v)
 	self.chrono = v
-	
+
 	if v > 1 then
 		self:flashWhite(math_min(0.5, v / 10))
-		
+
 		if not self:is("updateChrono") then
 			self:classify("updateChrono")
-			
+
 			self.chronoFxDelay = 0
 			self.chronoFx = {}
 		end
@@ -2840,22 +2836,22 @@
 
 function Object:updateChrono(time)
 	local chrono = self.chrono
-	
+
 	if chrono > 1 then
 		self:setMinTimeFactor(math_max(MIN_TF, 1 / chrono))
-		
+
 		local tf = math_max(MIN_TF, self.timeFactor)
 		local normal_time = time / tf
 		local factor = GLOBAL.object_chrono_restore_factor
 		local relative_dissipation = GLOBAL.object_chrono_restore_relative_factor * factor
 		local constant_dissipation = GLOBAL.object_chrono_restore_constant_factor * factor
 		local exp_chrono = chrono - 1
-		
+
 		chrono = chrono - normal_time * exp_chrono * relative_dissipation - normal_time * constant_dissipation
 		self.chrono = math_max(1, chrono)
-		
+
 		local fx_table = self.chronoFx
-		
+
 		if self.chronoFxDelay > 0 then
 			self.chronoFxDelay = self.chronoFxDelay - normal_time
 		else
@@ -2864,34 +2860,34 @@
 			local kill_time = 2 / (1 + chrono * 0.75)
 			local life_time = 2.2
 			local actual_lifetime = life_time - kill_time
-			
+
 			if max >= #fx_table then
 				local ang = math_randomAngle()
 				local dist = self:getFuzzySize() * math_random() * 3
 				local fx = self:emitPpFxAt("chronoedSpark", self.x + math_cos(ang) * dist, self.y + math_sin(ang) * dist)
-				
+
 				fx.timeFactor = tf / chrono
-				
+
 				fx:setMasterScale(math.min(2, (chrono - 0.1) * 4))
-				
+
 				fx.dist = dist
 				fx.ang = ang
 				fx.seed = math.random() * 1000
-				
+
 				fx:setLifeTime(actual_lifetime)
 				fx:setMasterScale(math_min(1, chrono - 1))
 				fx:setTarget(self)
 				table.insert(fx_table, fx)
 			end
-			
+
 			self.chronoFxDelay = (3 + math_random() * 0.5) / kill_time / 2
 		end
-		
+
 		table.removeCompletelyIf(fx_table)
 	else
 		self.chronoFx = nil
 		self.chronoFxDelay = nil
-		
+
 		self:declassify("updateChrono")
 	end
 end
@@ -2901,7 +2897,7 @@
 		if self.affectedBy ~= affector then
 			self:setAffectedBy(affector)
 		end
-		
+
 		if self.affectedAttack ~= affection then
 			self:setAffectedAttack(affection)
 		end
@@ -2910,9 +2906,9 @@
 
 function Object:setAffectedBy(affector)
 	self.affectedBy = affector
-	
+
 	local method = self.def.onAffectedByChangedMethod
-	
+
 	if method then
 		method(self, affector)
 	end
@@ -2954,14 +2950,14 @@
 
 function Object:performDestroy()
 	self.destroyed = true
-	
+
 	local ref = self.prediction or self
 	local destroyMethod = ref.def.destroyMethod
-	
+
 	if destroyMethod then
 		destroyMethod(ref, ref.itemRef)
 	end
-	
+
 	self:remove()
 end
 
@@ -2981,22 +2977,22 @@
 	if not self.health then
 		self.health = self:getStartingHealth()
 	end
-	
+
 	self.health = self.health - amt
 end
 
 function Object:emitText(txt, speed)
 	if self.map then
 		local fx = self:emitPpFx("killText")
-		
+
 		fx:setMasterColor(COLORS.green)
-		
+
 		local speed = speed or 15
-		
+
 		fx:setSpeedXY(0, -speed)
-		
+
 		fx.text = txt
-		
+
 		return fx
 	end
 end
@@ -3016,13 +3012,13 @@
 
 function Object:hitPrediction(impact, attack, factor)
 	self:checkActual()
-	
+
 	local def = self.def
-	
+
 	if not (not attack.hurtsObjects and not attack.hurtsFire) and not self:isIndestructable() and not self:isBullet() or def.hurtable_by_all then
 		local stHp = self:getHealth()
 		local feedback, damage = attacks.get_damage(self, attack, impact.damageModifier, factor or 1)
-		
+
 		return true, math_min(stHp, damage), true
 	end
 end
@@ -3031,73 +3027,73 @@
 	if self._remove then
 		return false, 0
 	end
-	
+
 	local factor = factor or 1
-	
+
 	self.target = nil
-	
+
 	if impact.owner then
 		local resp = impact.owner:getResponsibleActor()
-		
+
 		impact.owner:countHit()
-		
+
 		if resp and resp ~= self.affectedBy and self:isExplosive() and attack.type ~= "area" then
 			self.hits = (self.hits or 0) + 1
-			
+
 			local x = impact.x or self.x
 			local x, y = x, impact.y or self.y
-			
+
 			self:emitSoundAt("helmetHit", x, y, 0.6, 1.4)
 			self:emitPpFxAt("deflectHitFlash", x, y)
 		end
-		
+
 		self:affect(resp, attack.index)
 	end
-	
+
 	local def = self.def
-	
+
 	if def.hitMethod and def.hitMethod(self, impact, attack) then
 		return true, attack.overall_power
 	end
-	
+
 	if attack.any_object_damage then
 		attacks.onObject(self, attack, impact.damageModifier, factor, impact.owner, impact)
 	end
-	
+
 	if not (not attack.hurtsObjects and not attack.hurtsFire) and not self:isIndestructable() and not self:isBullet() or def.hurtable_by_all then
 		if not self.health then
 			self.health = self:getStartingHealth()
 		end
-		
+
 		local stHp = self.health
 		local feedback, damage = attacks.apply(self, attack, impact.damageModifier, factor, impact.owner, impact, "damage")
 		local has_feedback = self:hasHitFeedback()
-		
+
 		if has_feedback then
 			self:changedHealth(math.clamp(self.health, -1, OBJ_MAX_HEALTH), math.min(MAX_FEEDBACK, feedback))
 		end
-		
+
 		if self.health <= 0 then
 			self:destroy()
 		elseif has_feedback and not attack.continous then
 			local vol = math_min(1, 0.25 * damage)
-			
+
 			if vol > 0 then
 				self:emitSound("objectDamaged", math_min(1, 0.25 * damage), 0.8 + math_random() * 0.4)
 			end
 		end
-		
+
 		return true, math_min(stHp, damage), true
 	end
-	
+
 	return true, attack.overall_power, false
 end
 
 function Object:blockPickupUntilClear()
 	self.blinkTimer = 2
-	
+
 	self:setPickupable(false)
-	
+
 	self.pickupableBlockedUntilClear = true
 	self.sensor = true
 end
@@ -3105,7 +3101,7 @@
 function Object:impactLosCheck(target, maxDist, arcLimit, bodyFilter, asStaticAll, objectsToo)
 	local impact = self.losImpact or {}
 	local hit, target, x, y, angle, hitId = self:losCheck(target, maxDist, arcLimit, bodyFilter, asStaticAll, objectsToo)
-	
+
 	if hit then
 		impact.x = x
 		impact.y = y
@@ -3116,7 +3112,7 @@
 		impact.nx = math_cos(angle)
 		impact.ny = math_sin(angle)
 		impact.id = hitId
-		
+
 		return impact
 	else
 		return nil
@@ -3151,48 +3147,49 @@
 	if target and self.map ~= target.map then
 		return false, "wrong map"
 	end
-	
+
 	if maxDist ~= nil and target and math_distance2(self.x, self.y, target.x, target.y) > maxDist * maxDist then
 		return false, "wrong distance"
 	end
-	
+
 	if arcLimit ~= nil and math_abs(math_angleDifference(self.angle, math_angleBetweenPoints(self.x, self.y, target.x, target.y))) > arcLimit / 2 then
 		return false, "wrong angle"
 	end
-	
+
 	local colCat = _collisionCategory.objectSensor
 	local colMask = _collisionFilter.actorsAndStatic
 	local tx, ty
-	
+
 	if target and target._category == "tile" and target:isDebris() then
 		colMask = _collisionFilter.debrisAndStatic
 	end
-	
+
 	if asStaticAll then
 		colCat = _collisionCategory.staticSensor
 		colMask = _collisionFilter.allActivesAndDebris
 	end
-	
+
 	if objectsToo then
 		colMask = _collisionFilter.notIdleObjectsNoSensor
 	end
-	
+
 	local finalx, finaly, finalTarget, hitAngle, hitId
 	local resolution = self.map.resolution
-	
+
 	if target then
 		tx, ty = target.x, target.y
-		
+
 		if not target.body and target._category == "tile" then
 			tx, ty = target:getPerceptualPosition()
 		end
-		
+
 		if DEBUG.showDebug and DEBUG.showGraphs then
 			D.addToGraph("ray", 1)
 		end
-		
-		local result, hitx, hity, nx, ny, userData, id = self.map.physics:raycastPoints(self.x * resolution, self.y * resolution, tx * resolution, ty * resolution, false, colCat, colMask, -(self.body or 0))
-		
+
+		local result, hitx, hity, nx, ny, userData, id = self.map.physics:raycastPoints(self.x * resolution,
+			self.y * resolution, tx * resolution, ty * resolution, false, colCat, colMask, -(self.body or 0))
+
 		if result then
 			finalx = hitx / resolution
 			finaly = hity / resolution
@@ -3204,9 +3201,11 @@
 		if DEBUG.showDebug and DEBUG.showGraphs then
 			D.addToGraph("ray", 1)
 		end
-		
-		local result, hitx, hity, nx, ny, userData, id = self.map.physics:raycastPoints(self.x * resolution, self.y * resolution, (self.x + math_cos(self.angle) * (maxDist or 2000)) * resolution, (self.y + math_sin(self.angle) * (maxDist or 2000)) * resolution, true, colCat, colMask, bodyFilter)
-		
+
+		local result, hitx, hity, nx, ny, userData, id = self.map.physics:raycastPoints(self.x * resolution,
+			self.y * resolution, (self.x + math_cos(self.angle) * (maxDist or 2000)) * resolution,
+			(self.y + math_sin(self.angle) * (maxDist or 2000)) * resolution, true, colCat, colMask, bodyFilter)
+
 		if result then
 			finalx = hitx / resolution
 			finaly = hity / resolution
@@ -3215,7 +3214,7 @@
 			hitId = id
 		end
 	end
-	
+
 	if not finalTarget then
 		if target then
 			return true, target, target.x, target.y, math_angleBetweenPoints(self.x, self.y, target.x, target.y), hitId
@@ -3223,16 +3222,16 @@
 			return false, nil
 		end
 	end
-	
+
 	if finalTarget then
 		if target and finalTarget ~= target then
 			return false, nil, "invalid target, or no target"
 		end
-		
+
 		if target and finalTarget == target then
 			return true, finalTarget, finalx, finaly, hitAngle, hitId
 		end
-		
+
 		if not target then
 			return true, finalTarget, finalx, finaly, hitAngle, hitId
 		end
@@ -3241,7 +3240,7 @@
 
 function Object:isDestructible()
 	local def = self.def
-	
+
 	return def.destructible or self.health or def.hurtable_by_all
 end
 
@@ -3271,35 +3270,35 @@
 	if shaders.enabled then
 		local shader = PP_SHADERS
 		local toShader = shader.light.toShader
-		
+
 		toShader.intensity = amount * 1.5
-		
+
 		local colorMask = toShader.colorMask
-		
+
 		colorMask[1] = 1
 		colorMask[2] = 0.3
 		colorMask[3] = 0.3
-		
+
 		video.renderSpriteStateShader(shaders.getMaterial(shader.light), FX.glow.sprite, x, y, 0.05 + amount * 0.35, toShader)
 	end
 end
 
 function Object:renderHud(x, y, r, g, b)
 	local actor = self:getActor()
-	
+
 	if actor and actor.isPlayer then
 		local name = actor:getName()
-		
+
 		if name then
 			local col = actor:getIdentityColor() or COLORS.white
-			
+
 			video.renderShadowedTextSprites(name, x, y + 20, 1, "small", 64, col.r, col.g, col.b)
 		end
-		
+
 		if false then
 		end
 	end
-	
+
 	if false then
 	end
 end
@@ -3310,9 +3309,9 @@
 
 function Object:prepareShader()
 	if self.def.no_shader then
-		return 
+		return
 	end
-	
+
 	if self.fullShader then
 		local hit = self.hitTimer or 0
 		local heat = math_max(0, self.heat or 0)
@@ -3320,20 +3319,20 @@
 		local bg = self.grayFade or 0
 		local highlight = self.highlighted or 0
 		local gamma = self.gamma or 0
-		
+
 		if self.glowTimer then
 			bg = bg * (1 - self.glowTimer)
 		end
-		
+
 		if hit > 0 or heat > 0 or cold > 0 or bg > 0 or highlight > 0 or gamma > 0 then
 			local obj_shader = SHADERS.objectState
-			
+
 			if not self.shader or self.shader ~= obj_shader then
 				applyShader(self, obj_shader)
 			end
-			
+
 			local to_shader = self.shaderData.toShader
-			
+
 			to_shader.hit = hit * hit
 			to_shader.heat = heat
 			to_shader.cold = cold
@@ -3344,38 +3343,38 @@
 			if self.shader then
 				removeShader(self, SHADERS.objectState)
 			end
-			
+
 			self.anyShader = false
 			self.fullShader = false
 		end
-		
+
 		if hit <= 0 and heat <= 0 and cold <= 0 and highlight <= 0 and gamma <= 0 and bg > 0 then
 			self.fullShader = false
-			
+
 			if self.shader then
 				applyShader(self, SHADERS.objectStateSimple)
-				
+
 				self.shaderData.toShader.bg = bg
 			end
 		end
 	else
 		local bg = self.grayFade or 0
-		
+
 		if self.glowTimer then
 			bg = bg * (1 - self.glowTimer)
 		end
-		
+
 		if bg > 0 then
 			if not self.shader or self.shader ~= SHADERS.objectStateSimple then
 				applyShader(self, SHADERS.objectStateSimple)
 			end
-			
+
 			self.shaderData.toShader.bg = bg
 		else
 			if self.shader then
 				removeShader(self, SHADERS.objectStateSimple)
 			end
-			
+
 			self.anyShader = false
 		end
 	end
@@ -3386,9 +3385,9 @@
 		if self.slept then
 			self:removeSlept()
 		end
-		
+
 		local def = self.def
-		
+
 		if def.renderMethod then
 			def.renderMethod(self, x, y, r, g, b, ox, oy)
 		end
@@ -3400,49 +3399,49 @@
 		video.renderTextSprites(self.body or "NIL", x, y - 40, 1, "small", 255, 0, 255, 255, nil, 0.5)
 		video.renderTextSprites(self.bodyFilter or "NO_FILTER", x, y - 50, 1, "small", 255, 0, 255, 255, nil, 0.5)
 		video.renderTextSprites(self._filter, x, y - 60, 1, "small", 255, 0, 255, 255, nil, 0.5)
-		
+
 		if self.idle then
 			video.renderTextSprites("IDLE", x, y - 70, 1, "small", 255, 0, 255, 255, nil, 0.5)
 		end
-		
+
 		if not self.body then
 			printtable(self._physics)
 		end
-		
+
 		if self.isPickupable then
 			video.renderTextSprites("P", x - 20, y - 20, 1, "small", 255, 255, 255, 255, nil, 0.7)
 		end
-		
+
 		if self.allowPickup then
 			video.renderTextSprites("AllowP", x - 20, y - 30, 1, "small", 255, 255, 255, 255, nil, 0.7)
 		end
-		
+
 		if self.pickupable then
 			video.renderTextSprites("Pick", x - 20, y - 40, 1, "small", 255, 255, 255, 255, nil, 0.7)
 		end
-		
+
 		if self.ignore then
 			video.renderTextSprites("I", x - 20, y - 60, 1, "small", 255, 64, 64, 255, nil, 0.7)
 		end
-		
+
 		if self.owner then
 			video.renderTextSprites("O", x - 40, y - 60, 1, "small", 255, 64, 64, 255, nil, 0.7)
 		end
-		
+
 		if self.itemRef and self.itemRef.hitActive then
 			video.renderTextSprites("HIT", x - 60, y - 60, 1, "small", 255, 255, 0, 0, nil, 0.7)
 		end
-		
+
 		video.renderSpriteLine(x, y, x + math_cos(self.angle) * 20, y + math_sin(self.angle) * 20, 255, 255, 255, 0)
-		
+
 		if self.itemRef then
 			video.renderTextSprites(self.type, x - 20, y - 80, 1, "small", 255, 0, 255, 0, nil, 0.7)
 		end
-		
+
 		if self.boosted then
 			video.renderTextSprites("BOOST", x + 50, y - 80, 0, "small", 255, 0, 255, 0, nil, 0.7)
 		end
-		
+
 		if self.isSleeping then
 			if self.map.physics:isEntitySleeping(self.body) then
 				video.renderTextSprites("sleep X", x, y - 20, 1, "small", 255, 0, 255, 255, nil, 0.7)
@@ -3451,49 +3450,54 @@
 			end
 		elseif self.fatigue then
 			if self.map.physics:isEntitySleeping(self.body) then
-				video.renderTextSprites(string.format("%.2f", self.fatigue) .. " X", x, y - 20, 1, "small", 255, 255, 0, 255, nil, 0.7)
+				video.renderTextSprites(string.format("%.2f", self.fatigue) .. " X", x, y - 20, 1, "small", 255, 255, 0, 255, nil,
+					0.7)
 			else
 				video.renderTextSprites(string.format("%.2f", self.fatigue), x, y - 20, 1, "small", 255, 255, 0, 0, nil, 0.7)
 			end
 		end
-		
+
 		if self.fatigue then
-			video.renderTextSprites(self.map.physics:getEntityFatigue(self.body), x + 75, y, 0, "small", 255, 0, 128, 0, nil, 0.6)
+			video.renderTextSprites(self.map.physics:getEntityFatigue(self.body), x + 75, y, 0, "small", 255, 0, 128, 0, nil,
+				0.6)
 		end
-		
+
 		if self.allowPhysicsManipulation then
 			video.renderTextSprites("Manip", x, y - 30, 1, "small", 255, 255, 255, 0, nil, 0.7)
 		end
-		
+
 		if self.onGround then
 			video.renderTextSprites("onG", x + 20, y - 30, 0, "small", 255, 0, 255, 255, nil, 0.7)
 		end
-		
+
 		if self.motionless then
 			video.renderTextSprites(string.format("%.2f", self.motionless), x, y + 20, 1, "small", 255, 64, 64, 64, nil, 0.7)
 		end
 	end
-	
+
 	if DEBUG.showClassifications and self.mc then
 		local yy = 0
-		
+
 		video.renderTextSprites(tostring(self.health), x, y - 20 - yy, 1, "small", 255, 64, 0, 255, nil, 0.7)
-		
+
 		yy = yy + 15
-		
+
 		for index, m in pairs(self.mc) do
 			video.renderTextSprites(index, x, y - 20 - yy, 1, "small", 255, 64, 0, 64, nil, 0.7)
-			
+
 			yy = yy + 15
 		end
 	end
-	
+
 	if DEBUG.showObjectSpeed and not self.def.debris then
-		video.renderTextSprites(math_round(self:getSpeed()) .. " *" .. string.simplifyNumber(self.timeFactor, 2), x, y - 15, 1, "small", 255, 128, 255, 128, nil, 0.7)
-		video.renderTextSprites(string.simplifyNumber(self.dx, 2) .. ",  " .. string.simplifyNumber(self.dy, 2), x, y - 1, 1, "small", 255, 128, 128, 255, nil, 0.5)
-		
+		video.renderTextSprites(math_round(self:getSpeed()) .. " *" .. string.simplifyNumber(self.timeFactor, 2), x, y - 15,
+			1, "small", 255, 128, 255, 128, nil, 0.7)
+		video.renderTextSprites(string.simplifyNumber(self.dx, 2) .. ",  " .. string.simplifyNumber(self.dy, 2), x, y - 1, 1,
+			"small", 255, 128, 128, 255, nil, 0.5)
+
 		if self.fluidType and self.submersion then
-			video.renderSpriteLine(x, y, x, y - self.submersion * 100, 64, 255 * self.submersion, 255, 128, nil, 0.75 + 1.25 * self.timeFactor)
+			video.renderSpriteLine(x, y, x, y - self.submersion * 100, 64, 255 * self.submersion, 255, 128, nil,
+				0.75 + 1.25 * self.timeFactor)
 		end
 	end
 end
@@ -3503,20 +3507,20 @@
 		if self.anyShader and shaders.enabled and not self.shaderApplied then
 			self:prepareShader()
 		end
-		
+
 		if self.slept then
 			self:removeSlept()
 		end
-		
+
 		local def = self.def
-		
+
 		if def.renderMethod then
 			if self.shader then
 				shaders.pushRenderShader(self.shader, self.shaderData)
 			end
-			
+
 			def.renderMethod(self, x, y, r, g, b)
-			
+
 			if self.shader then
 				shaders.popRenderShader(self.shader, self.shaderData)
 			end
@@ -3526,7 +3530,7 @@
 
 function Object:updateFluid(t, x, y, factor, time)
 	local fluid = DEFS.FLUIDS[t]
-	
+
 	if fluid.objectUpdate then
 		fluid.objectUpdate(self, x, y, factor, time)
 	end
@@ -3534,14 +3538,14 @@
 
 function Object:setTargetScale(scale)
 	self:checkPrediction()
-	
+
 	self.scale = self.scale or 1
-	
+
 	if not self.husk then
 		self.targetScale = scale
 		self.smoothTargetScale = self.scale
 		self.smoothScale = self.scale
-		
+
 		self:classify("updateTargetScale")
 	end
 end
@@ -3552,37 +3556,37 @@
 	local w = 0
 	local h = 0
 	local ox, oy = self.x, self.y
-	
+
 	for i = 0, 1 do
 		local angle = base_angle + math.pi * i
 		local free, target, x, y = self:getLosTowards(angle, ray_length, los_settings)
-		
+
 		w = w + math.distance(ox, oy, x, y)
 	end
-	
+
 	for i = 0, 1 do
 		local angle = base_angle + math.pi * i + math.pi * 0.5
 		local free, target, x, y = self:getLosTowards(angle, ray_length, los_settings)
-		
+
 		h = h + math.distance(ox, oy, x, y)
 	end
-	
+
 	local space = math.min(w, h)
-	
+
 	return space
 end
 
 function Object:setSmoothScale(scale)
 	self.scale = self.scale or scale
 	self.smoothScale = scale
-	
+
 	self:classify("updateSmoothScale")
 end
 
 function Object:updateSmoothScale(time)
 	local scale = self.scale
 	local smooth = self.smoothScale
-	
+
 	if scale ~= smooth then
 		scale = math.approach(scale, smooth, time * math_abs(smooth - scale) * 10 + time * 10)
 		self.scale = scale
@@ -3590,7 +3594,7 @@
 		if self.body then
 			self:recreatePhysics()
 		end
-		
+
 		self:declassify("updateSmoothScale")
 	end
 end
@@ -3599,32 +3603,33 @@
 	local smoothScale = self.smoothScale
 	local targetScale = self.targetScale
 	local climbingTargetScale = self.smoothTargetScale
-	
+
 	if targetScale and climbingTargetScale ~= targetScale then
-		climbingTargetScale = math.approach(climbingTargetScale, targetScale, time * math_abs(targetScale - climbingTargetScale) + time)
+		climbingTargetScale = math.approach(climbingTargetScale, targetScale,
+			time * math_abs(targetScale - climbingTargetScale) + time)
 		self.smoothTargetScale = climbingTargetScale
 	end
-	
+
 	if targetScale and targetScale ~= smoothScale then
 		if math.abs(climbingTargetScale - smoothScale) > 0.25 or climbingTargetScale == targetScale then
 			local bounds = self.def.bounds
 			local w, h = bounds:getWidth(), bounds:getHeight()
 			local desired_space = math.max(w, h) * climbingTargetScale
 			local space = self:calculateFreeLosSpaceAround(desired_space, LOS.bullet)
-			
+
 			if desired_space <= space then
 				self:setSmoothScale(climbingTargetScale)
 			else
 				self.targetScale = nil
 				self.smoothTargetScale = nil
-				
+
 				self:declassify("updateTargetScale")
 			end
 		end
 	else
 		self.targetScale = nil
 		self.smoothTargetScale = nil
-		
+
 		self:declassify("updateTargetScale")
 	end
 end
@@ -3632,13 +3637,13 @@
 function Object:updateGlow(time)
 	if self.glowTimer > 0 then
 		self.glowTimer = math_max(0, self.glowTimer - time / (self.glowDuration or 3))
-		
+
 		if self.grayFade > 0 then
 			self.anyShader = true
 		end
 	else
 		self.glowTimer = nil
-		
+
 		self:declassify("updateGlow")
 	end
 end
@@ -3647,40 +3652,40 @@
 	if self.sparkTimer then
 		if self.sparkTimer > 0 then
 			self.sparkTimer = self.sparkTimer - time
-			
+
 			local details = _config.graphicsFx
-			
+
 			if details > 0 and math_random() < details * time * 2 * math_min(1, self.sparkTimer) then
 				self:emitFx("botDamagedSpark")
-				
+
 				if math_random() > 0.75 then
 					self:emitSound("hardFizzle", 1, math_random() * 0.1 + 1.6 - math_min(1, self.sparkTimer) * 0.5)
 				end
-				
+
 				self:addSpeed(math_random() * 2 * math_pi, math_random() * 6 + 3)
 				self:setAngleSpeed(math_random() * math_pi * 1 - math_random() * math_pi * 1)
 			end
-			
+
 			if self.sparkTimer <= 0 and self.endSparkSmokeTimer and self.endSparkSmokeTimer > 0 then
 				self:emitSound("gunBreak", 1, 1)
 			end
 		end
 	else
 		local sptimer = self.endSparkSmokeTimer
-		
+
 		if sptimer and sptimer > 0 then
 			sptimer = sptimer - time
-			
+
 			local details = _config.graphicsFx
-			
+
 			if details > 0 and math_random() < time * 15 * math_min(1, sptimer) * details then
 				local ang = -half_pi + math_pi * math_random() * 0.2 - math_pi * math_random() * 0.2
 				local dist = math_random() * 15 * math_min(1, sptimer)
 				local fx = self:emitFxAt("fragileSmoke", self.x + math_cos(ang) * dist, self.y + math_sin(ang) * dist)
-				
+
 				fx:setSpeed(ang, 29 * math_min(1, sptimer) + math_random(15) * math_min(1, self.endSparkSmokeTimer))
 			end
-			
+
 			self.endSparkSmokeTimer = sptimer
 		else
 			self:declassify("updateSpark")
@@ -3691,23 +3696,25 @@
 function Object:updateSparkShoot(time)
 	if self.sparkShootTimer > 0 then
 		local details = _config.graphicsFx
-		
+
 		if details > 0 and math_random() < time * 6 * math_min(1, self.sparkShootTimer) * details then
 			local offAng = math_randomAngle()
 			local obj = self:emitSpark("postTinyDestroySpark")
-			
-			obj:setSpeed(offAng, math_random() * 2 / math_min(1, math_max(0.1, self.sparkShootTimer)) + 5 / math_min(1, math_max(0.1, self.sparkShootTimer)))
+
+			obj:setSpeed(offAng,
+				math_random() * 2 / math_min(1, math_max(0.1, self.sparkShootTimer)) +
+				5 / math_min(1, math_max(0.1, self.sparkShootTimer)))
 			obj:addSpeedXY(self.dx, self.dy)
-			
+
 			obj.dieOnCollision = true
 			obj.dieSound = "fizzle"
 		end
-		
+
 		self.sparkShootTimer = self.sparkShootTimer - time
-		
+
 		if self.sparkShootTimer <= 0 then
 			self.sparkShootTimer = nil
-			
+
 			self:declassify("updateSparkShoot")
 		end
 	end
@@ -3716,18 +3723,19 @@
 function Object:updateBurn(time)
 	if self.burnTimer > 0 then
 		self.burnTimer = math_max(0, self.burnTimer - time)
-		
-		self:emitLoop("flame", math_min(1, self.burnTimer), math_min(1, self.burnTimer) * 0.5 + 0.5, math_min(1, self.burnTimer) * RANGES.long)
-		
+
+		self:emitLoop("flame", math_min(1, self.burnTimer), math_min(1, self.burnTimer) * 0.5 + 0.5,
+			math_min(1, self.burnTimer) * RANGES.long)
+
 		if math_random() < time * 15 * math_min(1, self.burnTimer) * math_max(0.5, self:getSpeed() * 0.5) then
 			local ang = math_pi * 2 * math_random()
 			local dist = math_random() * 15 * math_min(1, self.burnTimer)
 			local fx = self:emitFxAt("debrisFireSmoke", self.x + math_cos(ang) * dist, self.y + math_sin(ang) * dist)
-			
+
 			fx:setSpeed(math_random() * math_pi * 2, math_random(10) * math_min(1, self.burnTimer))
-			
+
 			local fx = self:emitFxAt("debrisFire", self.x + math_cos(ang) * dist, self.y + math_sin(ang) * dist)
-			
+
 			fx:setSpeed(math_random() * math_pi * 2, math_random(40) * math_min(1, self.burnTimer))
 		end
 	else
@@ -3737,48 +3745,48 @@
 
 function Object:updateHit(time)
 	self.hitTimer = self.hitTimer - time / 0.9
-	
+
 	if self.hitTimer <= 0 then
 		self.hitTimer = nil
-		
+
 		self:declassify("updateHit")
 	end
 end
 
 function Object:highlightBlueprint()
 	self:flashWhite(1)
-	
+
 	self.blueprintTimer = 2
-	
+
 	if not self.blueprintFx or self.blueprintFx._remove then
 		self.blueprintFx = self:emitPpFx("blueprint")
-		
+
 		self.blueprintFx:setReference(self)
 	end
-	
+
 	if not self.blueprintText or self.blueprintText._remove then
 		self.blueprintText = self:emitPpFx("blueprintText")
 		self.blueprintText.text = localize.get("blueprint")
-		
+
 		self.blueprintText:setMasterColor(COLORS.blueprint)
 		self.blueprintText:setMasterScale(0.7)
 	else
 		self.blueprintText:setTime(math_min(1, self.blueprintText.time))
 		self.blueprintText:setPosition(self.x, self.y - 10)
 	end
-	
+
 	self.blueprintFx:setMasterScale(1)
 	self.blueprintFx:setMasterAlpha(255)
 end
 
 function Object:updateBlueprint(time)
 	self.blueprintTimer = self.blueprintTimer - time
-	
+
 	if self.blueprintTimer <= 0 then
 		self.blueprintTimer = nil
-		
+
 		self:declassify("updateBlueprint")
-		
+
 		self.blueprintText = nil
 		self.blueprintFx = nil
 	end
@@ -3786,16 +3794,16 @@
 
 function Object:updateHighlight(time)
 	self.highlighted = self.highlighted - time
-	
+
 	if self.highlighted <= 0 then
 		self.highlighted = nil
-		
+
 		self:declassify("updateHighlight")
-		
+
 		if self.blueprintText then
 			self.blueprintText = nil
 		end
-		
+
 		if self.blueprintFx then
 			self.blueprintFx = nil
 		end
@@ -3819,7 +3827,7 @@
 function Object:updateGravityList(objects, gravity, time)
 	for _, object in pairs(objects) do
 		local obj_time = time * object.pingTimeFactor
-		
+
 		object.gravityCache = object.gravityCache or object:getGravity()
 		object.dy = object.dy + object.gravityCache * gravity * obj_time
 	end
@@ -3829,7 +3837,7 @@
 	if self.heat ~= 0 then
 		if self.heatProtection then
 			self.heatProtection = self.heatProtection - time
-			
+
 			if self.heatProtection <= 0 then
 				self.heatProtection = nil
 			end
@@ -3837,7 +3845,7 @@
 			self.heatDelay = self.heatDelay - time
 		else
 			self.heat = math_approach(self.heat, 0, math_abs(self.heat) * 0.5 * time + time * 0.25)
-			
+
 			if self.heat == 0 then
 				self:declassify("updateHeat")
 			end
@@ -3861,7 +3869,7 @@
 function Object.prePhysicsSetupList(map, list, time)
 	local physics = map.physics
 	local resolution = map.resolution
-	
+
 	for i, object in pairs(list) do
 		if not object.sleeping and not object.blockUpdate then
 			object:processPrePhysicsSetup(physics, resolution, time)
@@ -3874,42 +3882,42 @@
 function Object:processPrePhysicsSetup(physics, resolution, time)
 	local factor = self.pingTimeFactor
 	local body = self.body
-	
+
 	if body then
 		local physx, physy = physics:getEntityPosition(body)
 		local def = self.def
-		
+
 		if def.noPhysicsMovement then
 			physics:setEntitySpeed(body, 0, 0)
 			physics:setEntityAngleSpeed(body, 0)
-			
+
 			self.x = physx / resolution
 			self.y = physy / resolution
 		else
 			local allowPhysicsManipulation = self.allowPhysicsManipulation
-			
+
 			if def.box2dControlled and not self.attached then
 				if not self.def.fixedRotation then
 					self.angle = math_normalizeAngle(physics:getEntityAngle(body))
 				end
-				
+
 				if allowPhysicsManipulation then
 					physics:setEntityAngleSpeed(body, physics:getEntityAngleSpeed(body) * factor)
 				end
 			elseif allowPhysicsManipulation then
 				physics:setEntityAngle(body, self.angle)
 			end
-			
+
 			self.x = physx / resolution
 			self.y = physy / resolution
 			self.physicsTimeFactor = math_max(MIN_FACTOR, factor)
-			
+
 			if allowPhysicsManipulation then
 				if def.box2dControlledSpeed then
 					if def.box2dGravity then
 						physics:applyEntityForce(body, physx, physy, 0, physics:getEntityMass(body) * self:getGravity())
 					end
-					
+
 					physics:setEntitySpeed(body, self.dx * factor, self.dy * factor)
 				else
 					physics:setEntitySpeed(body, self.dx * factor, self.dy * factor)
@@ -3922,11 +3930,11 @@
 function Object:updateFatigue(time, factor)
 	if not self._remove then
 		self.recursiveBlock = false
-		
+
 		local body = self.body
 		local physics = self.map.physics
 		local fatigue = physics:getEntityFatigue(body)
-		
+
 		if fatigue then
 			if self.parents or self.children then
 				if fatigue > 0.25 and self.sleepTimer then
@@ -3934,22 +3942,23 @@
 				else
 					self.sleepTimer = 0
 				end
-				
+
 				self.fatigue = fatigue
 				self.allowPhysicsManipulation = not self.onGround or self.fatigue <= 0
-				
+
 				if (fatigue >= 0.5 or self.sleepTimer >= 1) and not self.isSleeping and self.timeFactor >= 1 and not self.isLethal and not self.neverInitiateSleep then
 					self:sleep()
-					
-					return 
+
+					return
 				end
-				
+
 				if not self.isSleeping then
 					local adiff = math_abs(self.angle - physics:getEntityAngle(body)) * 300
-					local motionless = self.motionless - (math_abs(self.dx) + math_abs(self.dy) + adiff) * 2 * time + time * (self.motionless + 1)
-					
+					local motionless = self.motionless - (math_abs(self.dx) + math_abs(self.dy) + adiff) * 2 * time +
+					time * (self.motionless + 1)
+
 					self.motionless = math_clamp(motionless, 0, 5)
-					
+
 					if self.motionless >= 5 and self.timeFactor >= 1 then
 						self:sleep()
 					end
@@ -3957,19 +3966,21 @@
 			else
 				self.fatigue = fatigue
 				self.allowPhysicsManipulation = not self.onGround or self.fatigue <= 0
-				
+
 				if fatigue >= 0.5 and self.timeFactor >= 1 then
 					self:sleep()
-					
-					return 
+
+					return
 				end
-				
+
 				local dx, dy = physics:getEntitySpeed(body)
 				local adiff = math_abs(self.angle - physics:getEntityAngle(body)) * 300
-				local motionless = self.motionless - (math_abs(dx) + math_abs(dy) + adiff) / math_max(MIN_FACTOR, self.timeFactor) * 2 * time + time * (self.motionless + 1)
-				
+				local motionless = self.motionless -
+				(math_abs(dx) + math_abs(dy) + adiff) / math_max(MIN_FACTOR, self.timeFactor) * 2 * time +
+				time * (self.motionless + 1)
+
 				self.motionless = math_clamp(motionless, 0, 3)
-				
+
 				if self.motionless >= 3 and self.timeFactor >= 1 then
 					self:sleep()
 				end
@@ -3984,16 +3995,16 @@
 
 function Object:setActual(actual)
 	self.actual = actual
-	
+
 	if actual then
 		self:classify("updateActual")
-		
+
 		self.actual_time = 0
 		self.actual_fade = 0
 		self.nid = actual.nid
 	else
 		self:declassify("updateActual")
-		
+
 		self.nid = nil
 	end
 end
@@ -4007,7 +4018,7 @@
 		self:classify("updateGravityPrediction")
 	else
 		local pred_ground_time = self:calculateLinearPrediction(LOS.ground) or self:getLifeTime()
-		
+
 		self.prediction_deathtime = pred_ground_time
 		self.prediction_lifetime = pred_ground_time
 	end
@@ -4018,16 +4029,16 @@
 	local dist = RANGES.ultra
 	local resolution = self.map.resolution
 	local speed = self:getSpeed()
-	
+
 	if life_time then
 		dist = speed / resolution * life_time
 	end
-	
+
 	local los_ok, hitTarget, hitx, hity, hitAngle = self:getLosTowards(self:getSpeedAngle(), dist, los)
-	
+
 	if not los_ok then
 		local dist_to = math_max(0, math.distance(self.x, self.y, hitx, hity) - self:getFuzzySize())
-		
+
 		return dist_to / (speed / resolution)
 	end
 end
@@ -4040,23 +4051,25 @@
 function Object:updateGravityPrediction(time)
 	local pred_time = self.prediction_lifetime or GLOBAL.prediciton_catchup_max
 	local los_ok, hitTarget, hitx, hity, hitAngle = self:getLosTowards(self:getSpeedAngle(), RANGES.ultra, LOS.ground)
-	
+
 	if not los_ok then
 		local speed = self:getSpeed()
 		local dist = math.distance(self.x, self.y, hitx, hity)
 		local travel_time = dist / math.max(1, speed / self.map.resolution)
-		
+
 		if pred_time > travel_time * 3 then
 			for i = 1, 3 do
 				local predX, predY = self:getPredictedPosition(travel_time * i * i)
 				local hit, hitTarget2, hitx2, hity2 = self:getRayHitAt(predX, predY, LOS.ground)
-				
+
 				if hit then
-					local dist = math.distance(self.x, self.y, hitx2, hity2) * 0.5 + (math_abs(self.x - hitx2) + math_abs(self.y - hity2)) * 0.5
-					
-					pred_time = math.clamp(dist / math.max(1, speed / self.map.resolution * self.pingTimeFactor), GLOBAL.prediciton_catchup_min, pred_time)
+					local dist = math.distance(self.x, self.y, hitx2, hity2) * 0.5 +
+					(math_abs(self.x - hitx2) + math_abs(self.y - hity2)) * 0.5
+
+					pred_time = math.clamp(dist / math.max(1, speed / self.map.resolution * self.pingTimeFactor),
+						GLOBAL.prediciton_catchup_min, pred_time)
 					self.prediction_lifetime = pred_time
-					
+
 					break
 				end
 			end
@@ -4069,16 +4082,16 @@
 
 function Object.postPhysicsList(object_list, time)
 	local OBJECTS = OBJECTS
-	
+
 	for _, object in ipairs(object_list) do
 		repeat
 			if object.body and not object.blockUpdate then
 				local def = object.def
-				
+
 				if def.noPhysicsMovement or object.static then
 					break
 				end
-				
+
 				object:processPostPhysics(time)
 			end
 		until true
@@ -4089,17 +4102,17 @@
 	if not self.isSleeping then
 		local dx, dy
 		local physics = self.map.physics
-		
+
 		if self.def.box2dControlledSpeed then
 			local body = self.body
 			local allowPhysicsManipulation = self.allowPhysicsManipulation
 			local tf = self.physicsTimeFactor
-			
+
 			if tf > 0 then
 				if allowPhysicsManipulation then
 					physics:setEntityAngleSpeed(body, physics:getEntityAngleSpeed(body) / tf)
 				end
-				
+
 				if self.startDx then
 					dx, dy = physics:getEntitySpeed(body)
 					dx = dx / tf
@@ -4118,7 +4131,7 @@
 
 function Object:getRelationTeam()
 	local act = self:getResponsibleActor()
-	
+
 	return act and act:getRelationTeam()
 end
 
@@ -4128,9 +4141,9 @@
 
 function Object:applySpecial(id, actor, weapon)
 	self[id] = true
-	
+
 	local def = DEFS.SPECIALS[id]
-	
+
 	if def.apply then
 		def.apply(weapon, actor, self)
 	end
@@ -4139,32 +4152,32 @@
 function Object.updateWakeupList(map, list)
 	local physics = map.physics
 	local bodyLookup = map.bodyLookup
-	
+
 	for _, object in pairs(list) do
 		repeat
 			if not object.blockUpdate and not object._remove and object.body then
 				object.recursiveBlock = false
-				
+
 				if object.parents or object.children then
 					local fatigue = physics:getEntityFatigue(object.body)
-					
+
 					if fatigue then
 						local sleepTimer = object.sleepTimer
-						
+
 						if object.isSleeping and (fatigue < 0.5 and sleepTimer < 1 or sleepTimer >= 1 and fatigue <= 0) then
 							object:wake()
-							
+
 							break
 						end
 					end
 				elseif not physics:isEntitySleeping(object.body) or not object.isSleeping then
 					object:wake()
-					
+
 					break
 				end
-				
+
 				local groundId = object.groundId
-				
+
 				if groundId and not bodyLookup[groundId] then
 					object:wake()
 				end
@@ -4176,17 +4189,17 @@
 function Object:updateWakeup(time, factor)
 	if not self._remove then
 		self.recursiveBlock = false
-		
+
 		if self.parents or self.children then
 			local fatigue = self.map.physics:getEntityFatigue(self.body)
-			
+
 			if (fatigue < 0.5 and self.sleepTimer < 1 or self.sleepTimer >= 1 and fatigue <= 0) and self.isSleeping then
 				self:wake()
 			end
 		elseif not self.map.physics:isEntitySleeping(self.body) or not self.isSleeping then
 			self:wake()
 		end
-		
+
 		if self.groundId and not self.map.bodyLookup[self.groundId] then
 			self:wake()
 		end
@@ -4213,7 +4226,7 @@
 	else
 		self.hitActive = v
 	end
-	
+
 	self:triggerHooks("changedHitActive")
 end
 
@@ -4251,22 +4264,22 @@
 	for index, imp in pairs(temp_impacts) do
 		table.clear(imp)
 	end
-	
+
 	table.clear(temp_impacts_targets)
 	table.clear(temp_impacts_table)
 end
 
 function Object.postPhysicsHandlingSensorsList(object_list, time)
 	local math_angleBetweenPoints = math_angleBetweenPoints
-	
+
 	for _, self in ipairs(object_list) do
 		repeat
 			local body = self.body
-			
+
 			if not body or self.blockUpdate or self.def.noPhysicsMovement or self._remove then
 				break
 			end
-			
+
 			local factor = self.pingTimeFactor
 			local my_time = time * factor
 			local sensors = self.sensors
@@ -4275,12 +4288,12 @@
 			local numSensors = math_min(total_temp_impacts, physics:getEntitySensorPointCount(body))
 			local sensor_target_index = 1
 			local bodyLookup = self.map.bodyLookup
-			
+
 			for sensor_index = 1, numSensors do
 				local sensor = temp_impacts[sensor_target_index]
 				local id, userData = physics:getEntitySensorPoint(body, sensor_index)
 				local target = bodyLookup[id]
-				
+
 				if target and not temp_impacts_targets[target] then
 					temp_impacts_targets[target] = true
 					sensor.target = target
@@ -4291,34 +4304,34 @@
 					numSensors = numSensors - 1
 				end
 			end
-			
+
 			if not table.isEmpty(temp_impacts_targets) then
 				table.clear(temp_impacts_targets)
 			end
-			
+
 			if numSensors > 0 then
 				local sensorMethod = self.def.sensorMethod
-				
+
 				for sensor_index = 1, numSensors do
 					local sensor = temp_impacts[sensor_index]
-					
+
 					if self._remove then
 						break
 					end
-					
+
 					local target = bodyLookup[sensor.id]
-					
+
 					sensor.owner = self
 					sensor.target = target
 					sensor.x = self.x
 					sensor.y = self.y
 					sensor.angle = math_angleBetweenPoints(self.x, self.y, target.x, target.y)
 					sensor.impulse = 0
-					
+
 					sensorMethod(self, sensor, my_time)
-					
+
 					sensor.target = nil
-					
+
 					for a, _ in pairs(sensor) do
 						sensor[a] = nil
 					end
@@ -4329,7 +4342,8 @@
 end
 
 function Object.postPhysicsHandlingImpactsList(object_list, time)
-	local math_pi, math_abs, math_angleDifference, math_angleBetweenPoints = math_pi, math_abs, math_angleDifference, math_angleBetweenPoints
+	local math_pi, math_abs, math_angleDifference, math_angleBetweenPoints = math_pi, math_abs, math_angleDifference,
+			math_angleBetweenPoints
 	local OBJECTS = OBJECTS
 	local pairs, next = pairs, next
 	local math_approach, math_distance = math.approach, math.distance
@@ -4339,37 +4353,37 @@
 	local getEntityCollision = Box2d.getEntityCollision
 	local getEntitySpeed = Box2d.getEntitySpeed
 	local setSpeedXY = Object.setSpeedXY
-	
+
 	for _, self in pairs(object_list) do
 		repeat
 			local body = self.body
 			local def = self.def
-			
+
 			if not body or self.blockUpdate or def.noPhysicsMovement or self.isSleeping or self._remove then
 				break
 			end
-			
+
 			local factor = self.pingTimeFactor
 			local my_time = time * factor
-			
+
 			self.onGround = false
-			
+
 			local my_type = self.type
 			local map = self.map
 			local physics = map.physics
 			local numImpacts = math_min(total_temp_impacts, getEntityCollisionCount(physics, body))
-			
+
 			if numImpacts > 0 then
 				local bodyLookup = map.bodyLookup
 				local resolution = map.resolution
 				local has_impulse = false
 				local impact_index = 1
-				
+
 				for i = 1, numImpacts do
 					local impact = temp_impacts[impact_index]
 					local x, y, nx, ny, id, userData, impulse = getEntityCollision(physics, body, i)
 					local target = bodyLookup[id]
-					
+
 					if target and not temp_impacts_targets[target] then
 						temp_impacts_targets[target] = true
 						impact.target = target
@@ -4386,38 +4400,38 @@
 						numImpacts = numImpacts - 1
 					end
 				end
-				
+
 				for k, v in pairs(temp_impacts_targets) do
 					temp_impacts_targets[k] = nil
 				end
-				
+
 				if has_impulse and def.box2dControlledSpeed then
 					local dx, dy = getEntitySpeed(physics, body)
-					
+
 					self.dx, self.dy = dx / self.physicsTimeFactor, dy / self.physicsTimeFactor
 					self.has_collided = true
 				end
-				
+
 				local collisionMethod = def.collisionMethod
-				
+
 				if collisionMethod then
 					self.onGround = true
-					
+
 					for i = 1, numImpacts do
 						local impact = temp_impacts[i]
 						local angle = impact.angle
 						local target = impact.target
-						
+
 						collisionMethod(self, impact, my_time)
-						
+
 						self.groundId = impact.id
-						
+
 						if target then
 							local category = target._category
-							
+
 							if category == "tile" then
 								local groundRefSpeedsMethod = target.def.groundRefSpeedsMethod
-								
+
 								if groundRefSpeedsMethod then
 									local rdx, rdy = groundRefSpeedsMethod(target, self, angle)
 									local mass = self.mass
@@ -4427,50 +4441,51 @@
 									local ndx, ndy = self.dx, self.dy
 									local spDiff = math_distance(ndx, ndy, rdx, rdy)
 									local fact = 900 * my_time / (1 + spDiff)
-									
+
 									ndx = math_approach(ndx, rdx, fact)
 									ndy = math_approach(ndy, rdy, fact)
-									
+
 									setSpeedXY(self, ndx, ndy)
-									applyEntityImpulse(physics, body, impact.x * resolution, impact.y * resolution, t_dx * mass_time, t_dy * mass_time)
+									applyEntityImpulse(physics, body, impact.x * resolution, impact.y * resolution, t_dx * mass_time,
+										t_dy * mass_time)
 								end
 							elseif category == "object" then
 								local tCollisionMethod = target.def.collisionMethod
-								
+
 								if tCollisionMethod then
 									impact.owner = target
 									impact.angle = angle + math_pi
 									impact.target = self
-									
+
 									tCollisionMethod(target, impact, my_time)
 								end
 							end
 						end
-						
+
 						impact.target = nil
 						impact.owner = nil
-						
+
 						for a, _ in pairs(impact) do
 							impact[a] = nil
 						end
-						
+
 						if self._remove or self.body ~= body then
 							break
 						end
 					end
 				end
 			end
-			
+
 			self.allowPhysicsManipulation = not self.onGround or self.fatigue <= 0
-			
+
 			if def.box2dControlledSpeed then
 				if self.startDx then
 					self.startDx = self.dx
 					self.startDy = self.dy
-					
+
 					break
 				end
-				
+
 				self.startDx = self.savedDx
 				self.startDy = self.savedDy
 			end
@@ -4500,15 +4515,15 @@
 
 function Object:setSpeed(angle, speed)
 	self:wake()
-	
+
 	self.dx = math_cos(angle) * speed
 	self.dy = math_sin(angle) * speed
-	
+
 	if self.def.box2dControlledSpeed and self.allowPhysicsManipulation and self.body then
 		local tf = self.pingTimeFactor
-		
+
 		self.map.physics:setEntitySpeed(self.body, self.dx * tf, self.dy * tf)
-		
+
 		self.startDx = self.dx
 		self.startDy = self.dy
 	end
@@ -4524,32 +4539,32 @@
 	local ny = math_sin(angle) * speed
 	local controlx = control
 	local controly = control
-	
+
 	if vectorX > 0 and nx > 0 and nx < vectorX or vectorX < 0 and nx < 0 and vectorX < nx then
 		controlx = 0
 	end
-	
+
 	if vectorY > 0 and ny > 0 and ny < vectorY or vectorY < 0 and ny < 0 and vectorY < ny then
 		controly = 0
 	end
-	
+
 	local ax = math_min(math_abs(nx - vectorX), math_max(math_abs(nx - vectorX) * -1, (nx - vectorX) * time * controlx))
 	local ay = math_min(math_abs(ny - vectorY), math_max(math_abs(ny - vectorY) * -1, (ny - vectorY) * time * controly))
-	
+
 	self:addSpeedXY(ax, ay)
 end
 
 function Object:addSpeed(angle, speed)
 	self:wake()
-	
+
 	self.dx = self.dx + math_cos(angle) * speed
 	self.dy = self.dy + math_sin(angle) * speed
-	
+
 	if self.def.box2dControlledSpeed and self.allowPhysicsManipulation and self.body then
 		local tf = self.pingTimeFactor
-		
+
 		self.map.physics:setEntitySpeed(self.body, self.dx * tf, self.dy * tf)
-		
+
 		self.startDx = self.dx
 		self.startDy = self.dy
 	end
@@ -4557,15 +4572,15 @@
 
 function Object:testSpeed(angle, speed)
 	self:wake()
-	
+
 	self.dx = self.dx + math_cos(angle) * speed
 	self.dy = self.dy + math_sin(angle) * speed
-	
+
 	if self.def.box2dControlledSpeed and self.allowPhysicsManipulation and self.body then
 		local tf = self.pingTimeFactor
-		
+
 		self.map.physics:setEntitySpeed(self.body, self.dx * tf, self.dy * tf)
-		
+
 		self.startDx = self.dx
 		self.startDy = self.dy
 	end
@@ -4578,12 +4593,12 @@
 function Object:modifySpeedXY(dx, dy)
 	self.dx = dx
 	self.dy = dy
-	
+
 	if self.def.box2dControlledSpeed and self.allowPhysicsManipulation and self.body then
 		local tf = self.pingTimeFactor
-		
+
 		self.map.physics:setEntitySpeed(self.body, self.dx * tf, self.dy * tf)
-		
+
 		self.startDx = self.dx
 		self.startDy = self.dy
 	end
@@ -4591,15 +4606,15 @@
 
 function Object:setSpeedXY(dx, dy)
 	self:wake()
-	
+
 	self.dx = dx
 	self.dy = dy
-	
+
 	if self.def.box2dControlledSpeed and self.allowPhysicsManipulation and self.body then
 		local tf = self.pingTimeFactor
-		
+
 		self.map.physics:setEntitySpeed(self.body, self.dx * tf, self.dy * tf)
-		
+
 		self.startDx = self.dx
 		self.startDy = self.dy
 	end
@@ -4607,15 +4622,15 @@
 
 function Object:propelSpeedXY(dx, dy)
 	self:wake()
-	
+
 	self.dx = self.dx + dx
 	self.dy = self.dy + dy
-	
+
 	if self.def.box2dControlledSpeed and self.allowPhysicsManipulation and self.body then
 		local tf = self.pingTimeFactor
-		
+
 		self.map.physics:setEntitySpeed(self.body, self.dx * tf, self.dy * tf)
-		
+
 		self.startDx = self.dx
 		self.startDy = self.dy
 	end
@@ -4623,15 +4638,15 @@
 
 function Object:addSpeedXY(dx, dy)
 	self:wake()
-	
+
 	self.dx = self.dx + dx
 	self.dy = self.dy + dy
-	
+
 	if self.def.box2dControlledSpeed and self.allowPhysicsManipulation and self.body then
 		local tf = self.pingTimeFactor
-		
+
 		self.map.physics:setEntitySpeed(self.body, self.dx * tf, self.dy * tf)
-		
+
 		self.startDx = self.dx
 		self.startDy = self.dy
 	end
@@ -4640,7 +4655,7 @@
 function Object:addSpeedXYProjected(dx, dy, angle)
 	if math_abs(math_angleDifference(math_angleBetweenPoints(0, 0, dx, dy), angle)) < half_pi then
 		local sx, sy = _vectorMath.project(dx, dy, math_cos(angle), math_sin(angle))
-		
+
 		self:addSpeedXY(sx, sy)
 	end
 end
@@ -4663,11 +4678,11 @@
 	else
 		self.allowPickup = val
 	end
-	
+
 	if not self.allowPickup then
 		self:setPickupable(false)
 	end
-	
+
 	self.isPickupable = self:getIsPickupable()
 end
 
@@ -4679,7 +4694,7 @@
 	if self.prediction then
 		self.prediction:setPickupable(val)
 	end
-	
+
 	if self.map then
 		if val and not self.pickupable then
 			self:classify("pickup")
@@ -4687,12 +4702,12 @@
 			self:declassify("pickup")
 		end
 	end
-	
+
 	self.pickupable = val
 	self.isPickupable = self:getIsPickupable()
-	
+
 	self:triggerHooks("changedPickupable")
-	
+
 	if val then
 		if not self.idle and not self.def.neverIdle then
 			self:setPhysicsType("idle")
@@ -4707,11 +4722,11 @@
 		local map = self.map
 		local physics = map and map.physics
 		local body = self.body
-		
+
 		if physics and body then
 			physics:setEntityAngle(body, angle)
 		end
-		
+
 		self.angle = angle
 	else
 		self.angle = angle
@@ -4720,19 +4735,19 @@
 
 function Object:setIgnore(ignore)
 	local def = self.def
-	
+
 	if def.neverIgnore and ignore then
-		return 
+		return
 	end
-	
+
 	local was = self.ignore
-	
+
 	if ignore ~= was then
 		self:changeIgnore(ignore)
 	end
-	
+
 	local method = def.onIgnoreChangedMethod
-	
+
 	if method then
 		method(self, ignore)
 	end
@@ -4740,21 +4755,21 @@
 
 function Object:setAutopickup(v)
 	self.autoPickup = true
-	
+
 	if self.body then
 		self.bodyFilter = self.body and -self.body
-		
+
 		self.map.physics:setEntityGroup(self.body, self.bodyFilter)
 	end
 end
 
 function Object:changeIgnore(ignore)
 	self.ignore = ignore
-	
+
 	local body = self.body
-	
+
 	self.bodyFilter = ignore and ignore.bodyFilter or body and -body
-	
+
 	if body then
 		self.map.physics:setEntityGroup(body, self.bodyFilter)
 	end
@@ -4770,7 +4785,7 @@
 
 function Object:setPlayer(p)
 	self.player = p
-	
+
 	if self.def.onPlayerSet then
 		self.def.onPlayerSet(self, p)
 	end
@@ -4778,32 +4793,32 @@
 
 function Object:setTeamObjective(v)
 	self:checkPrediction()
-	
+
 	if v then
 		self.teamObjective = v
-		
+
 		local ref = self.itemRef
 		local team = ref and ref.team
-		
+
 		if team then
 			self.teamObjectiveTeam = team
-			
+
 			self:classifySub("teamObjective", team)
 		end
-		
+
 		if false then
 		end
 	else
 		self.teamObjective = nil
-		
+
 		local team = self.teamObjectiveTeam
-		
+
 		if team then
 			self:declassifySub("teamObjective", team)
-			
+
 			self.teamObjectiveTeam = nil
 		end
-		
+
 		if false then
 		end
 	end
@@ -4811,21 +4826,21 @@
 
 function Object:setTargetType(v)
 	self:checkPrediction()
-	
+
 	if v then
 		self.targetType = v
-		
+
 		self:classify("objectiveTarget")
 	else
 		self.targetType = nil
-		
+
 		self:declassify("objectiveTarget")
 	end
 end
 
 function Object:setSuccessTarget(t)
 	self.successTarget = t
-	
+
 	if self.def.onSuccessTargetSet then
 		self.def.onSuccessTargetSet(self, t)
 	end
@@ -4834,7 +4849,7 @@
 function Object:setTarget(t, subTarget)
 	self.target = t
 	self.subTarget = subTarget
-	
+
 	if self.def.onTargetSet then
 		self.def.onTargetSet(self, t, subTarget)
 	end
@@ -4846,14 +4861,14 @@
 
 function Object:setLinkTarget(link)
 	self.linkTarget = link
-	
+
 	self:refreshLinkTarget()
 end
 
 function Object:destroyLink()
 	if not self.destroyed then
 		self:destroy()
-		
+
 		if self.link then
 			self.link:destroyLink()
 		end
@@ -4862,15 +4877,15 @@
 
 function Object:setLink(link)
 	self.link = link
-	
+
 	self:refreshLink()
 end
 
 function Object:setLinkPower(linkPower)
 	self.linkPower = linkPower
-	
+
 	self:refreshLink()
-	
+
 	if linkPower then
 		self:emitSound("powerOnFast", 1, 1.25)
 	else
@@ -4885,26 +4900,26 @@
 
 function Object:setLinkType(linkType)
 	self.linkType = linkType
-	
+
 	self:refreshLink()
 end
 
 function Object:refreshLink()
 	if self.itemRef then
 		local meth = self.itemRef.def.asObjectRefreshLink
-		
+
 		if meth then
 			meth(self.itemRef, self, self.link, self.linkPower, self.linkType or "crystal")
 		end
 	end
-	
+
 	self:refreshLinkTarget()
 end
 
 function Object:refreshLinkTarget()
 	if self.itemRef then
 		local meth = self.itemRef.def.asObjectRefreshLinkTarget
-		
+
 		if meth then
 			meth(self.itemRef, self, self.linkTarget, self.linkPower)
 		end
@@ -4914,22 +4929,22 @@
 function Object:findLinkPower(seen_table)
 	if not seen_table[self] then
 		seen_table[self] = true
-		
+
 		local link = self.link
-		
+
 		if link and not seen_table[link] then
 			local power = link:findLinkPower(seen_table)
-			
+
 			if power then
 				power = power - 1
-				
+
 				if power > 0 then
 					return power
 				end
 			end
 		end
 	end
-	
+
 	return false
 end
 
@@ -4938,16 +4953,16 @@
 function Object:refreshLinkPower()
 	local link = self.link
 	local linkPower
-	
+
 	if not link then
 		linkPower = false
 	else
 		marked_links[self] = true
 		linkPower = link:findLinkPower(marked_links)
-		
+
 		table.clear(marked_links)
 	end
-	
+
 	if linkPower ~= self.linkPower then
 		self:setLinkPower(linkPower)
 	end
@@ -4958,33 +4973,34 @@
 		if speed > 0 then
 			self:addSpeed(self.angle, time * speed)
 		end
-		
+
 		local targetAngle = self:getAngleTo(self.target)
-		
+
 		if stop > 0 then
 			local diff = math_abs(math_angleDifference(targetAngle, self:getSpeedAngle())) / math_pi
-			
+
 			self:stopSpeedXY(speed * stop * diff, speed * stop * diff, time)
 		end
-		
+
 		self:setAngle(math_approachAngle(self.angle, targetAngle, math_pi * rotation * time))
-		
+
 		if carving then
 			local speedAng = self:getSpeedAngle()
 			local carve = math_approachAngle(speedAng, targetAngle, time * math_pi * 2 * rotation)
 			local speed = self:getSpeed()
-			
-			self:setSpeedXY(self.dx * (1 - time * carving) + carving * time * math_cos(carve) * speed, self.dy * (1 - time * carving) + carving * time * math_sin(carve) * speed)
+
+			self:setSpeedXY(self.dx * (1 - time * carving) + carving * time * math_cos(carve) * speed,
+				self.dy * (1 - time * carving) + carving * time * math_sin(carve) * speed)
 		end
 	end
 end
 
 function Object:setEmitter(v)
 	self.emitter = v
-	
+
 	local def = self.def
 	local method = def.onEmitterChangedMethod
-	
+
 	if method then
 		method(self, v)
 	end
@@ -4994,25 +5010,25 @@
 
 function Object:setOwner(owner)
 	local old_owner = self.owner
-	
+
 	self.owner = owner
 	self.timeFactor = owner and owner.timeFactor or self.timeFactor or 1
-	
+
 	local def = self.def
-	
+
 	if old_owner ~= owner then
 		local method = def.onOwnerChangedMethod
-		
+
 		if method then
 			method(self, owner, old_owner)
 		end
 	end
-	
+
 	self.pingTimeFactor = self.timeFactor
-	
+
 	if not def.neverIgnore then
 		self:setIgnore(owner)
-		
+
 		self.bodyFilter = owner and owner.bodyFilter
 	end
 end
@@ -5027,7 +5043,7 @@
 
 function Object:generatesWarningFor(actor)
 	local warn_for = self.def.warningForMethod
-	
+
 	if warn_for then
 		return warn_for(self, actor)
 	else
@@ -5090,7 +5106,7 @@
 function Object:getBodyPosition()
 	local x, y = self.map.physics:getEntityPosition(self.body)
 	local res = self.map.resolution
-	
+
 	return x / res, y / res
 end
 
@@ -5101,12 +5117,12 @@
 
 function Object:setPosition(x, y)
 	self:wake()
-	
+
 	self.lx = x
 	self.ly = y
 	self.x = x
 	self.y = y
-	
+
 	if self.body then
 		self.map:setEntityPosition(self.body, x, y)
 	end
@@ -5115,7 +5131,7 @@
 function Object:modifyPosition(x, y)
 	self.x = x
 	self.y = y
-	
+
 	if self.body then
 		self.map:setEntityPosition(self.body, x, y)
 	end
@@ -5123,15 +5139,19 @@
 
 function Object:stopSpeed(angle, control, time)
 	if self.dx > 0 then
-		self.dx = self.dx - math_min(math_abs(math_cos(angle)) * self.dx, math_abs(math_cos(angle)) * self.dx * time * control)
+		self.dx = self.dx -
+		math_min(math_abs(math_cos(angle)) * self.dx, math_abs(math_cos(angle)) * self.dx * time * control)
 	elseif self.dx < 0 then
-		self.dx = self.dx - math_max(math_abs(math_cos(angle)) * self.dx, math_abs(math_cos(angle)) * self.dx * time * control)
+		self.dx = self.dx -
+		math_max(math_abs(math_cos(angle)) * self.dx, math_abs(math_cos(angle)) * self.dx * time * control)
 	end
-	
+
 	if self.dy > 0 then
-		self.dy = self.dy - math_min(math_abs(math_sin(angle)) * self.dy, math_abs(math_sin(angle)) * self.dy * time * control)
+		self.dy = self.dy -
+		math_min(math_abs(math_sin(angle)) * self.dy, math_abs(math_sin(angle)) * self.dy * time * control)
 	elseif self.dy < 0 then
-		self.dy = self.dy - math_max(math_abs(math_sin(angle)) * self.dy, math_abs(math_sin(angle)) * self.dy * time * control)
+		self.dy = self.dy -
+		math_max(math_abs(math_sin(angle)) * self.dy, math_abs(math_sin(angle)) * self.dy * time * control)
 	end
 end
 
@@ -5150,7 +5170,7 @@
 function Object:stopAngleSpeed(amount, time)
 	if self.allowPhysicsManipulation then
 		local angleSpeed = self.map.physics:getEntityAngleSpeed(self.body)
-		
+
 		if math_abs(angleSpeed) > 0 then
 			self.map.physics:setEntityAngleSpeed(self.body, math_approach(angleSpeed, 0, math_abs(angleSpeed) * time * amount))
 		end
@@ -5160,10 +5180,10 @@
 function Object:stopLinearSpeedXY(controlX, controlY, time)
 	self.dx = math_approach(self.dx, 0, controlX * time)
 	self.dy = math_approach(self.dy, 0, controlY * time)
-	
+
 	if self.def.box2dControlledSpeed and self.allowPhysicsManipulation then
 		local tf = self.pingTimeFactor
-		
+
 		self.map.physics:setEntitySpeed(self.body, self.dx * tf, self.dy * tf)
 	end
 end
@@ -5171,10 +5191,10 @@
 function Object:stopSpeedXY(controlX, controlY, time)
 	self.dx = math_approach(self.dx, 0, math_abs(self.dx * controlX) * time)
 	self.dy = math_approach(self.dy, 0, math_abs(self.dy * controlY) * time)
-	
+
 	if self.def.box2dControlledSpeed and self.allowPhysicsManipulation then
 		local tf = self.pingTimeFactor
-		
+
 		self.map.physics:setEntitySpeed(self.body, self.dx * tf, self.dy * tf)
 	end
 end
@@ -5211,14 +5231,14 @@
 
 function Object:propelReach(angle, control, power)
 	self:reachSpeedVector(angle, control, power, 1)
-	
+
 	self.startDx = nil
 	self.startDy = nil
 end
 
 function Object:propel(angle, power)
 	self:setSpeedVector(angle, power)
-	
+
 	self.startDx = nil
 	self.startDy = nil
 end
@@ -5226,68 +5246,69 @@
 Object.propelSelf = Object.propel
 
 function Object:setSpeedVector(angle, speed)
-	local offVectorX, offVectorY = _vectorMath.project(self.dx, self.dy, math_cos(angle + math_pi * 0.5), math_sin(angle + math_pi * 0.5))
-	
+	local offVectorX, offVectorY = _vectorMath.project(self.dx, self.dy, math_cos(angle + math_pi * 0.5),
+		math_sin(angle + math_pi * 0.5))
+
 	self:wake()
-	
+
 	self.dx = offVectorX + math_cos(angle) * speed
 	self.dy = offVectorY + math_sin(angle) * speed
-	
+
 	if self.def.box2dControlledSpeed and self.allowPhysicsManipulation then
 		local tf = self.pingTimeFactor
-		
+
 		self.map.physics:setEntitySpeed(self.body, self.dx * tf, self.dy * tf)
 	end
 end
 
 function Object:bounceStartSpeedWithVector(angle, bouncyness)
 	bouncyness = bouncyness or 1
-	
+
 	local dx = self.startDx or self.dx
 	local dx, dy = dx, self.startDy or self.dy
 	local moveSpeed = math_length(dx, dy)
 	local moveAngle = math_angleBetweenPoints(0, 0, dx, dy)
 	local moveImpactDiff = math_abs(math_angleDifference(angle, moveAngle))
 	local length = math_abs(math_cos(moveImpactDiff) * moveSpeed) * (1 + bouncyness)
-	
+
 	if moveImpactDiff <= half_pi then
 		dx = dx + math_cos(angle + math_pi) * length
 		dy = dy + math_sin(angle + math_pi) * length
 		self.dx = dx
 		self.dy = dy
 	end
-	
+
 	if self.def.box2dControlledSpeed and self.allowPhysicsManipulation and self.body then
 		local tf = self.pingTimeFactor
-		
+
 		self.map.physics:setEntitySpeed(self.body, dx * tf, dy * tf)
 	end
-	
+
 	return math_angleBetweenPoints(0, 0, dx, dy)
 end
 
 function Object:bounceWithVector(angle, bouncyness)
 	bouncyness = bouncyness or 1
-	
+
 	local dx, dy = self.dx, self.dy
 	local moveSpeed = math_length(dx, dy)
 	local moveAngle = math_angleBetweenPoints(0, 0, dx, dy)
 	local moveImpactDiff = math_abs(math_angleDifference(angle, moveAngle))
 	local length = math_abs(math_cos(moveImpactDiff) * moveSpeed) * (1 + bouncyness)
-	
+
 	if moveImpactDiff <= half_pi then
 		dx = dx + math_cos(angle + math_pi) * length
 		dy = dy + math_sin(angle + math_pi) * length
 		self.dx = dx
 		self.dy = dy
 	end
-	
+
 	if self.def.box2dControlledSpeed and self.allowPhysicsManipulation and self.body then
 		local tf = self.pingTimeFactor
-		
+
 		self.map.physics:setEntitySpeed(self.body, dx * tf, dy * tf)
 	end
-	
+
 	return math_angleBetweenPoints(0, 0, dx, dy)
 end
 
@@ -5296,15 +5317,15 @@
 	local moveAngle = math_angleBetweenPoints(0, 0, self.dx, self.dy)
 	local moveImpactDiff = math_abs(math_angleDifference(angle, moveAngle))
 	local length = math_abs(math_cos(moveImpactDiff) * moveSpeed)
-	
+
 	if moveImpactDiff <= half_pi then
 		self.dx = self.dx + math_cos(angle + math_pi) * length
 		self.dy = self.dy + math_sin(angle + math_pi) * length
 	end
-	
+
 	if self.def.box2dControlledSpeed and self.allowPhysicsManipulation then
 		local tf = self.pingTimeFactor
-		
+
 		self.map.physics:setEntitySpeed(self.body, self.dx * tf, self.dy * tf)
 	end
 end
@@ -5315,7 +5336,7 @@
 	local moveAngle = math_angleBetweenPoints(0, 0, self.dx, self.dy)
 	local moveImpactDiff = math_angleDifference(angle, moveAngle)
 	local resultingDiff = math_angleDifference(angle + half_pi, moveAngle)
-	
+
 	if math_abs(moveImpactDiff) < half_pi then
 		if resultingDiff < half_pi or moveImpactDiff == 0 and self.dx < 0 then
 			self.dx = math_cos(angle + half_pi - offAngle) * math_abs(moveSpeed)
@@ -5339,11 +5360,13 @@
 end
 
 local function genericColorObjectRender(self, x, y, r, g, b)
-	video.renderSpriteState(self.def.sprite, x, y, 1, self.angle, self.a or 255, self.r or r, self.g or g, self.b or b, self.flipped)
+	video.renderSpriteState(self.def.sprite, x, y, 1, self.angle, self.a or 255, self.r or r, self.g or g, self.b or b,
+		self.flipped)
 end
 
 local function genericBrightObjectRender(self, x, y, r, g, b)
-	video.renderSpriteState(self.def.sprite, x, y, 1, self.angle, 255, (self.r or 1) * 255, (self.g or 1) * 255, (self.b or 1) * 255, self.flipped)
+	video.renderSpriteState(self.def.sprite, x, y, 1, self.angle, 255, (self.r or 1) * 255, (self.g or 1) * 255,
+		(self.b or 1) * 255, self.flipped)
 end
 
 local function physicsObjectRender(self, x, y)
@@ -5364,7 +5387,7 @@
 	if self.ignore and impact.target and impact.target == self.ignore then
 		return true, false
 	end
-	
+
 	if impact.target and impact.target.hit then
 		return impact.target:hit(impact, attack or ATTACKS.simple), true
 	else
@@ -5376,17 +5399,17 @@
 	if impact.target and impact.target._category == "actor" then
 		return impact.target:hit(impact, attack or ATTACKS.sensor), true
 	end
-	
+
 	return false
 end
 
 local function grenadeObjectUpdate(self, time)
 	self.time = self.time + time
-	
+
 	if self.lifeTime and self.time > self.lifeTime then
 		self:destroy()
 	end
-	
+
 	if self.onGround then
 		self:stopSpeedXY(1.5, 1.5, time)
 	end
@@ -5398,22 +5421,22 @@
 	else
 		self.blinkTimer = self.blinkTimer + time * 8
 	end
-	
+
 	if not self.proximity and self.blinkTimer > self.lifeTime - math_max(0, self.time) + 0.19 or self.proximity and self.blinkTimer > self.lifeTime then
 		self.blinkTimer = 0
-		
+
 		if self.proximity then
 			local fx = self:emitPpFx("grenadeBlinkBig")
-			
+
 			fx:setReference(self)
 			self:emitSound("grenadeBeep", 0.6, 1.5 - 0.5 * math_max(self.time, 0) / self.lifeTime, 400)
 		else
 			self.beepToggle = not self.beepToggle
-			
+
 			local fx = self:emitPpFx("grenadeBlink")
-			
+
 			fx:setReference(self)
-			
+
 			if self.beepToggle then
 				self:emitSound("grenadeBeep", 0.6, 0.5 + 0.5 * math_max(self.time, 0) / self.lifeTime, 400)
 			else
@@ -5427,10 +5450,10 @@
 	if impact.impulse > 0.1 then
 		self:hitSound(impact)
 	end
-	
+
 	if self.proximity and impact.target and (impact.target._category == "actor" or impact.target._category == "tile" and impact.target.destructible) then
 		local collide, hit = genericCheckHitOnlyCollideSelf(self, impact, ATTACKS.grenade)
-		
+
 		if collide and hit and impact.target and (collide or impact.target._category == "actor") then
 			self:destroy()
 		else
@@ -5446,19 +5469,19 @@
 local function jetshoeCollisionReaction(self, impact)
 	local x = impact.x or self.x
 	local x, y = x, impact.y or self.y
-	
+
 	for i = 1, 10 do
 		local fx = self:emitFxAt("jetSpark", x, y)
-		
+
 		fx:setSpeed(math_random() * math_pi * 2, 55 + math_random() * 760)
 		fx:setAngle(math_random() * 2 * math_pi)
-		
+
 		fx = self:emitFxAt("jetSmoke", x, y)
-		
+
 		fx:setSpeed(math_random() * math_pi * 2, math_random() * 160)
 		fx:setAngle(math_random() * 2 * math_pi)
 	end
-	
+
 	self:emitOmniForceAt(x, y, 160, 22)
 	self:remove()
 end
@@ -5466,11 +5489,11 @@
 local function jetshoeObjectCollision(self, impact)
 	if genericCheckHit(self, impact, ATTACKS.jet) then
 		self:hitSound(impact)
-		
+
 		if self.owner.isPlayer and impact.target and impact.target._category == "actor" then
 			self.owner:addExcitement()
 		end
-		
+
 		self:performReaction(impact)
 	end
 end
@@ -5478,23 +5501,23 @@
 local function jetshoeBulletObjectUpdate(self, time)
 	if self.owner then
 		self.time = self.time + time
-		
+
 		local angle = self.owner.aimAngle + half_pi
-		
+
 		self.distance = self.distance or 5
-		
+
 		local x, y = self.x, self.y
-		
+
 		if self.owner then
 			x = self.owner.x + math_cos(angle) * self.distance
 			y = self.owner.y + math_sin(angle) * self.distance
 		else
 			self:remove()
 		end
-		
+
 		self:setPosition(x, y)
 		self:setAngle(angle)
-		
+
 		if self.lifeTime and self.time > self.lifeTime then
 			self:remove()
 		end
@@ -5505,7 +5528,7 @@
 
 local function phaserBulletObjectInit(self)
 	local f = self:emitFx("phaserMuzzleFlash")
-	
+
 	f.reference = self
 end
 
@@ -5516,28 +5539,28 @@
 local function phaserBulletObjectUpdate(self, time)
 	self.time = self.time + time
 	self.scale = 1.5 - math_max(0, self.time) / self.lifeTime * 1.2
-	
+
 	if not self.owner or not self.owner.map then
 		self.owner = nil
-		
+
 		self:remove()
-		
-		return 
+
+		return
 	end
-	
+
 	local angle = self.owner:getAbsoluteWeaponAngle()
-	
+
 	self.distance = math_max(0, self.time) * (self.travelDistance or 0)
-	
+
 	local x, y = self.x, self.y
-	
+
 	if self.owner then
 		x, y = self.owner:getSafeWeaponXY(16 + self.distance, nil, true)
 	end
-	
+
 	self:setPosition(x, y)
 	self:setAngle(angle)
-	
+
 	if self.lifeTime and self.time > self.lifeTime then
 		self:remove()
 	end
@@ -5546,41 +5569,42 @@
 local function phaserBulletVisualCollisionReaction(self, x, y, angle)
 	local x = x or self.x
 	local x, y = x, y or self.x
-	
+
 	self:emitFxAt("phaserGlow", x, y)
-	
+
 	local detail = _config.graphicsFx
-	
+
 	for i = 1, math_random(2) + 3 * detail do
 		self:emitFxAt("phaserHitDischarge", x, y):setAngle(math_random() * math_pi * 2)
 	end
-	
+
 	local extra = 0
-	
+
 	if self.hitForce then
 		extra = math_ceil(self.hitForce * 0.133)
 	end
-	
+
 	local angle = angle or self.angle + math.pi
-	
+
 	for i = 1, math_random(2) + 3 * detail + extra * (0.2 + 0.8 * detail) do
 		local fx = self:emitFxAt("phaserSpark", x, y)
-		
-		fx:setSpeed(angle + math_pi + math_random() * 0.5 * math_pi - math_random() * 0.5 * math_pi, math_random(2000) + extra * 200)
+
+		fx:setSpeed(angle + math_pi + math_random() * 0.5 * math_pi - math_random() * 0.5 * math_pi,
+			math_random(2000) + extra * 200)
 		fx:setAngle(math_random() * math_pi * 2)
 		fx:setTime(math_random() * 0.1)
 	end
-	
+
 	self:emitSound("phaserHit", 1, 1, 300 + (self.damageModifier or 1) * 100)
 	self:remove()
 end
 
 local function phaserBulletCollisionReaction(self, impact)
 	self:hitSound(impact)
-	
+
 	local x = impact.x or self.x
 	local x, y = x, impact.y or self.y
-	
+
 	phaserBulletVisualCollisionReaction(self, x, y, impact.angle)
 end
 
@@ -5589,15 +5613,15 @@
 
 local function debrisInit(self, sprite, filterGroup)
 	self:setRemovable()
-	
+
 	self.time = 0
-	
+
 	self:setGray()
-	
+
 	self.sprite = sprite
 	self.onGround = false
 	self.groundAngle = 0
-	
+
 	if sprite and sprite > 0 then
 		self.offsets = sprites.getOrGenerateOffsets(sprite)
 		self._physics = sprites.getOrGenerateDebrisPhysics(sprite)
@@ -5610,35 +5634,36 @@
 local function debrisUpdate(self, time)
 	if not self.body then
 		self:remove()
-		
-		return 
+
+		return
 	end
-	
+
 	if not self.def.box2dControlled and self.onGround then
 		self:stopSpeed(self.groundAngle - half_pi, 1, time)
 	end
-	
+
 	if not self.onGround and self.airFriction then
 		self:stopSpeedXY(self.airFriction, self.airFriction, time)
-		
+
 		local moveAngle = math_angleBetweenPoints(0, 0, self.dx, self.dy)
 		local moveSpeed = math_length(self.dx, self.dy)
-		
+
 		self.angle = math_approachAngle(self.angle, moveAngle - half_pi, math_pi * moveSpeed / 30 * time)
-		
+
 		local diff = math_angleDifference(0, self.angle)
-		
+
 		self.dy = self.dy - self.dy * time * self.airFriction
 		self.dx = self.dx - self.dx * time * self.airFriction + -math_sin(diff) * self.dy * time * 16
-		
+
 		if self.allowPhysicsManipulation then
-			self:setAngleSpeed(-math_sin(diff) * self.dy * time * 16 - self.airFriction * time * self.map.physics:getEntityAngleSpeed(self.body) / math_pi)
+			self:setAngleSpeed(-math_sin(diff) * self.dy * time * 16 -
+			self.airFriction * time * self.map.physics:getEntityAngleSpeed(self.body) / math_pi)
 		end
 	end
-	
+
 	if self.angleDamping and self.allowPhysicsManipulation then
 		local speed = self.map.physics:getEntityAngleSpeed(self.body)
-		
+
 		self:setAngleSpeed(math_approach(speed, 0, self.angleDamping * time))
 	end
 end
@@ -5647,35 +5672,36 @@
 
 local function debrisRender(self, x, y, r, g, b)
 	if self._remove then
-		return 
+		return
 	end
-	
+
 	local offsets = self.offsets
 	local flipped = self.flipped
 	local offAngle = flipped and offsets.spriteOffsetAngleFlipped or offsets.spriteOffsetAngle
 	local offDist = flipped and offsets.spriteOffsetFlipped or offsets.spriteOffset
-	
+
 	if self.red then
 		r = r * self.red
 		g = g * self.green
 		b = b * self.blue
 	end
-	
+
 	if self.glowTimer then
 		r, g, b = self:getGlowColor(r, g, b)
 	end
-	
-	video.renderSpriteState(self.sprite, x + math_cos(offAngle + self.angle) * offDist, y + math_sin(offAngle + self.angle) * offDist, 1, self.angle, 255 * self.fade, r, g, b, flipped)
+
+	video.renderSpriteState(self.sprite, x + math_cos(offAngle + self.angle) * offDist,
+		y + math_sin(offAngle + self.angle) * offDist, 1, self.angle, 255 * self.fade, r, g, b, flipped)
 end
 
 local function debrisCollision(self, impact)
 	if impact.impulse > 10 then
 		self:hitSound(impact)
 	end
-	
+
 	local x = impact.x or self.x
 	local x, y = x, impact.y or self.y
-	
+
 	self.groundAngle = impact.angle
 end
 
@@ -5686,7 +5712,7 @@
 		self.dx = 0
 		self.dy = 0
 		self.angle = self.owner.aimAngle + self.owner.rig.rightHand.a * facingToFlipFactor(self.owner.facingRight)
-		
+
 		self.map:setEntityPosition(self.body, self.x, self.y)
 	else
 		self:remove()
@@ -5696,16 +5722,16 @@
 local function itemObjectInit(self)
 	self.bounces = self.bounces or 0
 	self.pickupableTimer = self.pickupableTimer or 0
-	
+
 	self:setPickupable(self.pickupable or false)
-	
+
 	self.pickupDelay = self.pickupDelay or 0
-	
+
 	if self.allowPickup == nil then
 		self.allowPickup = true
 		self.isPickupable = self:getIsPickupable()
 	end
-	
+
 	self.collisionBeforePickup = self.collisionBeforePickup or false
 end
 
@@ -5717,17 +5743,17 @@
 
 local function itemObjectOnAdded(self)
 	local itemRef = self.itemRef
-	
+
 	if not itemRef then
 		D.p(1, "items", self.type .. " lacks itemref")
 		self.map:declassifyAll(self)
 		self:remove()
-		
-		return 
+
+		return
 	end
-	
+
 	itemRef:objectified(self)
-	
+
 	if self.isPickupable then
 		self:classify("pickup")
 	end
@@ -5735,9 +5761,9 @@
 
 function Object:setUid(uid)
 	self.uid = uid
-	
+
 	local itemRef = self.itemRef
-	
+
 	if itemRef then
 		itemRef.uid = uid
 	end
@@ -5749,7 +5775,7 @@
 
 local function itemObjectArmedUpdate(self, time)
 	local itemRef = self.itemRef
-	
+
 	if not itemRef.armed then
 		self:declassify("armedUpdate")
 	else
@@ -5759,7 +5785,7 @@
 
 local function itemObjectRenderUpdate(self, time)
 	local itemRef = self.itemRef
-	
+
 	if itemRef.fragile and not itemRef.repaired and math_random() < time * 2 and self:isInView(200) then
 		if math_random() > 0.8 then
 			self:emitFx("itemFragileBigSpark")
@@ -5768,10 +5794,10 @@
 			self:emitFx("itemFragileSpark")
 		end
 	end
-	
+
 	if self.isPickupable and self.highlightPickup then
 		self.pickupableShine = math_min(1, self.pickupableShine + time / 0.1)
-		
+
 		if self.pickupableShine >= 1 then
 			self.highlightPickup = nil
 		end
@@ -5786,16 +5812,16 @@
 local function itemObjectUpdateHusk(self, time)
 	local itemRef = self.itemRef
 	local ouh = itemRef.def.asObjectUpdateHusk
-	
+
 	if ouh then
 		ouh(itemRef, self, time)
 	end
-	
+
 	self.time = self.time + time
-	
+
 	if self.blockSensorTimer then
 		self.blockSensorTimer = self.blockSensorTimer - time
-		
+
 		if self.blockSensorTimer <= 0 then
 			self.blockSensorTimer = nil
 		end
@@ -5804,49 +5830,49 @@
 
 local function itemObjectUpdate(self, time)
 	self.time = self.time + time
-	
+
 	local itemRef = self.itemRef
 	local idef = itemRef.def
-	
+
 	if idef.asObjectUpdate then
 		idef.asObjectUpdate(itemRef, self, time)
 	end
-	
+
 	if not self.def.box2dControlled and self.onGround and not self.isSleeping then
 		self:stopSpeed(self.groundAngle, time, idef.asObjectFriction or 4)
 	end
-	
+
 	if self.tryingToPickup then
 		self.pickupDelay = self.pickupDelay + time
 		self.tryingToPickup = false
 	elseif self.pickupDelay > 0 then
 		self.pickupDelay = math_max(0, self.pickupDelay - time)
 	end
-	
+
 	if self.blinkTimer > 0 then
 		self.blinkTimer = math_max(0, self.blinkTimer - time)
 	end
-	
+
 	if self.blockSensorTimer then
 		self.blockSensorTimer = self.blockSensorTimer - time
-		
+
 		if self.blockSensorTimer <= 0 then
 			self.blockSensorTimer = nil
 		end
 	end
-	
+
 	if self.hitActive and self.allowPickup then
 		self.collisionBeforePickup = true
 	end
-	
+
 	if self.pickupableTimer > 0 then
 		self.pickupableTimer = math_max(0, self.pickupableTimer - time)
 	end
-	
+
 	if self.pickupableTimer <= 0 and not self.pickupable and not self.pickupableBlockedUntilClear and not self.collisionBeforePickup and self.pickupableTimer <= 0 and self.allowPickup and itemRef and (not itemRef.hitActive or self.autoPickup) then
 		self:setPickupable(true)
 	end
-	
+
 	if self.sensor then
 		self.sensor = false
 	elseif self.pickupableBlockedUntilClear then
@@ -5856,26 +5882,26 @@
 
 local function itemObjectSensor(self, sensor, time)
 	if self.blockSensorTimer then
-		return 
+		return
 	end
-	
+
 	local itemRef = self.itemRef
 	local aos = itemRef.def.asObjectSensor
-	
+
 	if aos then
 		aos(self, sensor)
 	end
-	
+
 	local target = sensor.target
-	
+
 	if target and target._category == "actor" then
 		self.sensor = true
-		
+
 		local ignore = self.ignore
-		
+
 		if itemRef.hitActive and (not ignore or ignore ~= target and ignore.team ~= target.team) then
 			local aohs = itemRef.def.asObjectHitSensor
-			
+
 			if aohs then
 				aohs(self, sensor)
 			end
@@ -5883,12 +5909,12 @@
 			self:offerSelf(target)
 		end
 	end
-	
+
 	if target and target._category == "tile" and not target.blockUpdate then
 		sensor.owner = target
 		sensor.target = self
 		sensor.id = self.body
-		
+
 		target:onSensor(sensor, time)
 	end
 end
@@ -5896,53 +5922,59 @@
 local function itemObjectCollision(self, impact)
 	if (impact.impulse > 1 or self.itemRef.hitActive) and self:hitSound(impact) and self.itemRef and self.itemRef.def.bounceSound then
 		local vol = self:getImpactVolume(impact, 2)
-		
+
 		if vol > 0.05 then
 			self:emitSound(self.itemRef.def.bounceSound, vol, 1)
 		end
 	end
-	
+
 	if self.allowPickup and not self.isPickupable and self.pickupableTimer and self.pickupableTimer <= 0 then
 		self:setPickupTimer(0.05)
 	end
-	
+
 	self.collisionBeforePickup = false
-	
+
 	local item_def = self.itemRef.def
 	local coll = item_def.asObjectCollision
-	
+
 	if coll then
 		coll(self, impact)
 	elseif not item_def.asObjectHitSensor and self.hitActive then
 		self:disableHit()
 	end
-	
+
 	local x = impact.x or self.x
 	local x, y = x, impact.y or self.y
-	
+
 	self.groundAngle = math_angleBetweenPoints(0, 0, impact.nx, impact.ny)
 end
 
 local function itemObjectLightMapRender(self, x, y, r, g, b)
 	local item = self.itemRef
-	
+
 	if item then
 		local idef = item.def
-		
+
 		if self.isPickupable and self.pickupableShine > 0 then
 			local shine = self.pickupableShine
-			
+
 			if item.fragile and not item.repaired then
-				video.renderSpriteState(FX.itemShine.sprite, x, y, 0.5 * math_max(0, shine + 0.15 * math_cos(self.time + (_time + item.countId / 10) * 0.8 * math_pi) * shine), 0, 192 * shine, 255, 64, 64)
+				video.renderSpriteState(FX.itemShine.sprite, x, y,
+					0.5 * math_max(0, shine + 0.15 * math_cos(self.time + (_time + item.countId / 10) * 0.8 * math_pi) * shine), 0,
+					192 * shine, 255, 64, 64)
 			elseif idef.legend then
-				video.renderSpriteState(FX.itemShine.sprite, x, y, 3.2 * shine + 0.05 * math_cos(self.time * 4 + (_time + item.countId / 10) * 0.8 * math_pi) * shine, 0, 255 * shine / 10, 255, 234.60000000000002, 216.75)
+				video.renderSpriteState(FX.itemShine.sprite, x, y,
+					3.2 * shine + 0.05 * math_cos(self.time * 4 + (_time + item.countId / 10) * 0.8 * math_pi) * shine, 0,
+					255 * shine / 10, 255, 234.60000000000002, 216.75)
 			elseif idef.weapon then
 				local sh = self.autoPickup and 30 or 0.8
-				
-				video.renderSpriteState(FX.itemShine.sprite, x, y, 0.5 * math_max(0, 1 * shine + 0.15 * math_cos(self.time + (_time + item.countId / 10) * 1 * math_pi) * shine), 0, shine * 64, 255, 255, 229.5)
+
+				video.renderSpriteState(FX.itemShine.sprite, x, y,
+					0.5 * math_max(0, 1 * shine + 0.15 * math_cos(self.time + (_time + item.countId / 10) * 1 * math_pi) * shine),
+					0, shine * 64, 255, 255, 229.5)
 			end
 		end
-		
+
 		if idef.lightMapRenderMethod then
 			idef.lightMapRenderMethod(item, self, x, y, self.angle, not self.flipped)
 		end
@@ -5951,59 +5983,72 @@
 
 local function itemObjectRender(self, x, y, r, g, b)
 	local item = self.itemRef
-	
+
 	if not item then
-		return 
+		return
 	end
-	
+
 	local idef = item.def
-	
+
 	if self.isPickupable and self.pickupableShine > 0 and idef.legend then
 		local sprite = FX.itemShineWide.sprite
 		local shine = self.pickupableShine
 		local my_time = self.time
 		local count_id = item.countId
 		local count_offset = (_time + count_id / 10) * 0.8 * math_pi
-		
-		video.renderSpriteState(sprite, x, y, 1.2 * shine + 0.05 * math_cos(my_time * 4 + count_offset) * shine, 0.05 * math_cos(my_time * 4 + count_offset) * shine * math_pi * 0.4 - math_pi * 0.25, 255 * shine / 10, 255, 234.60000000000002, 216.75)
-		video.renderSpriteState(sprite, x, y, 1.2 * shine + 0.05 * math_cos(my_time * 4 + count_offset) * shine, -0.05 * math_cos(my_time * 4 + count_offset) * shine * math_pi * 0.4 + math_pi * 0.25, 255 * shine / 10, 255, 234.60000000000002, 216.75)
+
+		video.renderSpriteState(sprite, x, y, 1.2 * shine + 0.05 * math_cos(my_time * 4 + count_offset) * shine,
+			0.05 * math_cos(my_time * 4 + count_offset) * shine * math_pi * 0.4 - math_pi * 0.25, 255 * shine / 10, 255,
+			234.60000000000002, 216.75)
+		video.renderSpriteState(sprite, x, y, 1.2 * shine + 0.05 * math_cos(my_time * 4 + count_offset) * shine,
+			-0.05 * math_cos(my_time * 4 + count_offset) * shine * math_pi * 0.4 + math_pi * 0.25, 255 * shine / 10, 255,
+			234.60000000000002, 216.75)
 	end
-	
+
 	if self.blinkTimer and self.blinkTimer > 0 then
 		local blink = math_abs(math_cos(math_seededRandomNumber(item.countId) * math_pi * 2 + self.time * 8))
 		local amt = math_min(1, self.blinkTimer * 4)
-		
-		r, g, b = math_max(r * 0.5, r * (1 - amt) + blink * 255 * amt), math_max(g * 0.5, g * (1 - amt) + blink * 255 * amt), math_max(b * 0.5, b * (1 - amt) + blink * 255 * amt)
+
+		r, g, b = math_max(r * 0.5, r * (1 - amt) + blink * 255 * amt), math_max(g * 0.5, g * (1 - amt) + blink * 255 * amt),
+				math_max(b * 0.5, b * (1 - amt) + blink * 255 * amt)
 	end
-	
+
 	if self.highlighted then
 		local high = math_min(1, self.highlighted)
-		
+
 		r = r * (1 - high) + 255 * high
 		g = g * (1 - high) + 255 * high
 		b = b * (1 - high) + 255 * high
 	end
-	
+
 	local offsets = self.def.offsets
-	
+
 	if offsets then
 		local flipped = self.flipped
 		local offAngle = flipped and offsets.spriteOffsetAngleFlipped or offsets.spriteOffsetAngle
 		local offDist = flipped and offsets.spriteOffsetFlipped or offsets.spriteOffset
 		local numStack = item:getStack()
-		
+
 		if numStack > 1 then
-			item:renderStack(math_min(5, numStack), x + math_cos(offAngle + self.angle) * offDist, y + math_sin(offAngle + self.angle) * offDist, self.angle, r, g, b, not self.flipped)
-			video.renderTextSprites(numStack, x, y - 30, 1, "small", self.pickupableShine * 170 - 64 * math_cos(self.time + (_time + item.countId / 10) * 0.8 * math_pi) * self.pickupableShine, TINTS.orange.r * 255, TINTS.orange.g * 255, 128 * TINTS.orange.b)
+			item:renderStack(math_min(5, numStack), x + math_cos(offAngle + self.angle) * offDist,
+				y + math_sin(offAngle + self.angle) * offDist, self.angle, r, g, b, not self.flipped)
+			video.renderTextSprites(numStack, x, y - 30, 1, "small",
+				self.pickupableShine * 170 -
+				64 * math_cos(self.time + (_time + item.countId / 10) * 0.8 * math_pi) * self.pickupableShine,
+				TINTS.orange.r * 255, TINTS.orange.g * 255, 128 * TINTS.orange.b)
 		else
-			item:render(x + math_cos(offAngle + self.angle) * offDist, y + math_sin(offAngle + self.angle) * offDist, self.angle, r, g, b, not self.flipped)
+			item:render(x + math_cos(offAngle + self.angle) * offDist, y + math_sin(offAngle + self.angle) * offDist,
+				self.angle, r, g, b, not self.flipped)
 		end
 	else
 		local numStack = item:getStack()
-		
+
 		if numStack > 1 then
 			item:renderStack(tostring(math_min(5, numStack)), x, y, self.angle, r, g, b, not self.flipped)
-			video.renderTextSprites(tostring(numStack), x, y - 30, 1, "small", self.pickupableShine * 170 - 64 * math_cos(self.time + (_time + item.countId / 10) * 0.8 * math_pi) * self.pickupableShine, 255 * TINTS.orange.r, 255 * TINTS.orange.g, 128 * TINTS.orange.b)
+			video.renderTextSprites(tostring(numStack), x, y - 30, 1, "small",
+				self.pickupableShine * 170 -
+				64 * math_cos(self.time + (_time + item.countId / 10) * 0.8 * math_pi) * self.pickupableShine,
+				255 * TINTS.orange.r, 255 * TINTS.orange.g, 128 * TINTS.orange.b)
 		else
 			item:render(x, y, self.angle, r, g, b, not self.flipped)
 		end
@@ -6012,18 +6057,18 @@
 
 local function itemObjectHit(self, impact, attack)
 	local aos = self.itemRef.def.asObjectHit
-	
+
 	if aos then
 		return aos(self, impact, attack)
 	end
-	
+
 	return false
 end
 
 local function itemObjectReaction(self, impact)
 	local itemRef = self.itemRef
 	local aos = itemRef.def.asObjectReaction
-	
+
 	if aos then
 		return aos(self, impact, itemRef)
 	end
@@ -6032,7 +6077,7 @@
 local function itemObjectEmitReaction(self, angle)
 	local itemRef = self.itemRef
 	local aos = itemRef.def.asObjectEmitReaction
-	
+
 	if aos then
 		return aos(self, angle, itemRef)
 	end
@@ -6041,17 +6086,17 @@
 function Object:offerSelf(target)
 	if not self._remove then
 		local itemRef = self.itemRef
-		
+
 		target:handleItemPickup(itemRef, self)
 	end
 end
 
 local function itemObjectChangedOwner(self, owner, old_owner)
 	local itemRef = self.itemRef
-	
+
 	if itemRef then
 		local method = itemRef.def.asObjectChangedOwner
-		
+
 		if method then
 			method(itemRef, self, owner, old_owner)
 		end
@@ -6060,11 +6105,11 @@
 
 local function genericFallingObjectUpdate(self, time)
 	self.time = self.time + time
-	
+
 	local gravity = 50
-	
+
 	self.dy = self.dy + gravity * time
-	
+
 	if self.lifeTime and self.time > self.lifeTime then
 		self:remove()
 	end
@@ -6072,22 +6117,23 @@
 
 local function dropKill(self, impact)
 	self:emitSound(self.def.killSound, 1, 1, 200)
-	
+
 	local speed = math_length(self.dx, self.dy)
 	local x
-	
+
 	if impact then
 		x = impact.x or self.x
-		
+
 		local x, y = x, impact.y or self.y
-		
+
 		for i = 1, 4 + math_random(5) do
 			local fx = self:emitFxAt(self.def.killFx, x, y)
-			
-			fx:setSpeed(impact.angle + math_pi + math_random() * 0.5 * math_pi - math_random() * 0.5 * math_pi, (math_random(speed / self.map.resolution + 1) - 1) / 8 + speed / self.map.resolution / 4)
+
+			fx:setSpeed(impact.angle + math_pi + math_random() * 0.5 * math_pi - math_random() * 0.5 * math_pi,
+				(math_random(speed / self.map.resolution + 1) - 1) / 8 + speed / self.map.resolution / 4)
 		end
 	end
-	
+
 	self:remove()
 end
 
@@ -6161,16 +6207,16 @@
 
 local function itemResponsibleActorChanged(object)
 	local resp = object:getResponsibleActor()
-	
+
 	if resp ~= object.last_responsible then
 		local itemRef = object.itemRef
-		
+
 		if itemRef then
 			local method = itemRef.def.asObjectResponsibleActorChangedMethod
-			
+
 			method(itemRef, object, resp, object.last_responsible)
 		end
-		
+
 		object.last_responsible = resp
 	end
 end
@@ -6180,53 +6226,53 @@
 	local smart_path = assetPath .. "/itemSpriteOffsets.ids"
 	local ITEM_SPRITE_OFFSETS = assert(table.load(smart_path), "failed to load item offsets")
 	local any_sprite = false
-	
+
 	for index, item in pairs(ITEMS) do
 		local def = OBJECTS[index]
-		
+
 		def.network = item.network or {
 			sync_method = "game_object",
 			sync = true
 		}
 		def.density = 1.75
-		
+
 		if item.explosive then
 			def.omniThreat = true
 		end
-		
+
 		for index, field in pairs(ITEM_TO_OBJECT_FIELDS) do
 			def[field] = item[field]
 		end
-		
+
 		if item.getObjectBulletTimeFactor then
 			def.getBulletTimeFactor = item.getObjectBulletTimeFactor
 		end
-		
-		if def._generated_from_item then
+
+		if def._generated_from_item and not def.classifications then
 			for index, value in pairs(itemObjectTemplate) do
 				def[index] = value
 			end
-			
+
 			def.visualReactionMethod = item.asObjectVisualReactionMethod
 			def.performVisualFeedbackMethod = item.asObjectVisualFeedbackMethod
-			
+
 			if item.asObjectResponsibleActorChangedMethod then
 				def.onAffectedByChangedMethod = itemResponsibleActorChanged
 			end
-			
+
 			def.id = index
 			def.neverIdle = item.neverIdle
-			
+
 			if item.noFilter then
 				def.noFilter = true
 			end
-			
+
 			def.destroyMethod = item.asObjectDestroy
-			
+
 			assert(not def.classifications)
-			
+
 			def.classifications = item.classifications
-			
+
 			if item.asObjectPhysics then
 				def.physics = item.asObjectPhysics
 			elseif item.spriteName then
@@ -6235,26 +6281,26 @@
 				else
 					assert(RENDERING, "can't generateItemDefs when rendering is disabled!")
 					sprites.requireDefsKey(SPRITE_BOOKER, ITEMS, index)
-					
+
 					any_sprite = true
-					
+
 					assert(item.sprite and item.sprite >= 0, "item refers to invalid sprite", index)
-					
+
 					item.offsets = sprites.generateOffsets(item.sprite)
 					ITEM_SPRITE_OFFSETS[index] = item.offsets
 				end
-				
+
 				if item.offsets then
 					def.physics = sprites.generateItemPhysics(item.offsets, item)
 				end
 			end
 		end
 	end
-	
+
 	if any_sprite then
 		sprites.releaseAll(SPRITE_BOOKER)
 	end
-	
+
 	if not BITSQUID and app.developerMode then
 		local success, msg = table.save(ITEM_SPRITE_OFFSETS, smart_path)
 	end
@@ -6263,9 +6309,9 @@
 local function generateItemDefs()
 	for index, item in pairs(ITEMS) do
 		local def = OBJECTS[index] or {}
-		
+
 		def.itemRefIndex = index
-		
+
 		if not OBJECTS[index] then
 			OBJECTS[index] = def
 			def._generated_from_item = index
@@ -6279,37 +6325,37 @@
 	local l, t, r, b = self.def.bounds:getBoundingBox(self.scale or 1, self.angle or 0, self.flipped)
 	local w = def.visual_padding_w or 15
 	local w, h = w, def.visual_padding_h or 4
-	
+
 	return l - w * 0.5, t - h * 0.5, r + w * 0.5, b + h * 0.5
 end
 
 function Object:getBoundingBox()
 	local l, t, r, b = self.def.bounds:getBoundingBox(self.scale or 1, self.angle or 0, self.flipped)
-	
+
 	return self.x + l, self.y + t, self.x + r, self.y + b
 end
 
 function Object:getGroundSpacing()
 	local bounds = self.def.bounds
-	
+
 	return bounds.b
 end
 
 function spawnStarGuardShrapnel(x, y, map, collisionId, count)
 	for i = 1, count do
 		local obj = map:addObject(Object:newSpark(x, y - 32, map, "starGuardSmallDebris"), collisionId)
-		
+
 		obj:setSpeed(math_random() * -math_pi, 4 + math_random() * 20)
-		
+
 		obj.time = 0
 		obj.airFriction = 0
 		obj.gravity = 28
 		obj.dieOnCollision = true
-		
+
 		if math_random(1, 3) == 1 then
 			obj.deathFxName = "starGuardSmallExplosion"
 		end
-		
+
 		map.physics:setEntityAngleSpeed(obj.body, math_random() * 4 * math_pi - math_random() * 4 * math_pi)
 	end
 end
@@ -6317,7 +6363,7 @@
 local function grenadeObjectInit(self)
 	self.blinkTimer = self.blinkTimer or 0
 	self.beepToggle = self.beepToggle or false
-	
+
 	self:emitSound("grenadeArm", 1, 1)
 end
 
@@ -6348,7 +6394,8 @@
 	},
 	renderMethod = function(self, x, y, r, g, b)
 		if self.proximity then
-			video.renderSpriteState(self.def.customSprites.proxy, x, y, 1, self.angle, 255, r, g * 0.25, b * 0.25, self.flipped)
+			video.renderSpriteState(self.def.customSprites.proxy, x, y, 1, self.angle, 255, r, g * 0.25, b * 0.25, self
+			.flipped)
 			video.renderSpriteState(self.def.customSprites.proxyLight, x, y, 1, self.angle, 255, 255, 255, 255, self.flipped)
 		else
 			video.renderSpriteState(self.def.sprite, x, y, 1, self.angle, 255, r, g, b, self.flipped)
@@ -6358,11 +6405,11 @@
 	getBulletTimeFactor = function(self)
 		if self.proximity then
 			local prg = self.time / self.lifeTime
-			
+
 			return 0.6 + 0.1 * prg * prg * prg
 		else
 			local prg = self.time / self.lifeTime
-			
+
 			return 0.1 + 0.6 * prg * prg * prg
 		end
 	end,
@@ -6403,38 +6450,38 @@
 
 local function megaShardObjectInit(self)
 	self.blinkTimer = self.blinkTimer or 0
-	
+
 	local fx = self:emitFx("megaFlame")
-	
+
 	fx:setReference(self)
-	
+
 	self.smokeCap = self.smokeCap or 0.5
 end
 
 local function megaShardObjectCollisionMethod(self, impact)
 	local detail = _config.graphicsFx
-	
+
 	if self.smokeCap * (0.2 + 0.8 * detail) <= math_random() then
 		local origMoveAng = math_angleBetweenPoints(0, 0, self.dx, self.dy)
 		local ang = impact.angle + math_pi + math_random() * half_pi - math_random() * half_pi
 		local dist = math_random() * 200 - math_random() * 100
 		local fx = self:emitFxAt("fire", self.x + math_cos(ang) * dist, self.y + math_sin(ang) * dist)
 		local moveAng = origMoveAng + math_random() * math_pi * 0.25 - math_random() * math_pi * 0.25
-		
+
 		fx:setSpeed(moveAng, dist * 6 + 30)
-		
+
 		if self.fluidType and DEFS.FLUIDS[self.fluidType].onExplosion then
 			DEFS.FLUIDS[self.fluidType].onExplosion(self, 1)
 		elseif math_random() > 0.75 then
 			local fx = self:emitFxAt("fireSmoke", self.x + math_cos(ang) * dist, self.y + math_sin(ang) * dist)
-			
+
 			fx:setSpeed(moveAng, dist * 2 + 10)
 		else
 			local fx = self:emitFxAt("fireSmokeBig", self.x + math_cos(ang) * dist, self.y + math_sin(ang) * dist)
-			
+
 			fx:setSpeed(moveAng, dist * 2 + 10)
 		end
-		
+
 		self.smokeCap = self.smokeCap + 0.5
 	end
 end
@@ -6442,9 +6489,9 @@
 local function megaShardSensor(self, impact, time)
 	if impact.target and impact.target._category == "actor" and not impact.target:isBeaten() then
 		local speed = self:getSpeed()
-		
+
 		impact.damageModifier = time * self:getSpeed() / 50
-		
+
 		impact.target:addSpeed(self:getSpeedAngle(), speed * time * 3)
 		impact.target:gripless(1)
 		impact.target:hit(impact, self:getAttack())
@@ -6453,23 +6500,23 @@
 
 local function megaLightMapRender(self, x, y)
 	local color = COLORS.fireHigh
-	local op = self.opacity^0.5
+	local op = self.opacity ^ 0.5
 	local ca, cr, cg, cb = color.a, color.r * op, color.g * op, color.b * op
-	
+
 	video.renderAdditiveSpriteState(FX.glow.sprite, x, y, 2, self.angle, cr, cg, cb, self.flipped)
 end
 
 local function megaUpdate(self, time)
 	self.time = self.time + time
-	
+
 	self:stopSpeedXY(1, 1, time)
-	
+
 	self.smokeCap = math_max(0, self.smokeCap - time * 5)
-	
+
 	local prg = 1 - math.clamp(self.time / (self.lifeTime or 1), 0, 1)
-	
+
 	self.opacity = prg
-	
+
 	if self.lifeTime and self.time > self.lifeTime then
 		self:remove()
 	end
@@ -6497,13 +6544,13 @@
 	end,
 	collisionMethod = function(self, impact)
 		megaShardObjectCollisionMethod(self, impact)
-		
+
 		if impact.target._category == "tile" then
 			impact.damageModifier = math_min(self:getSpeed() / 5)
-			
+
 			impact.target:hit(impact, ATTACKS.tileShockwave)
 		end
-		
+
 		self:bounceWithVector(impact.angle, 0.1)
 	end,
 	sensorMethod = megaShardSensor,
@@ -6741,38 +6788,39 @@
 	local def = self.def
 	local color = self.color
 	local ca, cr, cg, cb = color.a, color.r, color.g, color.b
-	
+
 	video.renderSpriteState(def.sprite, x, y, 1, self.angle, 255, light * cr, light * cg, light * cb, self.flipped)
-	
+
 	local lastx = self.lx
-	
+
 	if lastx then
 		local lx, ly = x - self.x + lastx, y - self.y + self.ly
 		local op = self.opacity
 		local trail_width = def.trail_width
 		local tint = def.trail_tint
-		
-		video.renderSpriteLine(lx, ly, x, y, tint.a * ca * op, tint.r * cr * op, tint.g * cg * op, tint.b * cb * op, SPRITES.lineLaserAdditive, true, trail_width)
+
+		video.renderSpriteLine(lx, ly, x, y, tint.a * ca * op, tint.r * cr * op, tint.g * cg * op, tint.b * cb * op,
+			SPRITES.lineLaserAdditive, true, trail_width)
 	end
 end
 
 local function genericLaserBulletLightMapRender(self, x, y)
 	local color = self.color
 	local ca, cr, cg, cb = color.a, color.r, color.g, color.b
-	
+
 	video.renderAdditiveSpriteState(FX.glow.sprite, x, y, 0.25, self.angle, cr, cg, cb, self.flipped)
 end
 
 local function genericLaserBulletRuntime(self)
 	local def = self.def
-	
+
 	self.opacity = 1
 	self.light = 1
-	
+
 	if def.glowerFx and self.map and not self.prediction then
 		self.fx = self:emitFx(def.glowerFx)
 	end
-	
+
 	self.lx = self.lx or self.x
 	self.ly = self.ly or self.y
 end
@@ -6782,27 +6830,27 @@
 	local lifeTime = self.lifeTime
 	local prg = 0.7 + 0.3 * (1 - math_max(0, totalTime) / lifeTime)
 	local fx = self.fx
-	
+
 	if fx then
 		fx:setPosition(self.x, self.y)
 	end
-	
+
 	self.opacity = math_clamp(prg, 0.1, 1)
-	
+
 	local sp = math_max(self.timeFactor, 0.01)
 	local lx = self.lx
 	local ly = self.ly
 	local x = self.x
 	local y = self.y
 	local speed_time = time * 15 / sp
-	
+
 	self.lx = math_approach(lx, x, speed_time + math_difference(lx, x) * speed_time)
 	self.ly = math_approach(ly, y, speed_time + math_difference(ly, y) * speed_time)
 end
 
 local function genericLaserBulletUpdate(self, time)
 	self.time = self.time + time
-	
+
 	if self.lifeTime and self.time > self.lifeTime then
 		self:performExpireReaction()
 	end
@@ -6812,40 +6860,40 @@
 	local def = self.def
 	local color = self.color or self.def.color or COLORS.white
 	local fx = self:emitFx(def.cloudFx or "laserCloud")
-	
+
 	fx:setAngle(self.angle)
 	fx:applyColor(color)
-	
+
 	local detail = _config.graphicsFx
-	
+
 	if detail > 0 then
 		for i = 1, math_random(1, 2) * (def.deathSparksFactor or 1) * detail do
 			local obj = self:emitSpark(def.sparkFx or "redSpark")
-			
+
 			obj:setSpeed(self.angle, (4 + math_random() * 20) * (def.deathSparksFactor or 1))
 			obj:addSpeed(math_random() * math_pi * 2, math_random() * 10)
-			
+
 			obj.airFriction = 0
 			obj.gravity = 28
 			obj.dieOnCollision = true
 			obj.deathFxName = "postTinySpark"
 			obj.collisionSound = "fizzleSpark"
 			obj.dieSound = "fizzle"
-			
+
 			local fx = obj.myFx
-			
+
 			if fx then
 				fx:applyColor(color)
 			end
 		end
 	end
-	
+
 	local dieSound = def.dieSound
-	
+
 	if dieSound then
 		self:emitSound(dieSound, def.soundVolume or 1, 1 * (self.soundMod or 1), 400)
 	end
-	
+
 	if self.fx then
 		self.fx:remove()
 	end
@@ -6855,49 +6903,50 @@
 	local def = self.def
 	local color = self.color or def.color or COLORS.white
 	local fx = self:emitFxAt(def.cloudFx or "laserCloudWhite", x, y)
-	
+
 	fx.angle = self.angle
-	
+
 	fx:applyColor(color)
-	
+
 	local fx = self:emitFxAt(def.glowFx or "laserGlowWhite", x, y)
-	
+
 	fx.angle = self.angle
-	
+
 	fx:applyColor(color)
-	
+
 	local detail = _config.graphicsFx
-	
+
 	if detail > 0 then
 		local sparkfx = def.sparkFx
-		
+
 		if sparkfx then
 			for i = 1, math_random(2, 4) * (def.deathSparksFactor or 1) * detail do
 				local obj = self:emitSparkAt(def.sparkFx, x, y)
-				
-				obj:setSpeed(angle + math_pi + math_random() * 0.5 * math_pi - math_random() * 0.5 * math_pi, math_random(20) * (def.deathSparksFactor or 1))
+
+				obj:setSpeed(angle + math_pi + math_random() * 0.5 * math_pi - math_random() * 0.5 * math_pi,
+					math_random(20) * (def.deathSparksFactor or 1))
 				obj:setAngle(math_random() * math_pi * 2)
-				
+
 				obj.deathFxName = "postTinySpark"
 				obj.collisionSound = "fizzleSpark"
 				obj.dieSound = "fizzle"
 				obj.collisionTimeFactor = 10
-				
+
 				local fx = obj.myFx
-				
+
 				if fx then
 					fx:applyColor(color)
 				end
 			end
 		end
 	end
-	
+
 	local hitsound = def.hitSound
-	
+
 	if hitsound then
 		self:emitSound(hitsound, def.soundVolume or 1, 1 * (self.soundMod or 1), 400)
 	end
-	
+
 	if self.fx then
 		self.fx:remove()
 	end
@@ -6907,19 +6956,19 @@
 	local def = self.def
 	local attack = self:getAttack()
 	local hit, damage = impact.target:hit(impact, attack)
-	
+
 	if hit then
 		if damage then
 			self.damageLeft = self.damageLeft - damage / attack.overall_power * 2
 		end
-		
+
 		if self.damageLeft <= 0 then
 			local hf = def.hitSoundFactor
-			
+
 			if hf then
 				self:hitSound(impact, def.hitSoundFactor, def.hitSoundRangeFactor)
 			end
-			
+
 			self:performReaction(impact)
 		end
 	end
@@ -7610,14 +7659,14 @@
 	color = COLORS.object_chrono,
 	initRuntimeMethod = function(self)
 		genericLaserBulletRuntime(self)
-		
+
 		self.power = self.power or 1
 		self.hitActive = true
 	end,
 	updateRenderMethod = genericLaserBulletUpdateRender,
 	updateMethod = function(self, time)
 		self.time = self.time + time
-		
+
 		if self.hitActive then
 			if self.lifeTime and self.time > self.lifeTime then
 				self:disableHit()
@@ -7625,7 +7674,7 @@
 			end
 		else
 			self.power = self.power - time * 0.5
-			
+
 			if self.power <= 0 then
 				self:remove()
 			end
@@ -7638,33 +7687,33 @@
 		if self.hitActive then
 			self:disableHit()
 			self:performReaction(impact)
-			
+
 			return true
 		end
 	end,
 	collisionMethod = function(self, impact)
 		local def = self.def
-		
+
 		if self.hitActive then
 			self:disableHit()
-			
+
 			impact.damageModifier = self:getPowerDamageModifier(self.power)
-			
+
 			local attack = self:getAttack()
 			local hit, damage = impact.target:hit(impact, attack)
-			
+
 			if hit then
 				local target = impact.target
-				
+
 				if target and target._category == "actor" then
 					local fx = self:emitFx("chronoBulletHitGlow")
-					
+
 					self:emitOmniTimeFactor(RANGES.short * 0.5, 0.3, 1)
 				end
-				
+
 				self:hitSound(impact, def.hitSoundFactor, def.hitSoundRangeFactor)
 			end
-			
+
 			self:performReaction(impact)
 		end
 	end,
@@ -7675,7 +7724,7 @@
 		local control = def.bonus_speed_control
 		local factor = def.bonus_speed_reach_factor
 		local stop_factor = def.bonus_speed_stop_factor
-		
+
 		what:stopSpeedXY(stop_factor, stop_factor, 1)
 		what:reachSpeedVector(angle, speed * factor, control, 1)
 		what:addSpeed(angle, speed * (1 - factor))
@@ -7686,18 +7735,18 @@
 	visualReactionMethod = function(self, x, y, angle)
 		self:setSpeed(0, 0)
 		self:emitExplosion(self.def.explosion, self.def.explosionIntensity)
-		
+
 		local actor = self:getOriginalActor()
-		
+
 		actor = actor and actor:getBottomActor()
-		
+
 		if actor and actor:isAllowedToTeleport() and not actor:isChanging() and actor.map then
 			self:disableHit()
 			self:setSpeedXY(0, 0)
 			actor:teleportTo(self, 0.05, nil, nil, true)
-			
+
 			local fx = self:emitFxAt("chronoBolt", self.x, self.y)
-			
+
 			fx:setEnd(actor.x, actor.y)
 			actor:addSpeed(self:getAngle(), self.def.bonus_speed)
 			self:emitAnomaly(1)
@@ -7705,7 +7754,7 @@
 			self:disableHit()
 			self:remove()
 		end
-		
+
 		genericLaserBulletVisualReaction(self, x, y, angle)
 	end,
 	visualExpireMethod = genericLaserBulletVisualExpireReaction,
@@ -7742,17 +7791,17 @@
 local function genericLavaBallInit(self)
 	self.spawnTime = self.spawnTime or 1
 	self.boostTimer = self.boostTimer or 0
-	
+
 	self:setPower(1)
-	
+
 	if self.hitActive == nil then
 		self:setHitActive(true)
 	end
-	
+
 	if self.blockFluid == nil then
 		self.blockFluid = true
 	end
-	
+
 	self:emitSound("lavaBall", 1, 1.5, 120)
 end
 
@@ -7779,20 +7828,23 @@
 	},
 	renderMethod = function(self, x, y, r, g, b)
 		local amt = (1 - self.spawnTime) * (1 - self.spawnTime) * (1 - self.spawnTime)
-		
+
 		video.renderSpriteState(self.def.sprite, x, y, 1 * amt, self.angle, 255 * amt, r, g, b, self.flipped)
-		
+
 		if self.spawnTime > 0 then
 			local amt = math_max(0, 1 - self.spawnTime * self.spawnTime * self.spawnTime + (1 - self.spawnTime))
-			
-			video.renderAdditiveSpriteState(self.def.customSprites.lavaBallGlowAdditive, x, y, 1 * amt * 2, self.angle, 255 * amt, 255 * amt, 255 * amt, false)
+
+			video.renderAdditiveSpriteState(self.def.customSprites.lavaBallGlowAdditive, x, y, 1 * amt * 2, self.angle,
+				255 * amt, 255 * amt, 255 * amt, false)
 		end
 	end,
 	lightMapRenderMethod = function(self, x, y)
 		local amt = 0.2 + math_abs(0.8 * math_cos(self.time * 44.5 * math_pi) * math_sin(self.time * 87.11 * math_pi))
-		
-		video.renderAdditiveSpriteState(self.def.customSprites.lavaBallGlowAdditive, x, y, 1, self.angle, 255 * amt, 255 * amt, 255 * amt, false)
-		video.renderAdditiveSpriteState(FX.glow.sprite, x, y, 0.35 + 0.25 * amt, self.angle, 255 * amt, 186 * amt, 32 * amt, false)
+
+		video.renderAdditiveSpriteState(self.def.customSprites.lavaBallGlowAdditive, x, y, 1, self.angle, 255 * amt,
+			255 * amt, 255 * amt, false)
+		video.renderAdditiveSpriteState(FX.glow.sprite, x, y, 0.35 + 0.25 * amt, self.angle, 255 * amt, 186 * amt, 32 * amt,
+			false)
 	end,
 	initMethod = genericLavaBallInit,
 	getGravity = function(self)
@@ -7806,29 +7858,31 @@
 		if fluid then
 			if self.power > 0 then
 				local detail = _config.graphicsFx
-				
+
 				self:setPower(self.power - 0.5)
-				
+
 				for i = 1, 1 + math_random(2, 5) * detail do
 					local f = self:emitFx("lavaSplashGlow")
-					
-					f:setSpeed(self.angle + math_pi + math_random() * 0.2 + math_random() * 0.2, math_random() * 100 - math_random() * 10)
+
+					f:setSpeed(self.angle + math_pi + math_random() * 0.2 + math_random() * 0.2,
+						math_random() * 100 - math_random() * 10)
 				end
-				
+
 				if detail > 0 then
 					for i = 1, math_random(1, 3) * detail do
 						local obj = self:emitSpark("lavaSpark")
-						
-						obj:setSpeed(self.angle + math_random() * math_pi * 1 - math_random() * math_pi * 1, self:getSpeed() * 0.75 + 0.5 * math_random())
+
+						obj:setSpeed(self.angle + math_random() * math_pi * 1 - math_random() * math_pi * 1,
+							self:getSpeed() * 0.75 + 0.5 * math_random())
 						obj:setLifeTime(2)
 						self.map.physics:setEntityAngleSpeed(obj.body, math_random() * 2 * math_pi - math_random() * 2 * math_pi)
 					end
 				end
-				
+
 				self:flashWhite(0.5)
 				self:addSpeedXY(0, -(15 + 20 * self.power))
 				self:emitSound("lavaBall", 1, 1.75, 120)
-				
+
 				return true
 			else
 				self:destroy()
@@ -7838,33 +7892,35 @@
 	updateMethod = function(self, time)
 		if self.spawnTime > 0 then
 			self.spawnTime = math_max(0, self.spawnTime - time / 0.5)
-			
+
 			if not self.oldSpeedDx then
 				self.oldSpeedDx = self.dx
 				self.oldSpeedDy = self.dy
 			end
-			
+
 			if self.spawnTime <= 0 then
 				self.boostTimer = 1
-				
+
 				self:setGravity(self:getGravity())
 				self:setSpeedXY(self.oldSpeedDx, self.oldSpeedDy)
 				self:addAngleSpeed(math_random() - math_random(), 20)
-				
+
 				if self:isInView(200) then
 					local detail = _config.graphicsFx
-					
+
 					for i = 1, 1 + math_random(2, 5) * detail do
 						local f = self:emitFx("lavaSplashGlow")
-						
-						f:setSpeed(self.angle + math_pi + math_random() * 0.2 + math_random() * 0.2, math_random() * 100 - math_random() * 10)
+
+						f:setSpeed(self.angle + math_pi + math_random() * 0.2 + math_random() * 0.2,
+							math_random() * 100 - math_random() * 10)
 					end
-					
+
 					if detail > 0 then
 						for i = 1, math_random(1, 3) * detail do
 							local obj = self:emitSpark("lavaSpark")
-							
-							obj:setSpeed(self.angle + math_random() * math_pi * 1 - math_random() * math_pi * 1, self:getSpeed() * 0.75 + 0.5 * math_random())
+
+							obj:setSpeed(self.angle + math_random() * math_pi * 1 - math_random() * math_pi * 1,
+								self:getSpeed() * 0.75 + 0.5 * math_random())
 							obj:setLifeTime(2)
 							self.map.physics:setEntityAngleSpeed(obj.body, math_random() * 2 * math_pi - math_random() * 2 * math_pi)
 						end
@@ -7877,18 +7933,18 @@
 			if self.blockFluid then
 				self:updateFluids(time)
 			end
-			
+
 			self.time = self.time + time
-			
+
 			if self.lifeTime and self.time > self.lifeTime then
 				self:setPower(0)
 				self:performReaction()
 			end
 		end
-		
+
 		if self.reactionDelay then
 			self.reactionDelay = self.reactionDelay - time
-			
+
 			if self.reactionDelay <= 0 then
 				self.reactionDelay = nil
 			end
@@ -7917,36 +7973,36 @@
 		if self.hitActive and impact.target and (impact.target._category == "tile" or impact.target._category == "actor") and genericCheckHit(self, impact, ATTACKS.lavaBall) then
 			self:hitSound(impact, 8)
 		end
-		
+
 		self:bounceWithVector(impact.angle, 0.75)
-		
+
 		if not self.reactionDelay then
 			self.reactionDelay = 0.1
-			
+
 			self:performReaction(impact)
 		end
 	end,
 	visualReactionMethod = function(self, x, y, angle)
 		if self:isInView(200) then
 			self:emitFxAt("spikeHitFlash", x, y)
-			
+
 			local f = self:emitFx("lavaHitGlow")
-			
+
 			f:setSpeed(math_randomAngle(), math_random() * 50)
-			
+
 			local detail = _config.graphicsFx
-			
+
 			if detail > 0 then
 				for i = 1, math_random(3, 7) * detail do
 					local obj = self:emitSpark("lavaSpark")
-					
+
 					obj:setSpeed(angle + math_random() * math_pi * 1 - math_random() * math_pi * 1, 2 + 12 * math_random())
 					obj:setLifeTime(2)
 					self.map.physics:setEntityAngleSpeed(obj.body, math_random() * 2 * math_pi - math_random() * 2 * math_pi)
 				end
 			end
 		end
-		
+
 		self:emitSound("lavaBallDie", 1, 1)
 	end,
 	render = {
@@ -7980,7 +8036,7 @@
 	if self.hitActive == nil then
 		self:setHitActive(true)
 	end
-	
+
 	self.soundLife = self.soundLife or math_random() * 0.1
 end
 
@@ -8013,17 +8069,17 @@
 	},
 	updateMethod = function(self, time)
 		self.time = self.time + time
-		
+
 		if self.soundLife and self.time > self.soundLife then
 			self:emitSound("spikeAttack", 1, 1 - self.soundLife, 120)
-			
+
 			self.soundLife = nil
 		end
-		
+
 		if self.lifeTime and self.time > self.lifeTime then
 			self:performReaction()
 		end
-		
+
 		if self.hitActive then
 			self:setAngle(math_approachAngle(self.angle, math_angleBetweenPoints(0, 0, self.dx, self.dy), time * math_pi * 2))
 		end
@@ -8033,7 +8089,7 @@
 	end,
 	collisionMethod = function(self, impact)
 		impact.damageModifier = self:getSpeedDamageModifier(self:getSpeed())
-		
+
 		if self.hitActive and genericCheckHit(self, impact, self:getAttack()) then
 			self:hitSound(impact, 8)
 			self:performReaction(impact)
@@ -8043,17 +8099,17 @@
 		if RENDERING then
 			self:emitFxAt("spikeHitFlash", x, y)
 			self:emitSound("spikeHit", 1, 1, 200)
-			
+
 			local obj = self:emitFxDebris("spikeDebris", 1)
-			
+
 			obj:setAngle(self.angle)
 			obj:setSpeed(math_random() * math_pi * 2, math_random() * 6 + 6)
 			obj:addSpeedXY(self.dx / 2, self.dy / 2)
 			obj:setLifeTime(15)
 			self.map.physics:setEntityAngleSpeed(obj.body, math_random() * 2 * math_pi - math_random() * 2 * math_pi)
-			
+
 			obj = self:emitFxDebris("spikeDebris", 2)
-			
+
 			obj:setAngle(self.angle)
 			obj:setSpeed(math_random() * math_pi * 2, math_random() * 6 + 6)
 			obj:addSpeedXY(self.dx / 2, self.dy / 2)
@@ -8088,7 +8144,7 @@
 	},
 	getBulletTimeFactor = function(self)
 		local s = self:getSpeed()
-		
+
 		return math_min(1, s / 57) * 0.55
 	end,
 	editor = {
@@ -8106,7 +8162,7 @@
 	if self.hitActive == nil then
 		self:setHitActive(true)
 	end
-	
+
 	self.damageLeft = 1
 end
 
@@ -8266,34 +8322,34 @@
 local function gyrojetBulletSplit(self, angle, power, spread)
 	for i = 1, 3 do
 		local obj = self:emitObject("gyroBulletPiece")
-		
+
 		obj:setSpeed(angle + spread * 0.5 - spread * 0.5 * (i - 1), power)
 		obj:setAngle(angle + spread * 0.5 - spread * 0.5 * (i - 1))
-		
+
 		obj.owner = self.owner
-		
+
 		if self.trailMakerFx then
 			obj.trailMakerFx = self:emitFx("gyroTinyTrailMaker")
-			
+
 			obj.trailMakerFx:setOwner(obj)
-			
+
 			obj.trailMakerFx.distanceMoved = 0
 			obj.trailMakerFx.lastX = self.trailMakerFx.x
 			obj.trailMakerFx.lastY = self.trailMakerFx.y
 			obj.trailMakerFx.trailFx = self.trailMakerFx.trailFx
 		end
 	end
-	
+
 	self:remove()
 end
 
 local function gyrojetbulletObjectUpdate(self, time)
 	self.time = self.time + time
-	
+
 	if not self.isSleeping then
 		if self.time < self.lifeTime then
 			local thrust = self:getLifeProgressAcceleration(self.thrust)
-			
+
 			self.dx = self.dx + time * math_cos(self.angle) * thrust
 			self.dy = self.dy + time * math_sin(self.angle) * thrust
 			self.thrust = math_min(1, self.thrust + time / self.lifeTime)
@@ -8302,67 +8358,67 @@
 			self.thrust = math_max(0, self.thrust - time * 2)
 		end
 	end
-	
+
 	if self.hitActive then
 		self:setAngleSpeed(0)
 		self:setAngle(math_approachAngle(self.angle, math_angleBetweenPoints(0, 0, self.dx, self.dy), math_pi * time))
-		
+
 		if not self.trailMakerFx then
 			self.trailMakerFx = self:emitOwnedFx("gyroTrailMaker")
 		end
-		
+
 		self.flameSound = math_min(self.flameSound + time * 10, 1)
 	else
 		self.flameSound = math_max(self.flameSound - time * 10, 0)
-		
+
 		if self.trailMakerFx then
 			self.trailMakerFx:remove()
-			
+
 			self.trailMakerFx = nil
 		end
 	end
-	
+
 	if self.trailMakerFx then
 		self.trailMakerFx:setPosition(self.x, self.y)
 	end
-	
+
 	if self.flameSound > 0 then
 		local vol = math_min(1, self.flameSound)
-		
+
 		self:emitLoop("gyroFlame", vol, math_max(0.2, self.flameSound * 1 + 1 - self.time * 5), RANGES.tiny * vol)
 	end
-	
+
 	if not self.isSleeping then
 		local friction = self:getFrictionFactor()
-		
+
 		self:stopSpeedXY(math_abs(self.dx) * friction, math_abs(self.dy) * friction, time)
 	end
-	
+
 	if self.lifeTime and self.time > self.lifeTime then
 		if self.hitActive then
 			if self.time > self.lifeTime * 5 or self:getSpeed() <= 2 then
 				self:addAngleSpeed(math_randomAngle() - math_randomAngle(), 1)
 				self:disableHit()
-				
+
 				if self.myFx then
 					self.myFx:remove()
-					
+
 					self.myFx = nil
 				end
-				
+
 				self:emitSound("jetBulletDie", 0.4, 1.5)
-				
+
 				if self.flameFx then
 					self.flameFx:remove()
-					
+
 					self.flameFx = nil
 				end
-				
+
 				self:setRemovable()
 			end
 		elseif not self.recreated then
 			self:setPhysicsType("debris")
-			
+
 			self.recreated = true
 		end
 	end
@@ -8378,73 +8434,73 @@
 local function gyrojetbulletObjectCollision(self, impact)
 	if not self.isSleeping then
 		local hitt
-		
+
 		if self.hitActive then
 			impact.damageModifier = self:getSpeedDamageModifier(self:getStartSpeed())
-			
+
 			if impact.damageModifier > 0.1 and impact.target then
 				local hit, dam = impact.target:hit(impact, self:getAttack())
-				
+
 				if hit then
 					if impact.target and impact.target._category ~= "tile" then
 						self:performReaction(impact)
 					end
-					
+
 					self:hitSound(impact)
-					
+
 					hitt = true
 					self.bounces = self.bounces + 1
-					
+
 					self:setSpeed(self.angle, self:getSpeed() / (1 + dam * 5))
-					
+
 					self.thrust = self.thrust / (1 + dam * 1.5)
 					self.time = self.time + dam / 4
 				end
 			end
-			
+
 			local x, y = self.map.physics:getEntityPosition(self.body)
-			
+
 			self:setPosition(x / self.map.resolution, y / self.map.resolution)
-			
-			return 
+
+			return
 		end
-		
+
 		local diff = math_abs(math_angleDifference(impact.angle, self.angle))
-		
+
 		if diff > math_pi * 0.05 and self.hitActive then
 			if not self.collided then
 				self.collided = true
-				
+
 				if self.bounces < 12 then
 					self.collided = true
-					
+
 					local newAng = self.map.physics:getEntityAngle(self.body)
-					
+
 					self.bounces = self.bounces + 1
-					
+
 					self:setAngle(self:bounceWithVector(impact.angle, 1))
 					self:setSpeed(self.angle, self:getStartSpeed())
 					self:setAngleSpeed(0)
 					self:emitSound("bulletBounce", 1, 1)
-					
+
 					self.time = 0
 				end
 			end
-			
-			return 
+
+			return
 		end
 	end
 end
 
 local function gyroBulletPieceObjectInit(self)
 	self.bounces = self.bounces or 0
-	
+
 	if self.hitActive == nil then
 		self:setHitActive(true)
 	end
-	
+
 	local f = self:emitFx("trunkanBulletFlare")
-	
+
 	f.reference = self
 	self.myFx = f
 end
@@ -8469,39 +8525,39 @@
 	updateMethod = function(self, time)
 		if not self.sleeping then
 			self.time = self.time + time
-			
+
 			if self.lifeTime and self.time > self.lifeTime and self.hitActivet then
 				self:disableHit()
-				
+
 				if self.myFx then
 					self.myFx:remove()
-					
+
 					self.myFx = nil
 				end
-				
+
 				self:setRemovable()
 			end
-			
+
 			if not self.hitActive and self.trailMakerFx then
 				self.trailMakerFx:remove()
-				
+
 				self.trailMakerFx = nil
 			end
-			
+
 			if self.trailMakerFx then
 				self.trailMakerFx:setPosition(self.x, self.y)
 			end
-			
+
 			if self.hitActive then
 				self.dy = self.dy + 46 * time
-				
+
 				self:setAngle(math_approachAngle(self.angle, math_angleBetweenPoints(0, 0, self.dx, self.dy), time * math_pi * 2))
 			else
 				self.dy = self.dy + 46 * time
-				
+
 				if not self.recreated and self.onGround then
 					self:setPhysicsType("debris")
-					
+
 					self.recreated = true
 				end
 			end
@@ -8517,13 +8573,13 @@
 		if self.hitActive then
 			local x = impact.x or self.x
 			local x, y = x, impact.y or self.y
-			
+
 			self:emitFxAt("spikeHitFlash", x, y)
 			self:emitSound("spikeHit", 1, 1, 200)
-			
+
 			for i = 1, math_random(1, 3) do
 				obj = self:emitSpark("lightSpark")
-				
+
 				obj:setAngle(self.angle)
 				obj:setSpeed(math_random() * math_pi * 2, math_random() * 9 + 7.5)
 				obj:setSpeed(impact.angle + math_pi + math_random() * half_pi - math_random() * half_pi, math_random() * 9 + 7.5)
@@ -8531,12 +8587,12 @@
 				obj:setLifeTime(2)
 				self.map.physics:setEntityAngleSpeed(obj.body, math_random() * 2 * math_pi - math_random() * 2 * math_pi)
 			end
-			
+
 			self:remove()
-			
+
 			if self.myFx then
 				self.myFx:remove()
-				
+
 				self.myFx = nil
 			end
 		end
@@ -8572,7 +8628,7 @@
 	if self.hitActive == nil then
 		self:setHitActive(true)
 	end
-	
+
 	self.bounces = self.bounces or 0
 	self.flameSound = self.flameSound or 0
 	self.thrust = self.thrust or 0
@@ -8581,7 +8637,7 @@
 local function gyrojetBulletInitRuntime(self)
 	if self.map and not self.prediction then
 		local f = self:emitFx("jetBulletFlare")
-		
+
 		f.reference = self
 		self.flameFx = f
 	end
@@ -8607,11 +8663,11 @@
 	updateMethod = gyrojetbulletObjectUpdate,
 	getSpeedDamageModifier = function(self, speed)
 		local mod = speed / 25
-		
+
 		if mod < 1 then
 			return 0.1 + 0.9 * math_pow(mod, 2)
 		end
-		
+
 		return 0.1 + 0.9 * mod
 	end,
 	getLifeProgressAcceleration = function(self, lifeProgress)
@@ -8657,7 +8713,7 @@
 	},
 	getBulletTimeFactor = function(self)
 		local s = self:getSpeed()
-		
+
 		return math_min(1, s / 50) * 0.5
 	end,
 	network = {
@@ -8693,7 +8749,7 @@
 	collisionMethod = function(self, impact)
 		if impact.target then
 			local hit, dam = impact.target:hit(impact, ATTACKS.sgLaser)
-			
+
 			if hit then
 				self:performReaction(impact)
 			end
@@ -8702,7 +8758,7 @@
 	reactionMethod = function(self, impact)
 		local x = impact.x or self.x
 		local x, y = x, impact.y or self.y
-		
+
 		self:emitFxAt("bulletHitFlash", x, y)
 		self:emitSoundAt("bulletHit", x, y, 1, 1.2, 800)
 		self:remove()
@@ -8738,10 +8794,10 @@
 	self.delay = 0.5
 	self.charge = 0
 	self.instability = 0
-	
+
 	if not self.player or self.player:isLocalHuman() then
 		self.trailFx = self:emitOwnedFx("plugTrailMaker")
-		
+
 		self.trailFx:setOwner(self)
 	end
 end
@@ -8756,11 +8812,15 @@
 	magnetic = false,
 	renderMethod = function(self, x, y)
 		local color = self.color or COLORS.white
-		
-		video.renderSpriteState(self.def.customSprites.glow, x, y, 1.5 + math_cos(self.time * math_pi * 2) * 0.2, self.angle + self.time * math_pi * 3, self.charge * (128 + 128 * self.sparkOpacity), color.r, color.g, color.b, self.flipped)
-		video.renderSpriteState(self.def.sprite, x, y, 1.5 + math_cos(self.time * math_pi * 2) * 0.2, self.angle + self.time * math_pi * 3, self.charge * 55, color.r, color.g, color.b, self.flipped)
-		video.renderSpriteState(self.def.customSprites.spark, x, y, 2.5 + math_cos(self.time * math_pi * 2) * 0.2, self.sparkAngle, self.charge * 255 * self.sparkOpacity, color.r, color.g, color.b, self.flipped)
-		
+
+		video.renderSpriteState(self.def.customSprites.glow, x, y, 1.5 + math_cos(self.time * math_pi * 2) * 0.2,
+			self.angle + self.time * math_pi * 3, self.charge * (128 + 128 * self.sparkOpacity), color.r, color.g, color.b,
+			self.flipped)
+		video.renderSpriteState(self.def.sprite, x, y, 1.5 + math_cos(self.time * math_pi * 2) * 0.2,
+			self.angle + self.time * math_pi * 3, self.charge * 55, color.r, color.g, color.b, self.flipped)
+		video.renderSpriteState(self.def.customSprites.spark, x, y, 2.5 + math_cos(self.time * math_pi * 2) * 0.2,
+			self.sparkAngle, self.charge * 255 * self.sparkOpacity, color.r, color.g, color.b, self.flipped)
+
 		if self.player and self.delay <= 0 then
 			self.player:renderSmallHudName(x, y + 20, self.charge, 1)
 		end
@@ -8778,12 +8838,13 @@
 	initMethod = playerSparkObjectInit,
 	lightMapRenderMethod = function(self, x, y)
 		local color = self.actor and self.actor:getIdentityColor() or COLORS.white
-		
-		video.renderAdditiveSpriteState(FX.glow.sprite, x, y, 1.5 * (math_abs(math_sin(self.time * math_pi * 9.5)) * 0.3), 0, color.r, color.g, color.b, self.flipped)
+
+		video.renderAdditiveSpriteState(FX.glow.sprite, x, y, 1.5 * (math_abs(math_sin(self.time * math_pi * 9.5)) * 0.3), 0,
+			color.r, color.g, color.b, self.flipped)
 	end,
 	hitMethod = function(self, impact, attack)
 		self:bounceWithVector(impact.angle, 0.25)
-		
+
 		return true
 	end,
 	collisionMethod = function(self, impact)
@@ -8795,20 +8856,20 @@
 	end,
 	onPlayerSet = function(self, player)
 		self.color = player:getColor() or COLORS.white
-		
+
 		if not player:isLocalHuman() then
 			if self.trailFx then
 				self.trailFx:remove()
-				
+
 				self.trailFx = nil
 			end
-			
+
 			self.hidden = true
-			
+
 			self:hideRender()
 		else
 			self.hidden = false
-			
+
 			if self.trailFx then
 				self.trailFx:applyColor(self.color)
 			end
@@ -8816,37 +8877,37 @@
 	end,
 	updateMethod = function(self, time)
 		local tf = time / self.pingTimeFactor
-		
+
 		if self.delay > 0 then
 			self.delay = self.delay - tf
 		else
 			self.time = self.time + tf * self.time * 2 + tf * 0.1
-			
+
 			if self.target then
 				local dist = self:getDistanceTo(self.target)
-				
+
 				self.time = self.time + tf / dist * 500
 			end
-			
+
 			self.time = math.min(1, self.time)
 		end
-		
+
 		if self.trailFx then
 			self.trailFx:setPosition(self.x, self.y)
 			self.trailFx:setTime(0)
 		end
-		
+
 		if self.target then
 			self.charge = math_min(1, self.charge + tf * 40)
-			
+
 			if self.target:isBeaten() or self.target:isChanging() then
 				self.target = nil
 			else
 				local prg = self.time * self.time
 				local tx, ty = self.target.x * prg + self.startX * (1 - prg), self.target.y * prg + self.startY * (1 - prg)
-				
+
 				self:setPosition(tx, ty)
-				
+
 				if prg >= 1 then
 					self.player:setTemporaryActor(self.target)
 					self:performReaction()
@@ -8854,12 +8915,12 @@
 			end
 		else
 			self.charge = math_max(0, self.charge - tf * 2)
-			
+
 			if self.charge <= 0 then
 				self:performReaction()
 			end
 		end
-		
+
 		if self.sparkOpacity <= 0 then
 			self.sparkOpacity = 1
 			self.sparkAngle = math_randomAngle()
@@ -8910,7 +8971,7 @@
 	self.charge = 0
 	self.instability = 0
 	self.trailFx = self:emitOwnedFx("plugTrailMaker")
-	
+
 	self.trailFx:setOwner(self)
 end
 
@@ -8924,10 +8985,14 @@
 	bulletTimeDistanceFactor = 0,
 	renderMethod = function(self, x, y)
 		local color = self.color or COLORS.white
-		
-		video.renderSpriteState(self.def.customSprites.glow, x, y, 2.5 + math_cos(self.time * math_pi * 2) * 0.3, self.angle + self.time * math_pi * 3, self.charge * (128 + 128 * self.sparkOpacity), color.r, color.g, color.b, self.flipped)
-		video.renderSpriteState(self.def.sprite, x, y, 1.5 + math_cos(self.time * math_pi * 2) * 0.2, self.angle + self.time * math_pi * 3, self.charge * 55, color.r, color.g, color.b, self.flipped)
-		video.renderSpriteState(self.def.customSprites.spark, x, y, 1.5 + math_cos(self.time * math_pi * 2) * 0.5, self.sparkAngle, self.charge * 255 * self.sparkOpacity, color.r, color.g, color.b, self.flipped)
+
+		video.renderSpriteState(self.def.customSprites.glow, x, y, 2.5 + math_cos(self.time * math_pi * 2) * 0.3,
+			self.angle + self.time * math_pi * 3, self.charge * (128 + 128 * self.sparkOpacity), color.r, color.g, color.b,
+			self.flipped)
+		video.renderSpriteState(self.def.sprite, x, y, 1.5 + math_cos(self.time * math_pi * 2) * 0.2,
+			self.angle + self.time * math_pi * 3, self.charge * 55, color.r, color.g, color.b, self.flipped)
+		video.renderSpriteState(self.def.customSprites.spark, x, y, 1.5 + math_cos(self.time * math_pi * 2) * 0.5,
+			self.sparkAngle, self.charge * 255 * self.sparkOpacity, color.r, color.g, color.b, self.flipped)
 	end,
 	initRuntimeMethod = function(self)
 		self.sparkOpacity = 0
@@ -8942,70 +9007,71 @@
 	initMethod = teamSparkObjectInit,
 	lightMapRenderMethod = function(self, x, y)
 		local color = self.actor and self.actor:getIdentityColor() or COLORS.white
-		
-		video.renderAdditiveSpriteState(FX.glow.sprite, x, y, 2.5 * (math_abs(math_sin(self.time * math_pi * 9.5)) * 0.3), 0, color.r, color.g, color.b, self.flipped)
+
+		video.renderAdditiveSpriteState(FX.glow.sprite, x, y, 2.5 * (math_abs(math_sin(self.time * math_pi * 9.5)) * 0.3), 0,
+			color.r, color.g, color.b, self.flipped)
 	end,
 	onTeamSet = function(self, team)
 		self.color = team:getIdentityColor() or COLORS.white
-		
+
 		if self.trailFx then
 			self.trailFx:applyColor(self.color)
 		end
 	end,
 	updateMethod = function(self, time)
 		local tf = time / self.pingTimeFactor
-		
+
 		if self.delay > 0 then
 			self.delay = self.delay - tf
 		else
 			self.time = self.time + tf * self.time
-			
+
 			if self.target then
 				local dist = self:getDistanceTo(self.target)
-				
+
 				self.time = self.time + tf / dist * 500
 			end
-			
+
 			self.time = math_min(1, self.time)
 		end
-		
+
 		if self.trailFx then
 			self.trailFx:setPosition(self.x, self.y)
 			self.trailFx:setTime(0)
 		end
-		
+
 		local target = self.target
 		local team = self.team
-		
+
 		if target and team then
 			self.charge = math_min(1, self.charge + tf * 40)
-			
+
 			if target:isBeaten() or target:isChanging() then
 				self.target = nil
 			else
 				local prg = self.time * self.time
 				local tx, ty = self.target.x * prg + self.startX * (1 - prg), self.target.y * prg + self.startY * (1 - prg)
-				
+
 				self:setPosition(tx, ty)
-				
+
 				if prg >= 1 then
 					if target:canCaptureChangeTeam() and target.team ~= team then
 						target:ejectSeats()
 						target:setTeam(team)
 						target:emitCapturedByTeamFeedback(team)
 					end
-					
+
 					self:performReaction()
 				end
 			end
 		else
 			self.charge = math_max(0, self.charge - tf * 2)
-			
+
 			if self.charge <= 0 then
 				self:performReaction()
 			end
 		end
-		
+
 		if self.sparkOpacity <= 0 then
 			self.sparkOpacity = 1
 			self.sparkAngle = math_randomAngle()
@@ -9060,10 +9126,14 @@
 	magnetic = false,
 	renderMethod = function(self, x, y)
 		local color = self.actor and self.actor:getIdentityColor() or COLORS.white
-		
-		video.renderSpriteState(self.def.customSprites.glow, x, y, 1.5 + math_cos(self.time * math_pi * 2) * 0.2, self.angle + self.time * math_pi * 3, self.charge * (128 + 128 * self.sparkOpacity), color.r, color.g, color.b, self.flipped)
-		video.renderSpriteState(self.def.sprite, x, y, 1.5 + math_cos(self.time * math_pi * 2) * 0.2, self.angle + self.time * math_pi * 3, self.charge * 55, color.r, color.g, color.b, self.flipped)
-		video.renderSpriteState(self.def.customSprites.spark, x, y, 2.5 + math_cos(self.time * math_pi * 2) * 0.2, self.sparkAngle, self.charge * 255 * self.sparkOpacity, color.r, color.g, color.b, self.flipped)
+
+		video.renderSpriteState(self.def.customSprites.glow, x, y, 1.5 + math_cos(self.time * math_pi * 2) * 0.2,
+			self.angle + self.time * math_pi * 3, self.charge * (128 + 128 * self.sparkOpacity), color.r, color.g, color.b,
+			self.flipped)
+		video.renderSpriteState(self.def.sprite, x, y, 1.5 + math_cos(self.time * math_pi * 2) * 0.2,
+			self.angle + self.time * math_pi * 3, self.charge * 55, color.r, color.g, color.b, self.flipped)
+		video.renderSpriteState(self.def.customSprites.spark, x, y, 2.5 + math_cos(self.time * math_pi * 2) * 0.2,
+			self.sparkAngle, self.charge * 255 * self.sparkOpacity, color.r, color.g, color.b, self.flipped)
 	end,
 	initRuntimeMethod = function(self)
 		self.sparkOpacity = 0
@@ -9081,18 +9151,19 @@
 	end,
 	lightMapRenderMethod = function(self, x, y)
 		local color = self.actor and self.actor:getIdentityColor() or COLORS.white
-		
-		video.renderAdditiveSpriteState(FX.glow.sprite, x, y, 1.5 * (math_abs(math_sin(self.time * math_pi * 9.5)) * 0.3), 0, color.r, color.g, color.b, self.flipped)
+
+		video.renderAdditiveSpriteState(FX.glow.sprite, x, y, 1.5 * (math_abs(math_sin(self.time * math_pi * 9.5)) * 0.3), 0,
+			color.r, color.g, color.b, self.flipped)
 	end,
 	hitMethod = function(self, impact, attack)
 		self:bounceWithVector(impact.angle, 0.25)
-		
+
 		return true
 	end,
 	collisionMethod = function(self, impact)
 		if self.volatile then
 			self.groundAngle = impact.angle
-			
+
 			self:performReaction(impact)
 		else
 			self:bounceWithVector(impact.angle, 1)
@@ -9100,26 +9171,26 @@
 	end,
 	updateVisualMethod = function(self, time)
 		self.time = self.time + time * self.instability
-		
+
 		if math_random() < self.charge * time * 5 + time * 2 * self.instability then
 			local a = math_randomAngle()
 			local d = math_random() * (16 + self.instability * self.instability * 5)
 			local ball = self:emitFxAt("dematerializedBall", self.x + math_cos(a) * d, self.y + math_sin(a) * d)
-			
+
 			ball:setTarget(self)
 			ball:setSpeed(a, d * 15)
 			ball:addSpeed(a + half_pi, math_randomGaussian() * 125)
-			
+
 			local fx = self:emitFxAt("dematerializerBolt", self.x + math_cos(a) * d, self.y + math_sin(a) * d)
-			
+
 			fx:setOwner(ball)
 			fx:setTarget(self)
 		end
-		
+
 		if not self.materializing and self.actor then
 			self.actor:setPosition(self.x, self.y)
 		end
-		
+
 		if self.sparkOpacity <= 0 then
 			self.sparkOpacity = 1
 			self.sparkAngle = math_randomAngle()
@@ -9129,25 +9200,25 @@
 	end,
 	updateMethod = function(self, time)
 		local speed = self:getSpeed()
-		
+
 		self:stopSpeedXY(speed * 0.1, speed * 0.1, time)
-		
+
 		if self.charge >= 1 then
 			local actor = self:getActor()
-			
+
 			if not actor or actor:isBeaten() or actor._remove then
 				self:remove()
 			end
-			
+
 			if self.instability < 1 and not self.materializing then
 				if actor and not actor._remove then
 					actor:setPosition(self.x, self.y)
 				else
 					self:remove()
 				end
-				
+
 				self.instability = self.instability + time / 10
-				
+
 				if self.instability >= 1 then
 					self:performReaction()
 				end
@@ -9156,16 +9227,16 @@
 	end,
 	reactionMethod = function(self)
 		local actor = self:getActor()
-		
+
 		if actor and not actor:isBeaten() and not actor._remove then
 			if not actor.materializing then
 				self:setPhysicsType("debris")
 				actor:materialize(self)
-				
+
 				if self.groundAngle then
 					actor:adaptToUpwardsAngle(not self.flipped, self.groundAngle + math.pi)
 				end
-				
+
 				self.materializing = true
 			end
 		else
@@ -9218,13 +9289,17 @@
 	magnetic = false,
 	id = "dematerializer",
 	renderMethod = function(self, x, y)
-		video.renderSpriteState(self.def.customSprites.glow, x, y, 1 + math_cos(self.time * math_pi * 2) * 0.2, self.angle + self.time * math_pi * 3, 128 + 128 * self.sparkOpacity, 255, 255, 255, self.flipped)
-		video.renderSpriteState(self.def.sprite, x, y, 1 + math_cos(self.time * math_pi * 2) * 0.2, self.angle + self.time * math_pi * 3, 255, 255, 255, 255, self.flipped)
-		video.renderSpriteState(self.def.customSprites.spark, x, y, 2 + math_cos(self.time * math_pi * 2) * 0.2, self.sparkAngle, 255 * self.sparkOpacity, 255, 255, 255, self.flipped)
+		video.renderSpriteState(self.def.customSprites.glow, x, y, 1 + math_cos(self.time * math_pi * 2) * 0.2,
+			self.angle + self.time * math_pi * 3, 128 + 128 * self.sparkOpacity, 255, 255, 255, self.flipped)
+		video.renderSpriteState(self.def.sprite, x, y, 1 + math_cos(self.time * math_pi * 2) * 0.2,
+			self.angle + self.time * math_pi * 3, 255, 255, 255, 255, self.flipped)
+		video.renderSpriteState(self.def.customSprites.spark, x, y, 2 + math_cos(self.time * math_pi * 2) * 0.2,
+			self.sparkAngle, 255 * self.sparkOpacity, 255, 255, 255, self.flipped)
 	end,
 	initMethod = dematerializerObjectInit,
 	lightMapRenderMethod = function(self, x, y)
-		video.renderAdditiveSpriteState(FX.glow.sprite, x, y, 1 * (math_abs(math_sin(self.time * math_pi * 9.5)) * 0.3), 0, 255, 255, 255, self.flipped)
+		video.renderAdditiveSpriteState(FX.glow.sprite, x, y, 1 * (math_abs(math_sin(self.time * math_pi * 9.5)) * 0.3), 0,
+			255, 255, 255, self.flipped)
 	end,
 	hitMethod = function(self, impact, attack)
 		return true
@@ -9236,29 +9311,29 @@
 		if genericCheckSensorHit(self, impact) then
 			self.dx = self.dx * 0.25
 			self.dy = self.dy * 0.25
-			
+
 			local owner = self:getOwner()
 			local target = impact.target
-			
+
 			if owner and owner == target then
 				if self.weapon then
 					self.weapon:setTarget()
 				end
-				
+
 				target:hit(impact, ATTACKS.tinyEnergy)
 				target:setDamaged(0.5)
 			elseif target:canBeDematerialized() then
 				local ball = target:emitObject("dematerialized")
-				
+
 				if ball then
 					ball:setSpeedXY(target.dx, target.dy)
 					target:dematerializeInto(ball)
 					ball:setOwner(self.owner)
-					
+
 					if self.weapon then
 						self.weapon:setTarget(ball)
 					end
-					
+
 					local x = impact.x or self.x
 					local x, y = x, impact.y or self.y
 					local fx = self:emitPpFxAt("dematerializerGlow", x, y)
@@ -9267,11 +9342,11 @@
 				if self.weapon then
 					self.weapon:setTarget()
 				end
-				
+
 				target:hit(impact, ATTACKS.tinyEnergy)
 				target:setDamaged(0.5)
 			end
-			
+
 			self:performReaction(impact)
 		else
 			self:bounceWithVector(impact.angle, 0.25)
@@ -9287,34 +9362,34 @@
 	end,
 	updateMethod = function(self, time)
 		self.time = self.time + time
-		
+
 		local speed = self:getSpeed()
-		
+
 		if self.target then
 			self:followTarget(155, 0.05, 15, time)
 		else
 			self:stopSpeedXY(speed * 0.05, speed * 0.05, time)
 		end
-		
+
 		self:updateSpecial("homing", time)
-		
+
 		if self.time >= self.def.lifeTime then
 			self:performReaction()
 		end
 	end,
 	reactionMethod = function(self, impact)
 		local detail = _config.graphicsFx
-		
+
 		for i = 1, 2 + 6 * detail do
 			local obj = self:emitSpark("despawnSparkle")
-			
+
 			obj.airFriction = 5
 			obj.dieSound = "spawnSpark"
-			
+
 			obj:setSpeedXY(self.dx, self.dy)
 			obj:addSpeed(math_randomAngle(), math_random(15))
 		end
-		
+
 		self:remove()
 	end,
 	render = {
@@ -9355,20 +9430,20 @@
 	bulletTimeFactor = 0,
 	hitMethod = function(self, impact, attack)
 		self:performReaction(impact)
-		
+
 		return true
 	end,
 	reactionMethod = function(self, impact)
 		if self.hackDevice then
 			local owner = self.owner
-			
+
 			if owner then
 				owner:deactivateItem(self.hackDevice)
 			end
-			
+
 			self.hackDevice.controlling = false
 		end
-		
+
 		self:remove()
 	end,
 	render = {
@@ -9418,18 +9493,18 @@
 	deflectable = false,
 	updateMethod = function(self, time)
 		local def = self.def
-		
+
 		self.power = self.power - time * def.power_consumption_per_second
-		
+
 		if self.target then
 			local speed = def.homing_speed
 			local stop = def.homing_stop
 			local rotation = def.homing_rotation
 			local carving = def.homing_carving
-			
+
 			self:followTarget(speed, stop, rotation, time, carving)
 		end
-		
+
 		if self.power <= 0 then
 			self:performExpireReaction()
 		end
@@ -9444,7 +9519,7 @@
 	color = COLORS.hack,
 	visualExpireMethod = function(self)
 		local fx = self:emitPpFx("sparkSourceDieWhite")
-		
+
 		fx:applyColor(self.color)
 	end,
 	visualReactionMethod = function(self, x, y, angle, target)
@@ -9452,38 +9527,41 @@
 			for i = 1, math_random(4) + 4 do
 				local ang = math_pi * 2 * math_random()
 				local dist = math_random() * 50
-				local fx = target:emitPpFxAt("sparkSourceFlashWhite", target.x + math_cos(ang) * dist, target.y + math_sin(ang) * dist)
-				
+				local fx = target:emitPpFxAt("sparkSourceFlashWhite", target.x + math_cos(ang) * dist,
+					target.y + math_sin(ang) * dist)
+
 				fx:applyColor(self.color)
 				fx:setSpeed(math_random() * math_pi * 2, math_random() * 10 * self.power)
 				fx:setMasterScale(self.power * 0.5)
 			end
-			
+
 			self:emitSound("hacked")
 		end
 	end,
 	sensorMethod = function(self, impact)
 		local target = impact.target
 		local master = self:getOwner()
-		
+
 		if master and target then
 			if target._category == "actor" then
 				if target:isElectric() and master:isThreatened(target) then
 					target:affect(master)
-					
+
 					local def = self.def
-					
+
 					if target:isHackable() and not target.player then
-						target:performHackTeam(master, (def.hack_base_factor + self.power * def.hack_variable_factor) * def.hack_factor)
+						target:performHackTeam(master,
+							(def.hack_base_factor + self.power * def.hack_variable_factor) * def.hack_factor)
 					else
-						target:performHackBio((def.hack_bio_base_factor + def.hack_bio_variable_factor * self.power) * def.hack_bio_factor)
+						target:performHackBio((def.hack_bio_base_factor + def.hack_bio_variable_factor * self.power) *
+						def.hack_bio_factor)
 					end
-					
+
 					self:performReaction(impact)
 				end
 			elseif target._category == "object" then
 				local owner = target:getOwner()
-				
+
 				if target:isHackable() and (not owner or master:isThreatened(owner)) then
 					target:hackOwner(master)
 					target:affect(master)
@@ -9491,7 +9569,7 @@
 				end
 			end
 		end
-		
+
 		return true
 	end,
 	initMethod = function(self)
@@ -9545,14 +9623,14 @@
 	updateMethod = function(self, time)
 		if self.target then
 			self:followTarget(100, 1, 20, time, 1)
-			
+
 			self.power = self.power - time * 0.1
-			
+
 			if self.power <= 0 then
 				self:remove()
 			end
 		end
-		
+
 		if self.glow then
 			self.glow:setMasterScale(self.power)
 		end
@@ -9566,34 +9644,35 @@
 	onRemovedMethod = function(self)
 		if self.glow then
 			self.glow:remove()
-			
+
 			self.glow = nil
 		end
 	end,
 	sensorMethod = function(self, impact)
 		local target = impact.target
-		
+
 		if target == self.target and target._category == "actor" and target:canBeCharmedBy(self.owner) then
 			local def = self.def
-			
+
 			if target:isPlayerControlled() then
-				target:performHackBio((def.hack_bio_base_factor + def.hack_bio_variable_factor * self.power) * def.hack_bio_factor)
+				target:performHackBio((def.hack_bio_base_factor + def.hack_bio_variable_factor * self.power) *
+				def.hack_bio_factor)
 			else
 				target:addCharming(self.owner, self.power * (self.charming or 1))
 			end
-			
+
 			self:remove(impact)
 		end
-		
+
 		return true
 	end,
 	initMethod = function(self)
 		self.power = 1
-		
+
 		local fx = self:emitPpFx("danceMarkGlowFollow")
-		
+
 		fx:setReference(self)
-		
+
 		self.glow = fx
 	end,
 	render = {
@@ -9621,50 +9700,50 @@
 
 local function burnerFlameUpdate(self, time)
 	self.time = self.time + time
-	
+
 	if self.owner and self.owner._category == "tile" then
 		local x, y, absAng = self.owner:getNodeXYAngle()
-		
+
 		self:setPosition(x, y)
 		self:setAngle(absAng)
 		self.owner:addSpeed(absAng + math_pi, self.def.pushSpeed * time)
-		
+
 		if self.flameFx then
 			self.flameFx:setPosition(x, y)
 			self.flameFx:setAngle(absAng)
 		end
-		
+
 		if self.longFx then
 			self.longFx:setPosition(x, y)
 			self.longFx:setAngle(absAng)
 		end
 	end
-	
+
 	if self.flameFx then
 		self.flameFx:setTime(math_min(self.flameFx.time, 0.05))
 		self.flameFx:setAngle(self.angle)
 	end
-	
+
 	self.soundProgress = math_min(1, self.soundProgress + time / 0.1)
 	self.dist = math_min(self.range, self.dist + (self.range - self.dist) * time * 20)
-	
+
 	local impact = self:losToImpact(self:getLosForward(self.dist, LOS.staticHazard))
-	
+
 	if impact and impact.target and impact.target ~= self.owner then
 		self.dist = math_distance(self.x, self.y, impact.x, impact.y)
-		
+
 		if self:isInView(100) and (not self.hitFx or self.hitFx._remove or self.hitFx.time > 0.1) then
 			self.hitFx = self:emitFxAt("burnerHit", impact.x, impact.y)
-			
+
 			self.hitFx:setAngle(impact.angle + math_pi)
 		end
-		
+
 		if impact.target._category == "actor" or impact.target._category == "object" then
 			impact.impulse = 0
 			self.dx = math_cos(self.angle) * 10
 			self.dy = math_sin(self.angle) * 10
 			impact.damageModifier = math_easeOut(math_distance(self.x, self.y, impact.x, impact.y) / self.dist) * time
-			
+
 			if impact.target:hit(impact, ATTACKS.flame) then
 				if impact.target._category == "actor" then
 					impact.target:addSpeed(impact.angle + math_pi, 100 * time)
@@ -9672,20 +9751,21 @@
 					impact.target:addSpeed(impact.angle + math_pi, 100 * time)
 				end
 			end
-			
+
 			self.savedTarget = impact.target
 		end
 	end
-	
+
 	if self.longFx then
 		self.longFx:setEnd(self.x + math_cos(self.angle) * self.dist, self.y + math_sin(self.angle) * self.dist)
 		self.longFx:setTime(math_min(self.longFx.time, 0.05))
 	end
-	
+
 	if self:isInView(750) then
-		self:emitLoop("burner", 0.5 * math_max(0, self.soundProgress * 1 - math_max(0, self.time) / self.lifeTime), math_max(0.8, 0.8 + 0.4 * self.soundProgress * 1 - math_max(0, self.time) / self.lifeTime), RANGES.long)
+		self:emitLoop("burner", 0.5 * math_max(0, self.soundProgress * 1 - math_max(0, self.time) / self.lifeTime),
+			math_max(0.8, 0.8 + 0.4 * self.soundProgress * 1 - math_max(0, self.time) / self.lifeTime), RANGES.long)
 	end
-	
+
 	if self.lifeTime and self.time > self.lifeTime then
 		self:remove()
 		self:emitSound("burnerEnd", 0.3, 1)
@@ -9695,155 +9775,161 @@
 local function slugUpdate(self, time)
 	if self.skip_one then
 		self.skip_one = false
-		
-		return 
+
+		return
 	end
-	
+
 	self.time = self.time + time
-	
+
 	if self:getSpeed() < self.def.debrisSpeedThreshold then
 		if RENDERING then
 			local deb = self:emitDebris(self.def.sprite)
-			
+
 			deb:setAngleSpeed(self.wobble)
 			deb:setSpeedXY(self.dx, self.dy)
 			deb:setAngle(self.angle)
-			
+
 			deb.flipped = self.flipped
 		end
-		
+
 		self:remove()
-		
-		return 
+
+		return
 	end
-	
+
 	local buffer = time
-	
+
 	while buffer > 0 do
 		local time = math_min(APP.stepTime / 8, buffer)
-		
+
 		buffer = buffer - APP.stepTime / 8
-		self.wobble = math_cos(self.wobbleTimer * 15 * math_pi / self.def.damageFalloffSpeed * 50) * math_max(0, (self.def.damageFalloffSpeed - self:getSpeed()) / self.def.damageFalloffSpeed) / self:getMass() * 0.75
-		
+		self.wobble = math_cos(self.wobbleTimer * 15 * math_pi / self.def.damageFalloffSpeed * 50) *
+		math_max(0, (self.def.damageFalloffSpeed - self:getSpeed()) / self.def.damageFalloffSpeed) / self:getMass() * 0.75
+
 		local speed = self:getSpeed()
-		
+
 		self:setAngle(self.angle + 120 * self.wobble * time / self:getMass() / (50 + speed))
-		
+
 		local diff = math_abs(math_angleDifference(self.angle, self:getSpeedAngle()))
-		
+
 		self:stopSpeedXY(0.15 * math_abs(math_sin(diff)) * speed, math_abs(0.15 * math_sin(diff)) * speed, time)
-		
+
 		self.dx = math_approach(self.dx, math_cos(self.angle) * speed, time / self:getMass() * math_abs(math_cos(diff)) * 30)
 		self.dy = math_approach(self.dy, math_sin(self.angle) * speed, time / self:getMass() * math_abs(math_cos(diff)) * 30)
 	end
-	
+
 	local resolution = self.map.resolution
 	local nextX = self.x + self.dx * time / resolution
 	local nextY = self.y + self.dy * time / resolution
-	
+
 	if DEBUG.showDebug and DEBUG.showGraphs then
 		D.addToGraph("ray", 1)
 	end
-	
+
 	local len = self.def.rayLength
 	local ang = self.angle
-	local result, hitx, hity, nx, ny, userData, id = self.map.physics:raycastPoints((self.x - math_cos(ang) * len) * resolution, (self.y - math_sin(ang) * len) * resolution, (nextX + math_cos(ang) * len) * resolution, (nextY + math_sin(ang) * len) * resolution, true, _collisionCategory.bullets, _collisionFilter.notIdleObjectsNoSensorNoBullets, self.ignore and self.ignore.bodyFilter or -self.body)
-	
+	local result, hitx, hity, nx, ny, userData, id = self.map.physics:raycastPoints(
+	(self.x - math_cos(ang) * len) * resolution, (self.y - math_sin(ang) * len) * resolution,
+		(nextX + math_cos(ang) * len) * resolution, (nextY + math_sin(ang) * len) * resolution, true,
+		_collisionCategory.bullets, _collisionFilter.notIdleObjectsNoSensorNoBullets,
+		self.ignore and self.ignore.bodyFilter or -self.body)
+
 	if result then
 		hitx = hitx / resolution
 		hity = hity / resolution
 		nextX = hitx
 		nextY = hity
-		
+
 		local target = self.map.bodyLookup[id]
 		local hit = false
 		local attack = self:getAttack()
 		local damageDone = 0
-		
+
 		if target then
 			self.rayImpact = self.rayImpact or {}
-			
+
 			local rayInfo = self.rayImpact
-			
+
 			rayInfo.owner = self
 			rayInfo.x = hitx
 			rayInfo.y = hity
 			rayInfo.angle = self.angle
 			rayInfo.target = target
 			rayInfo.impulse = 34
-			
+
 			if target._category == "actor" or target._category == "object" or target._category == "tile" then
 				local sm = self:getSpeedDamageModifier(self:getSpeed())
-				
+
 				rayInfo.damageModifier = self.damageLeft * sm
 				hit, damageDone = target:hit(rayInfo, attack)
-				
+
 				if hit then
 					self:resolveImpulse(target, self.angle, 0, math_min(1, damageDone / attack.damage), 0.1)
-					
+
 					if target._category == "actor" then
 						target:gripless(self.damageLeft)
 					end
 				end
-				
+
 				if damageDone then
 					self.damageLeft = self.damageLeft - damageDone / sm / attack.overall_power
 				else
 					damageDone = 0
 				end
 			end
-			
+
 			if target._category == "tile" then
 				local fx = self:emitPpFxAt("railMark", rayInfo.x, rayInfo.y)
-				
+
 				fx:setMasterScale(self.def.markScale or 1)
 				fx:setOwner(self)
-				
+
 				hit = true
-				
+
 				self:hitSound(rayInfo, 1, 1)
-				
+
 				self.damageLeft = 0
 			end
-			
+
 			if hit and (target._category ~= "actor" and damageDone <= 0 or self.damageLeft <= 0) then
 				local self_angle = self.angle
-				
+
 				rayInfo.x = hitx + math_cos(self_angle) * -1
 				rayInfo.y = hity + math_sin(self_angle) * -1
-				
+
 				self:performReaction(rayInfo)
 			end
 		end
 	end
-	
+
 	if not self.fluidType then
 		local speed = self:getSpeed()
-		
+
 		self:stopSpeedXY(0.03 * speed, 0.03 * speed, time)
-		
+
 		local dist = math_distance(self.x, self.y, nextX, nextY)
-		
+
 		self.trailDist = self.trailDist + dist
-		
+
 		local lastX = self.x
 		local lastY = self.y
-		
+
 		if self.trailDist > 45 then
 			while self.trailDist > 45 do
 				local angleTo = math_angleBetweenPoints(lastX, lastY, nextX, nextY)
-				local midX, midY = lastX + math_cos(angleTo) * math_min(45, self.trailDist), lastY + math_sin(angleTo) * math_min(45, self.trailDist)
+				local midX, midY = lastX + math_cos(angleTo) * math_min(45, self.trailDist),
+						lastY + math_sin(angleTo) * math_min(45, self.trailDist)
 				local fx = self:emitFxAt("railTwigglyTrail", midX, midY)
-				
+
 				fx:setMasterScale(self.def.trailScale or 1)
 				fx:setSpeed(angleTo + half_pi, math_random(80) - math_random(80))
-				
+
 				if self.trailFx then
 					fx:setTarget(self.trailFx)
 				else
 					fx:setEnd(self.x, self.y)
 				end
-				
+
 				lastX = midX
 				lastY = midY
 				self.trailFx = fx
@@ -9855,11 +9941,11 @@
 	elseif self.trailFx then
 		self.trailFx = nil
 	end
-	
+
 	self:modifyPosition(nextX, nextY)
-	
+
 	self.wobbleTimer = self.wobbleTimer + time
-	
+
 	if self.time > self.lifeTime then
 		self:performReaction()
 	end
@@ -9868,30 +9954,30 @@
 local function slugVisualReaction(self, x, y, angle, target)
 	self.x = x
 	self.y = y
-	
+
 	local detail = _config.graphicsFx
 	local def = self.def
 	local markScale = def.markScale or 1
-	
+
 	if detail > 0 then
 		for i = 1, detail * math_ceil(math_random(4, 12) * markScale) do
 			local obj = self:emitSparkAt("railSpark", x, y)
-			
+
 			obj:setOwner(self)
 			obj:setSpeed(self.angle + math_random() * math_pi + half_pi, (math_random() * 44 + 5) * markScale)
-			
+
 			obj.time = math_random() * 0.4
 		end
 	end
-	
+
 	local markFx = def.markFx
 	local fx = self:emitPpFxAt(markFx, x, y)
-	
+
 	fx:setMasterScale(markScale)
 	fx:setOwner(self)
-	
+
 	local explosion = def.explosion
-	
+
 	if explosion then
 		self:emitExplosion(explosion, def.explosionIntensity or 1)
 	end
@@ -9923,7 +10009,7 @@
 	local x = self.x
 	local y = self.y
 	local speed_time = time * 20 / sp
-	
+
 	self.lx = math_approach(lx, x, speed_time + math_difference(lx, x) * speed_time)
 	self.ly = math_approach(ly, y, speed_time + math_difference(ly, y) * speed_time)
 end
@@ -9936,13 +10022,14 @@
 	local r = op * cr + iop * r
 	local g = op * cg + iop * g
 	local b = op * cb + iop * b
-	
+
 	if self.lx then
 		local lx, ly = x - self.x + self.lx, y - self.y + self.ly
-		
-		video.renderSpriteLine(lx, ly, x, y, 255, cr * op * 0.25, cg * op * 0.25, op * op * 0.5, SPRITES.lineAdditiveGlow, true, self.def.trail_width)
+
+		video.renderSpriteLine(lx, ly, x, y, 255, cr * op * 0.25, cg * op * 0.25, op * op * 0.5, SPRITES.lineAdditiveGlow,
+			true, self.def.trail_width)
 	end
-	
+
 	video.renderSpriteState(self.def.sprite, x, y, 1, self.angle, 255, r, g, b, self.flipped)
 end
 
@@ -10214,7 +10301,7 @@
 local function burnerFlameObjectInit(self)
 	self:emitReferenceFx("burnerFlame", "flameFx")
 	self:emitReferenceFx("burnerFlameLong", "longFx")
-	
+
 	self.hitDelay = self.hitDelay or 0
 	self.savedTarget = nil
 	self.range = self.range or 500
@@ -10238,13 +10325,13 @@
 	onRemovedMethod = function(self)
 		if self.flameFx then
 			self.flameFx:remove()
-			
+
 			self.flameFx = nil
 		end
-		
+
 		if self.longFx then
 			self.longFx:remove()
-			
+
 			self.longFx = nil
 		end
 	end,
@@ -10263,17 +10350,17 @@
 
 local function burnerFlameSmallObjectInit(self)
 	local f = self:emitFx("burnerFlameSmall")
-	
+
 	self.flameFx = f
-	
+
 	f:setReference(self)
-	
+
 	local f = self:emitFx("burnerFlameLong")
-	
+
 	self.longFx = f
-	
+
 	f:setReference(self)
-	
+
 	self.hitDelay = self.hitDelay or 0
 	self.savedTarget = nil
 	self.range = self.range or 200
@@ -10299,13 +10386,13 @@
 	onRemovedMethod = function(self)
 		if self.flameFx then
 			self.flameFx:remove()
-			
+
 			self.flameFx = nil
 		end
-		
+
 		if self.longFx then
 			self.longFx:remove()
-			
+
 			self.longFx = nil
 		end
 	end,
@@ -10325,16 +10412,16 @@
 local function beamRayObjectInit(self)
 	self.alpha = self.alpha or 1
 	self.charge = self.charge or 1
-	
+
 	self:setBounds()
-	
+
 	self.hitFxDelay = self.hitFxDelay or 0
 	self.power = self.power or 0
-	
+
 	if self.beam == nil then
 		self.beam = true
 	end
-	
+
 	self.lastX = self.lastX or self.x
 	self.lastY = self.lastY or self.y
 	self.lastAngle = self.lastAngle or self.angle
@@ -10365,46 +10452,52 @@
 		local startX, startY = x - self.x + self.lastX, y - self.y + self.lastY
 		local widthA, widthB, widthC = self.def.getWidths(self)
 		local alp = 0.5 * math_min(255, 255 * self.alpha * math_easeOut(math_min(1, self.power)))
-		
+
 		video.renderBeamSprite(self.def.sprite, startX, startY, x, y, widthA, alp, 50, 156, 255)
-		
+
 		local sprite = self.def.customSprites.white
-		
+
 		video.renderBeamSprite(sprite, startX, startY, x, y, widthB, alp, 80, 208, 255)
 		video.renderBeamSprite(sprite, startX, startY, x, y, widthC, alp, 190, 248, 255)
 	end,
 	getWidths = function(self)
 		local _time = _time
-		local widthA = 1 + (8 + math_cos(_time * 97) * 3 * math_easeOut(math_min(1, self.power * self.alpha))) * math_easeOut(math_min(1, self.power * self.alpha * 0.7))
-		local widthB = (7 + math_cos(_time * 97) * 3 * self.power * self.alpha) * math_min(1, math_max(0, self.power * self.alpha - 0.4) / 0.25)
-		local widthC = (8 + math_cos(_time * 97) * 3 * self.power * self.alpha) * math_min(1, math_max(0, self.power * self.alpha - 1.2) / 0.25)
-		
+		local widthA = 1 +
+		(8 + math_cos(_time * 97) * 3 * math_easeOut(math_min(1, self.power * self.alpha))) *
+		math_easeOut(math_min(1, self.power * self.alpha * 0.7))
+		local widthB = (7 + math_cos(_time * 97) * 3 * self.power * self.alpha) *
+		math_min(1, math_max(0, self.power * self.alpha - 0.4) / 0.25)
+		local widthC = (8 + math_cos(_time * 97) * 3 * self.power * self.alpha) *
+		math_min(1, math_max(0, self.power * self.alpha - 1.2) / 0.25)
+
 		return widthA, widthB, widthC
 	end,
 	getLightWidth = function(self)
-		return (10 + math_cos(_time * 97) * 1 * self.power * self.alpha) * math_min(2, math_max(0, math_easeOut(math_min(1, self.power * self.alpha * 0.7)) - 0.45) / 0.15)
+		return (10 + math_cos(_time * 97) * 1 * self.power * self.alpha) *
+		math_min(2, math_max(0, math_easeOut(math_min(1, self.power * self.alpha * 0.7)) - 0.45) / 0.15)
 	end,
 	lightMapRenderMethod = function(self, x, y)
 		local startX, startY = x - self.x + self.lastX, y - self.y + self.lastY
 		local widthC = self.def.getLightWidth(self)
-		
-		video.renderBeamSprite(self.def.customSprites.additive, startX, startY, x, y, widthC, math_min(64, 64 * self.alpha * math_easeOut(math_min(1, self.power))), 80, 245, 255)
+
+		video.renderBeamSprite(self.def.customSprites.additive, startX, startY, x, y, widthC,
+			math_min(64, 64 * self.alpha * math_easeOut(math_min(1, self.power))), 80, 245, 255)
 	end,
 	initMethod = beamRayObjectInit,
 	onRemovedMethod = function(self)
 		if self.muzzle then
 			self.muzzle:remove()
 		end
-		
+
 		if self.hitFx then
 			self.hitFx:remove()
-			
+
 			self.hitFx = nil
 		end
-		
+
 		if self.muzzle then
 			self.muzzle:remove()
-			
+
 			self.muzzle = nil
 		end
 	end,
@@ -10413,39 +10506,39 @@
 	end,
 	updateMethod = function(self, time)
 		self.time = self.time + time
-		
+
 		local speed = self:getSpeed()
-		
+
 		if self.beam then
 			local clear, target, x, y, angle = self:getLosForward(speed / self.map.resolution * time, LOS.bullet)
-			
+
 			if not clear then
 				if target then
 					local impact = self:losToImpact(not clear, target, x, y, angle)
 					local ix = impact.x or self.x
 					local ix, iy = ix, impact.y or self.y
-					
+
 					if not self.hitFx or self.hitFx._remove then
 						self.hitFx = self:emitPpFxAt("beamMark", ix, iy)
 					end
-					
+
 					self.hitFx:setPosition(ix, iy)
 					self.hitFx:setTime(math_min(3, self.power * self.power))
-					
+
 					if impact.target and impact.target ~= self.owner then
 						impact.damageModifier = self.power * self.charge
-						
+
 						impact.target:hit(impact, impact.target._category == "actor" and self:getAttack() or ATTACKS.beamObject)
-						
+
 						local detail = _config.graphicsFx
-						
+
 						if detail > 0 and detail > math_random() then
 							if impact.target._category == "actor" then
 								if math_random() <= 0.2 then
 									local obj = self:emitSparkAt("beamMiniSpark", ix, iy)
-									
+
 									obj:setSpeed(math_random() * math_pi * 2, 2 + 5 * self.power + math_random() * 10 * self.power)
-									
+
 									obj.time = 0
 									obj.airFriction = 0
 									obj.gravity = 28
@@ -10459,22 +10552,22 @@
 						end
 					end
 				end
-				
+
 				self.beam = false
 			end
-			
+
 			self:setPosition(x, y)
 		end
-		
+
 		local owner = self.owner
 		local x, y = self.x, self.y
 		local lastX, lastY = self.lastX, self.lastY
-		
+
 		if self.time > self.def.fullChargeTime then
 			local prg = (self.time - self.def.fullChargeTime) / (self.def.lifeTime - self.def.fullChargeTime)
 			local angle = math_angleBetweenPoints(lastX, lastY, x, y)
 			local dist = math_distance(lastX, lastY, x, y)
-			
+
 			lastX = math_approach(lastX, x, math_abs(math_cos(angle)) * dist * prg)
 			lastY = math_approach(lastY, y, math_abs(math_sin(angle)) * dist * prg)
 			self.lastX = lastX
@@ -10483,13 +10576,13 @@
 			self.charge = 1 - prg
 		elseif owner and owner.map then
 			local wx, wy = owner:getSafeNodeXY(self.node or "weapon")
-			
+
 			self.lastX = wx
 			self.lastY = wy
 		end
-		
+
 		self:setBounds(math_min(lastX, x), math_min(lastY, y), math_max(lastX, x), math_max(lastY, y))
-		
+
 		if self.time > self.def.lifeTime then
 			self:remove()
 		end
@@ -10503,7 +10596,7 @@
 	},
 	getBulletTimeFactor = function(self)
 		local pow = math.min(1, self.power / 6)
-		
+
 		return math.min(1, pow * pow + 0.1) * 0.75
 	end,
 	network = {
@@ -10515,7 +10608,7 @@
 local function beamRayWarningObjectInit(self)
 	self.beam = self.beam or false
 	self.alpha = self.alpha or 0.15
-	
+
 	self:setBounds()
 end
 
@@ -10535,47 +10628,52 @@
 			local realAngle = self.angle
 			local sx1, sy1 = x + math_cos(realAngle - half_pi) * width, y + math_sin(realAngle - half_pi) * width
 			local sx2, sy2 = x + math_cos(realAngle + half_pi) * width, y + math_sin(realAngle + half_pi) * width
-			local tx1, ty1 = x + math_cos(realAngle) * self.dist + math_cos(realAngle - half_pi) * width, y + math_sin(realAngle) * self.dist + math_sin(realAngle - half_pi) * width
-			local tx2, ty2 = x + math_cos(realAngle) * self.dist + math_cos(realAngle + half_pi) * width, y + math_sin(realAngle) * self.dist + math_sin(realAngle + half_pi) * width
-			
-			video.renderSpriteStateFreeShape(self.def.sprite, sx1, sy1, tx1, ty1, sx2, sy2, tx2, ty2, 255 * self.alpha, 255, 255, 255)
+			local tx1, ty1 = x + math_cos(realAngle) * self.dist + math_cos(realAngle - half_pi) * width,
+					y + math_sin(realAngle) * self.dist + math_sin(realAngle - half_pi) * width
+			local tx2, ty2 = x + math_cos(realAngle) * self.dist + math_cos(realAngle + half_pi) * width,
+					y + math_sin(realAngle) * self.dist + math_sin(realAngle + half_pi) * width
+
+			video.renderSpriteStateFreeShape(self.def.sprite, sx1, sy1, tx1, ty1, sx2, sy2, tx2, ty2, 255 * self.alpha, 255,
+				255, 255)
 		end
 	end,
 	initMethod = beamRayWarningObjectInit,
 	lifeTime = ITEMS.beamGun.firingTime,
 	updateMethod = function(self, time)
 		self.time = self.time + time
-		
+
 		if self.spawned or self.owner and not self.owner.killed and self.owner.isAble then
 			local x, y = self.owner:getSafeWeaponXY()
-			
+
 			self:setPosition(x, y)
 			self:setAngle(self.owner:getAbsoluteWeaponAngle())
-			
+
 			self.beam = false
-			
+
 			local impact = self:losToImpact(self:getLosForward(self.range, LOS.bullet))
-			
+
 			if impact then
 				if impact.x and impact.y then
 					self.dist = math_distance(self.x, self.y, impact.x, impact.y)
 				else
 					self.dist = self.range
 				end
-				
+
 				self.beam = true
 			else
 				self.dist = self.range
 				self.beam = true
 			end
-			
+
 			local angle = self.angle
-			
-			self:setBounds(math_min(self.x, self.x + math_cos(angle) * self.dist), math_min(self.y, self.y + math_sin(angle) * self.dist), math_max(self.x, self.x + math_cos(angle) * self.dist), math_max(self.y, self.y + math_sin(angle) * self.dist))
+
+			self:setBounds(math_min(self.x, self.x + math_cos(angle) * self.dist),
+				math_min(self.y, self.y + math_sin(angle) * self.dist), math_max(self.x, self.x + math_cos(angle) * self.dist),
+				math_max(self.y, self.y + math_sin(angle) * self.dist))
 		else
 			self:remove()
 		end
-		
+
 		if self.lifeTime and self.time > self.lifeTime then
 			self:remove()
 		end
@@ -10889,7 +10987,7 @@
 	renderMethod = function(self, x, y, r, g, b)
 		if self.proximity then
 			video.renderSpriteState(self.def.customSprites.proximity, x, y, 1, self.angle, 255, r, g, b, self.flipped)
-			
+
 			if math.cos(self.totalTimer * math_pi * 12) > -0.25 then
 				video.renderSpriteState(self.def.customSprites.glow, x, y, 1, self.angle, 255, 255, 255, 255, self.flipped)
 			end
@@ -10986,14 +11084,16 @@
 	renderMethod = function(self, x, y, r, g, b)
 		local def = self.def
 		local angle = self.angle
-		
+
 		video.renderSpriteState(def.sprite, x, y, 1, angle, 255, r, g, b, self.flipped)
-		
+
 		local prg = self.totalTimer * 10
 		local cusprites = def.customSprites
-		
-		video.renderSpriteState(cusprites.glow1, x, y, 1, angle, math_min(255, math_abs(math_cos(prg) * math_cos(prg) * 255) * 3), 255, 255, 255, self.flipped)
-		video.renderSpriteState(cusprites.glow2, x, y, 1, angle, math_min(255, math_abs(math_cos(prg) * math_sin(prg) * 255) * 3), 255, 255, 255, self.flipped)
+
+		video.renderSpriteState(cusprites.glow1, x, y, 1, angle,
+			math_min(255, math_abs(math_cos(prg) * math_cos(prg) * 255) * 3), 255, 255, 255, self.flipped)
+		video.renderSpriteState(cusprites.glow2, x, y, 1, angle,
+			math_min(255, math_abs(math_cos(prg) * math_sin(prg) * 255) * 3), 255, 255, 255, self.flipped)
 	end,
 	logic = {
 		"missile",
@@ -11033,27 +11133,27 @@
 	local x = impact.x or self.x
 	local x, y = x, impact.y or self.y
 	local angle = impact.angle or self.angle + math_pi
-	
+
 	if self.hitForce then
 		self:emitSound("phaserChargeHit", 1, 1)
-		
+
 		if hit and impact.target._category == "actor" then
 			self:emitOmniForceAt(x - math_cos(angle) * 1, y - math_sin(angle) * 1, 120 + 0.67 * self.hitForce, self.hitForce)
-			
+
 			if self.griplessForce then
 				impact.target:gripless(self.griplessForce)
 			end
 		elseif collide then
 			self.owner:resetUseTimer(0.75)
 			self:emitOmniForceAt(x - math_cos(angle) * 1, y - math_sin(angle) * 1, 120 + 0.67 * self.hitForce, self.hitForce)
-			
+
 			local ang = math_angleBetweenPoints(x, y, self.owner.x, self.owner.y)
-			
+
 			self.owner:propel(ang, self.hitForce * 0.8)
 			self:applyForce(self.angle + math.pi, 6 * self.hitForce)
 		end
 	end
-	
+
 	if hit then
 		self:performReaction(impact)
 		impact.target:applyForce(self.angle, 10, x, y)
@@ -11062,9 +11162,9 @@
 
 local function phaserBulletCollision(self, impact)
 	impact.damageModifier = self.damageModifier or 1
-	
+
 	local collide, hit = genericCheckHit(self, impact, self:getAttack())
-	
+
 	phaseBulletEffect(self, impact, collide, hit)
 end
 
@@ -11091,12 +11191,12 @@
 	end,
 	hitMethod = function(self, impact, attack)
 		local owner = impact.owner
-		
+
 		impact.target = owner
 		impact.owner = self
-		
+
 		phaseBulletEffect(self, impact, true, true)
-		
+
 		return true
 	end,
 	updateMethod = phaserBulletObjectUpdate,
@@ -11169,20 +11269,25 @@
 		local angle = self.angle
 		local color = self.color
 		local r, g, b = color.r, color.g, color.b
-		
-		video.renderSpriteState(sprite, x, y, pow_int * 1 + math_cos(time_pi * 2) * 0.2, angle + time_pi * 3, 255, r, g, b, flipped)
-		video.renderSpriteState(sprite, x, y, pow_int * 0.9 + math_cos(time_pi * 1.2) * 0.1, angle + time_pi * 1.25, 255, r, g, b, flipped)
-		
+
+		video.renderSpriteState(sprite, x, y, pow_int * 1 + math_cos(time_pi * 2) * 0.2, angle + time_pi * 3, 255, r, g, b,
+			flipped)
+		video.renderSpriteState(sprite, x, y, pow_int * 0.9 + math_cos(time_pi * 1.2) * 0.1, angle + time_pi * 1.25, 255, r,
+			g, b, flipped)
+
 		local br, bg, bb = math_min(255, r + 128), math_min(255, g + 128), math_min(255, b + 128)
-		
-		video.renderSpriteState(sprite, x, y, pow_int * 0.4 - math_cos(time_pi * 3.2) * 0.2, angle - time_pi * 3, 255, br, bg, bb, flipped)
-		video.renderSpriteState(sprite, x, y, pow_int * 0.3 + math_sin(time_pi * 2.5) * 0.1, angle - time_pi * 1.75, 255, br, bg, bb, flipped)
+
+		video.renderSpriteState(sprite, x, y, pow_int * 0.4 - math_cos(time_pi * 3.2) * 0.2, angle - time_pi * 3, 255, br, bg,
+			bb, flipped)
+		video.renderSpriteState(sprite, x, y, pow_int * 0.3 + math_sin(time_pi * 2.5) * 0.1, angle - time_pi * 1.75, 255, br,
+			bg, bb, flipped)
 	end,
 	lightMapRenderMethod = function(self, x, y)
 		local color = self.color
 		local r, g, b = color.r, color.g, color.b
-		
-		video.renderAdditiveSpriteState(FX.glow.sprite, x, y, self.power * (0.15 + math_abs(math_sin(_time * math_pi * 9.5)) * 0.2), 0, r, g, b, self.flipped)
+
+		video.renderAdditiveSpriteState(FX.glow.sprite, x, y,
+			self.power * (0.15 + math_abs(math_sin(_time * math_pi * 9.5)) * 0.2), 0, r, g, b, self.flipped)
 	end,
 	initMethod = blasterObjectInit,
 	initRuntimeMethod = function(self)
@@ -11196,9 +11301,9 @@
 	color = COLORS.object_blaster,
 	updateMethod = function(self, time)
 		self.time = self.time + time
-		
+
 		local lifeTime = self.lifeTime
-		
+
 		if lifeTime and lifeTime < self.time then
 			self:performReaction()
 		end
@@ -11206,29 +11311,29 @@
 	updateVisualMethod = function(self, time)
 		local lifeTime = self.lifeTime
 		local factor = self.def.intensity_lifetime_factor
-		
+
 		self.intensity = math_min(1, factor - factor * (self.time / lifeTime))
 	end,
 	hitMethod = function(self, impact)
 		if self.hitActive then
 			self:performReaction(impact)
-			
+
 			return true
 		end
 	end,
 	collisionMethod = function(self, impact)
 		local target = impact.target
-		
+
 		if not target then
 			self:hitSound(impact)
 			self:performReaction(impact)
 		else
 			local hit, damage = target:hit(impact, self:getAttack(), self.intensity)
-			
+
 			if damage > 0 then
 				self:hitSound(impact)
 			end
-			
+
 			if hit then
 				self:performReaction(impact)
 			end
@@ -11257,38 +11362,38 @@
 	visualReactionMethod = function(self, x, y, angle)
 		local intensity = self.intensity or 1
 		local power = self.power or 1
-		
+
 		self:emitExplosion(self.def.explosion, intensity * power * self.def.explosionIntensity)
-		
+
 		local fx_color = self.color or self.def.color or COLORS.object_blaster
-		
+
 		for i = 1, 3 + math_random(3) do
 			local fx = self:emitFx("blasterHaloWhite")
-			
+
 			fx:applyColor(fx_color)
 		end
-		
+
 		self:emitSound("blasterDie", 1, 1, 900)
-		
+
 		local fx = self:emitFx("blasterHaloWhite")
-		
+
 		fx:applyColor(fx_color)
-		
+
 		fx.masterScale = power
-		
+
 		for i = 1, 6 + math_random(3) do
 			local fx = self:emitFx("blasterBoltWhite")
-			
+
 			fx:setOwner(self)
 			fx:applyColor(fx_color)
-			
+
 			local dist = power * (math_random() * 110 + 70)
 			local angle = math_random() * math_pi * 2
-			
+
 			fx.endX = self.x + math_cos(angle) * dist
 			fx.endY = self.y + math_sin(angle) * dist
 		end
-		
+
 		self:emitSound("blasterHit", 1, 1, 1200)
 	end,
 	editor = {
@@ -11333,26 +11438,27 @@
 		local fluct = math_min(1, power) * math_abs(math_cos(self.totalMotion / 20))
 		local li = math_min(255, fluct * 20)
 		local cusprites = def.customSprites
-		
-		video.renderAdditiveSpriteState(cusprites.glow, x, y, math_easeOut(math_sqrt(power)) * 0.5, self.angle + spinTimer * math_pi * iff + math_pi * 1.5, li, li, li, self.flipped)
-		
+
+		video.renderAdditiveSpriteState(cusprites.glow, x, y, math_easeOut(math_sqrt(power)) * 0.5,
+			self.angle + spinTimer * math_pi * iff + math_pi * 1.5, li, li, li, self.flipped)
+
 		if self.lx then
 			local lx, ly = x - self.x + self.lx, y - self.y + self.ly
 			local op = math_min(power * 0.75, 1) * 0.5
-			
+
 			video.renderSpriteLine(lx, ly, x, y, 64, 255 * op, 180 * op, 60 * op, SPRITES.lineAdditiveGlow, true, 4 + 2 * power)
 		end
-		
+
 		local winAmt = 0.25
 		local wing = cusprites.wing
-		
+
 		if self.spin > 0 then
 			local spinAmt = math_min(1, 4 * self.spin)
 			local sc = spinAmt * self.wingTimer * (0.25 + 0.75 * math_sqrt(power))
 			local ang = self.angle + spinTimer * math_pi * iff
 			local alpha = winAmt * math_min(255, 255 * (0.5 + power * 0.5))
 			local flipped = self.flipped
-			
+
 			video.renderSpriteState(wing, x, y, sc, ang, alpha, r, g, b, flipped)
 			video.renderSpriteState(wing, x, y, sc, ang + half_pi, alpha, r, g, b, flipped)
 			video.renderSpriteState(wing, x, y, sc, ang + math_pi * 1, alpha, r, g, b, flipped)
@@ -11362,11 +11468,11 @@
 			local bangle = self.angle + math_pi * 1.5
 			local wangle = math_cos(self.totalMotion * 0.05) * math_pi * 0.07
 			local alpha = winAmt * math_min(255, 255 * (0.5 + power * 0.5))
-			
+
 			video.renderSpriteState(wing, x, y, sc, bangle + wangle, alpha, r, g, b, false)
 			video.renderSpriteState(wing, x, y, sc, bangle - wangle, alpha, r, g, b, true)
 		end
-		
+
 		video.renderSpriteState(def.sprite, x, y, math_min(1, math_easeOut(self.startPower * 0.75)), self.angle, 255, r, g, b)
 	end,
 	lightMapRenderMethod = function(self, x, y)
@@ -11374,8 +11480,9 @@
 		local pf = math_min(1, sqpow)
 		local fluct = pf * math_abs(math_cos(self.totalMotion / 20))
 		local li = pf * math_min(255, 30 + fluct * 10)
-		
-		video.renderRawAdditiveSpriteState(self.def.customSprites.glow, x, y, math_easeOut(sqpow * 0.75) * 1.25 + pf * 1.25 + fluct * 0.25, 0, li, li, li, self.flipped)
+
+		video.renderRawAdditiveSpriteState(self.def.customSprites.glow, x, y,
+			math_easeOut(sqpow * 0.75) * 1.25 + pf * 1.25 + fluct * 0.25, 0, li, li, li, self.flipped)
 	end,
 	initMethod = genericInitPlasma,
 	initRuntimeMethod = function(self)
@@ -11385,9 +11492,9 @@
 		self.totalMotion = 0
 		self.startPower = self.power or 1
 		self.wingTimer = 0
-		
+
 		self:setHitActive(true)
-		
+
 		self.collided = false
 		self.thrustTimer = 0
 		self.lx = self.x
@@ -11399,24 +11506,24 @@
 	updateRenderMethod = function(self, time)
 		if self.fluidType and math_random() < time * 20 then
 			local fluidDef = DEFS.FLUIDS[self.fluidType]
-			
+
 			if fluidDef.onExplosion then
 				fluidDef.onExplosion(self, 0.1)
 			end
 		end
-		
+
 		if self.sparkDelay > 0 then
 			self.sparkVolume = math_min(1, self.sparkVolume + time / 0.1)
 		end
-		
+
 		if self.sparkVolume > 0 and self.slide then
 			self:emitLoop("plasma", self.sparkVolume * 0.3, 2, self.sparkVolume * RANGES.medium)
 		end
-		
+
 		self.sparkDelay = self.sparkDelay - time
-		
+
 		local sp = math_max(self.timeFactor, MIN_TF) * math_min(1, self.power)
-		
+
 		self.lx = math_approach(self.lx, self.x, time * 10 / sp + math_difference(self.lx, self.x) * time * 15 / sp)
 		self.ly = math_approach(self.ly, self.y, time * 10 / sp + math_difference(self.ly, self.y) * time * 15 / sp)
 		self.spinTimer = self.spinTimer + time * 9 * self.spin
@@ -11427,40 +11534,40 @@
 		if self.lastX and self.lastY then
 			self.totalMotion = self.totalMotion + math_distance(self.x, self.y, self.lastX, self.lastY)
 		end
-		
+
 		local def = self.def
-		
+
 		if self.fluidType and self.fluidType == "water" then
 			self.power = math_max(0, self.power - time * 20)
 		end
-		
+
 		if self.power <= 0 then
 			self:disableHit()
 		end
-		
+
 		local thrust_spin = def.thrust_spin_factor
-		
+
 		if thrust_spin > 0 then
 			self:addSpeed(self.angle, 0.1 * self.spin * self.wingTimer * thrust_spin, 1)
 		end
-		
+
 		self.spin = math_max(0, self.spin - time * 0.2)
-		
+
 		local wingTimer = self.wingTimer
-		
+
 		if self.spin > 0 then
 			wingTimer = math_min(1, wingTimer + time * 15)
-			
+
 			if self.collided then
 				self.spin = self.spin - time * 0.4
 				self.time = math_max(0, self.time - time * self.spin)
-				
+
 				local factor = def.thrust_spin_ground_factor
 				local rel_angle = self.groundAngle + (self.flipped and math.pi * 0.5 or -math.pi * 0.5)
-				
+
 				self:addSpeed(rel_angle, time * 250 * wingTimer * factor)
 				self:addSpeed(self.groundAngle, time * 50 * wingTimer * factor)
-				
+
 				if self.onGround then
 					self:addSpeed(self.angle, 1 * self.spin, 1)
 				end
@@ -11468,38 +11575,38 @@
 		else
 			wingTimer = math_max(0, wingTimer - time * 15)
 		end
-		
+
 		self.wingTimer = wingTimer
-		
+
 		local thrust = self.thrustTimer * def.thrust_ground_factor
-		
+
 		if thrust > 0 then
 			self:stopSpeed(self.angle, time, self:getSpeed() * thrust * 0.5)
 			self:addSpeed(self.angle, (0.5 + 0.5 * self.power) * 50 * time * thrust)
-			
+
 			thrust = math_max(0, thrust - time)
 			self.totalMotion = self.totalMotion + thrust * time * 2000
 		end
-		
+
 		if self.time < self.lifeTime then
 			self.time = self.time + time
 		else
 			self.time = self.time + time
 			self.power = math_max(0, self.power - time * 2 - 20 / (1 + self.power) * time)
 		end
-		
+
 		if not self.hitActive then
 			local fx = self:emitFx("plasmaSmoke")
-			
+
 			fx:setTime(0)
-			
+
 			local fx = self:emitFx("plasmaAirMark")
-			
+
 			self:remove()
-			
-			return 
+
+			return
 		end
-		
+
 		self.lastX = self.x
 		self.lastY = self.y
 	end,
@@ -11508,62 +11615,62 @@
 	end,
 	collisionMethod = function(self, impact, time)
 		impact.damageModifier = self:getPowerDamageModifier(self.power)
-		
+
 		if not impact.target then
-			return 
+			return
 		end
-		
+
 		self.lx = self.x
 		self.ly = self.y
-		
+
 		local attack = self:getAttack()
 		local hit, damageDone, hurt = impact.target:hit(impact, attack)
-		
+
 		if hurt then
 			self.power = self.power - (damageDone or 1) / attack.overall_power
 		end
-		
+
 		if hit and impact.target and impact.target._category == "actor" then
 			if self.power <= 0 then
 				self:performReaction(impact)
 			end
-			
+
 			if not impact.target:setSlowed(0.5, 0.3, false) then
 				impact.target:setDamaged(0.33)
 			end
-			
+
 			self:stopSpeed(self.angle, time, self.power * self:getSpeed() * 5)
 		elseif hit then
 			local x = impact.x or self.x
 			local x, y = x, impact.y or self.y
-			
+
 			self.thrustTimer = 1
-			
+
 			if self.spin > 0 then
 				local stopPower = self:getSpeed() * 0.5
-				
+
 				self:stopSpeed(self.angle, time, stopPower)
-				
+
 				self.collided = true
 				self.groundAngle = impact.angle
-				
+
 				self:slideWithVector(impact.angle, 0)
 				self:bounceWithVector(impact.angle, self.spin * impact.impulse)
-				
+
 				self.spin = math_max(0, self.spin - stopPower * 0.05 * time)
-				
+
 				if impact.impulse > 0 and self.sparkDelay <= 0 then
 					self:emitFxAt("plasmaGlow", x, y)
-					
+
 					self.sparkDelay = math_random() * 0.1 + 0.05
 				end
 			else
 				if impact.target and impact.target._category == "tile" then
 					local fx = self:emitPpFxAt("plasmaMark", x, y)
-					
+
 					fx:setTime(math_max(0, 3 - 3 * self.power))
 				end
-				
+
 				self:performReaction(impact)
 			end
 		end
@@ -11571,24 +11678,25 @@
 	visualReactionMethod = function(self, x, y, angle)
 		local fx = self:emitFxAt("plasmaSmokeBig", self.x, self.y)
 		local power = self.power
-		
+
 		fx:setTime(math_max(0, 1 - power))
-		self:emitSoundAt("plasmaHit", x, y, math_easeOut(math_min(1, self.power)), 1.75 - 1.25 * math_easeOut(math_min(1, self.power)), 500 * self.power)
-		
+		self:emitSoundAt("plasmaHit", x, y, math_easeOut(math_min(1, self.power)),
+			1.75 - 1.25 * math_easeOut(math_min(1, self.power)), 500 * self.power)
+
 		local detail = _config.graphicsFx
-		
+
 		if detail > 0 then
 			for i = 1, math_min(3, math_random(1, math_max(2, math_floor(3 * power)))) * detail do
 				local obj = self:emitSpark("redderSpark")
-				
+
 				obj:setSpeed(self.angle, 2 + math_random() * 12)
 				obj:addSpeed(math_random() * math_pi * 2, math_random() * 6)
-				
+
 				obj.airFriction = 0
 				obj.gravity = 28
-				
+
 				obj.myFx:setTime(math.clamp(1 - power, 0, 1))
-				
+
 				obj.collisionTimeFactor = 10
 				obj.deathFxName = "postTinySpark"
 				obj.collisionSound = "fizzleSpark"
@@ -11664,22 +11772,24 @@
 		local r, g, b = math_min(255, r + 255 * power), math_min(255, g + 255 * power), math_min(255, b + 255 * power)
 		local angle = self.angle
 		local def = self.def
-		
-		video.renderSpriteState(def.sprite, x, y, 1, angle + self.spinTimer, math_min(255, math_easeOut(math_min(1, power)) * 255), 255, 255, 255)
-		video.renderSpriteState(def.customSprites.dust, x, y, 1.2, angle + self.spinTimer * 2, 128 + math_cos(_time * 15) * 127, 255, 255, 255)
+
+		video.renderSpriteState(def.sprite, x, y, 1, angle + self.spinTimer,
+			math_min(255, math_easeOut(math_min(1, power)) * 255), 255, 255, 255)
+		video.renderSpriteState(def.customSprites.dust, x, y, 1.2, angle + self.spinTimer * 2,
+			128 + math_cos(_time * 15) * 127, 255, 255, 255)
 	end,
 	initMethod = chemicalObjectInit,
 	onRemovedMethod = function(self)
 		local trailMakerFx = self.trailMakerFx
-		
+
 		if trailMakerFx and not trailMakerFx._remove then
 			trailMakerFx:setPosition(self.x, self.y)
-			
+
 			trailMakerFx.distanceMoved = 1000
-			
+
 			trailMakerFx:update(0.1)
 			trailMakerFx:remove()
-			
+
 			self.trailMakerFx = nil
 		end
 	end,
@@ -11687,9 +11797,9 @@
 		if self.fluidType and math_random() < time * 20 and self.fluidType and DEFS.FLUIDS[self.fluidType].onExplosion then
 			DEFS.FLUIDS[self.fluidType].onExplosion(self, 0.1)
 		end
-		
+
 		local trailMakerFx = self.trailMakerFx
-		
+
 		if not trailMakerFx then
 			trailMakerFx = self:emitOwnedFx("chemicalTrailMaker")
 			self.trailMakerFx = trailMakerFx
@@ -11698,7 +11808,7 @@
 			trailMakerFx:setTime(0)
 			trailMakerFx:setPosition(self.x, self.y)
 		end
-		
+
 		self.spinTimer = math_max(0, self.spinTimer + time * 0.2 * (self.flipped and -1 or 1))
 		self.spinTimer = self.spinTimer + time * 4 * math_max(0, math_min(1, self.lifeTime - self.time))
 	end,
@@ -11706,25 +11816,25 @@
 		if self.fluidType and self.fluidType == "water" then
 			self.power = math_max(0, self.power - time * 20)
 		end
-		
+
 		if self.target then
 			local def = self.def
-			
+
 			self:followTarget(def.follow_speed, def.follow_stopping, def.follow_rotation, time, def.follow_carving)
 		end
-		
+
 		if self.homing then
 			self:updateSpecial("homing", time)
 		end
-		
+
 		if self.ghosting then
 			self.ghosting = false
 		elseif self.ghosting ~= nil then
 			self:setGravity(self:getGravity())
-			
+
 			self.ghosting = nil
 		end
-		
+
 		if self.time < self.lifeTime then
 			self.time = self.time + time
 		else
@@ -11740,43 +11850,43 @@
 	collisionMethod = function(self, impact, time)
 		local attack = self:getAttack()
 		local hit, damageDone, hurt = impact.target:hit(impact, attack)
-		
+
 		if hit then
 			self:performReaction(impact)
 		end
 	end,
 	sensorMethod = function(self, impact, time)
 		self.power = self.power - time * self.def.ground_power_loss_rate
-		
+
 		if self.power <= 0 then
 			self:performReaction(impact)
 		end
-		
+
 		local speed = self:getSpeed()
 		local max_speed = self.def.ground_speed_max
-		
+
 		if max_speed < speed then
 			self:setSpeed(self:getSpeedAngle(), math_min(max_speed, speed))
 		end
-		
+
 		self.ghosting = true
-		
+
 		self:setGravity(0)
 	end,
 	visualReactionMethod = function(self, x, y, angle)
 		local detail = _config.graphicsFx
-		
+
 		if detail > 0 then
 			for i = 1, (4 + math_random(6)) * detail do
 				local fx = self:emitFx("chemicalSmoke")
-				
+
 				fx:setMasterScale(0.5)
 				fx:setSpeed(math_pi * 2 * math_random(), math_random(100))
 			end
 		end
-		
+
 		local fx = self:emitFx("chemicalFlash")
-		
+
 		fx:setMasterScale(0.5)
 		self:emitSound("chemical", 0.5, math_random() * 0.4 + 0.8, 200)
 	end,
@@ -11831,7 +11941,7 @@
 	sensorMethod = function(self, impact, time)
 		if impact.target then
 			impact.damageModifier = time
-			
+
 			impact.target:hit(impact, ATTACKS.jetFlame)
 		end
 	end,
@@ -11917,34 +12027,34 @@
 		if self.glowTimer then
 			r, g, b = self:getGlowColor(r, g, b)
 		end
-		
+
 		local ff = self.flipped and -1 or 1
 		local down_angle = self.angle + math.pi * 0.5
-		
+
 		x = x + math.cos(self.angle) * self.offset_x * ff + math.cos(down_angle) * self.offset_y
 		y = y + math.sin(self.angle) * self.offset_x * ff + math.sin(down_angle) * self.offset_y
-		
+
 		self.rig:renderComposite(x, y, not self.flipped, 255 * self.fade, r, g, b, self.debrisActor)
 	end,
 	initMethod = function(self, rig, composite, actor, rootNode)
 		self:setGray()
 		self:setRemovable()
-		
+
 		local rig = Rig:new(rig)
-		
+
 		rig:initComposite(composite, actor)
-		
+
 		self.rig = rig
 		self._physics = self.rig:getPhysicsDef()
-		
+
 		local offset_x = self._physics.offset_x
 		local offset_y = self._physics.offset_y
-		
+
 		self.offset_x = offset_x
 		self.offset_y = offset_y
-		
+
 		self:setPosition(self.x + offset_x, self.y + offset_y)
-		
+
 		self.debrisActor = actor
 		self.rootNode = rootNode
 	end,
@@ -11952,29 +12062,29 @@
 		if self.debrisActor and self.rig then
 			local rig = self.rig
 			local actor = self.debrisActor
-			
+
 			rig:applyCompositeNodeStates(actor.rig)
 			rig:copyNodeStates(actor.rig, self.rootNode)
 			rig:copyHull(actor.rig)
 			rig:applyDisabledBehaviours()
 			rig:applyCompositeColors(actor:getProfile(), actor.team, actor.tints, actor.use_simple_colors)
-			
+
 			self.compositeFade = 1
 		end
 	end,
 	updateMethod = function(self, time)
 		local fade = self.compositeFade
-		
+
 		if fade then
 			fade = fade - time
-			
+
 			local rig = self.rig
-			
+
 			rig:applyLinearCompositeFading(1 - fade)
-			
+
 			if fade <= 0 then
 				self.compositeFade = nil
-				
+
 				rig:applyCompositeLinear()
 				rig:applyDisabledBehaviours()
 			else
@@ -12031,22 +12141,23 @@
 	id = "tileDebris",
 	debris = true,
 	renderMethod = function(self, x, y, r, g, b)
-		video.renderSpriteState(self.tileDef.sprites[self.variation], x, y, self.scale, self.angle, 255, r, g, b, self.flipped)
+		video.renderSpriteState(self.tileDef.sprites[self.variation], x, y, self.scale, self.angle, 255, r, g, b,
+			self.flipped)
 	end,
 	initMethod = function(self, tileId)
 		self:setRemovable()
-		
+
 		self.tileId = tileId
-		
+
 		local tile_def = TILES[self.tileId]
-		
+
 		self.tileDef = tile_def
 		self._physics = tile_def.physics
 		self.variation = math_random(1, tile_def.variations)
 	end,
 	onAddedMethod = function(self)
 		local booker = self:getBooker()
-		
+
 		sprites.requireTile(booker, self.tileId)
 	end,
 	initRuntimeMethod = function(self)
@@ -12187,7 +12298,7 @@
 		if impact.target._category == "actor" then
 			impact.target:hit(impact, ATTACKS.lightGamma)
 		end
-		
+
 		self:performReaction(impact)
 	end,
 	sensorMethod = function(self, impact)
@@ -12246,24 +12357,26 @@
 	},
 	renderMethod = function(self, x, y, r, g, b)
 		local alpha = (self.fade or 1) * 255
-		
+
 		if self.children and #self.children > 0 then
-			video.renderSpriteState(self.def.sprites[self.variation], x + math_cos(self.angle) * -6, y + math_sin(self.angle) * -6, 1, self.angle, alpha, r, g, b, false)
+			video.renderSpriteState(self.def.sprites[self.variation], x + math_cos(self.angle) * -6,
+				y + math_sin(self.angle) * -6, 1, self.angle, alpha, r, g, b, false)
 		else
-			video.renderSpriteState(self.def.customSprites.cordPieceEnd, x + math_cos(self.angle) * -6, y + math_sin(self.angle) * -6, 1, self.angle, alpha, r, g, b, false)
+			video.renderSpriteState(self.def.customSprites.cordPieceEnd, x + math_cos(self.angle) * -6,
+				y + math_sin(self.angle) * -6, 1, self.angle, alpha, r, g, b, false)
 		end
 	end,
 	initMethod = cordObjectInit,
 	awakeMethod = function(self, time)
 		if self.silenceDelay > 0 then
 			self.silenceDelay = self.silenceDelay - time
-			
+
 			if not self.child and not self.sparkTimer and time > math_random() * 4 then
 				self:setSpark(math_random() * 0.3)
-				
+
 				for i = 1, math_random(7) + 4 do
 					local fx = self:emitFxAt("grenadeSpark", self.x + math_cos(self.angle) * 6, self.y + math_sin(self.angle) * 6)
-					
+
 					fx:setSpeed(math_random() * math_pi * 2, math_random(1200))
 					fx:setTime(math_random() * 0.01)
 					self:addSpeed(math_random() * math_pi * 2, math_random(20))
@@ -12338,9 +12451,10 @@
 		local angle = self.renderAngle + half_pi
 		local opacity = self.opacity
 		local color = self.color or COLORS.white
-		
+
 		video.renderSpriteState(def.sprites[variation], x, y, 1, angle, 255 * opacity, r, g, b, false)
-		video.renderSpriteState(def.customSprites[def.customSpriteNames[variation]], x, y, 1, angle, opacity * color.a, color.r, color.g, color.b, false)
+		video.renderSpriteState(def.customSprites[def.customSpriteNames[variation]], x, y, 1, angle, opacity * color.a,
+			color.r, color.g, color.b, false)
 	end,
 	lightMapRenderMethod = function(self, x, y)
 		local def = self.def
@@ -12348,18 +12462,19 @@
 		local angle = self.renderAngle + half_pi
 		local opacity = self.opacity
 		local color = self.color or COLORS.white
-		
-		video.renderSpriteState(def.customSprites[def.customSpriteNames[variation]], x, y, 1, angle, opacity * color.a, color.r, color.g, color.b, false)
+
+		video.renderSpriteState(def.customSprites[def.customSpriteNames[variation]], x, y, 1, angle, opacity * color.a,
+			color.r, color.g, color.b, false)
 	end,
 	updateRenderMethod = function(self)
 		local seed = self.seed
-		
+
 		self.opacity = 0.75 + 0.25 * math_cos(_time * 0.5 + seed * math_pi * 2) * math_cos(_time * 3.11 + seed * math_pi * 2)
 	end,
 	initMethod = jungleCordObjectInit,
 	awakeMethod = function(self, time)
 		local c = self.children and self.children[1]
-		
+
 		if c then
 			self.renderAngle = math_angleBetweenPoints(c.x, c.y, self.x, self.y)
 		end
@@ -12422,7 +12537,7 @@
 	end,
 	awakeMethod = function(self, time)
 		local c = self.children and self.children[1]
-		
+
 		if c then
 			self.renderAngle = math_angleBetweenPoints(c.x, c.y, self.x, self.y)
 		end
@@ -12493,15 +12608,15 @@
 	},
 	onAddedMethod = function(self)
 		if not RENDERING then
-			return 
+			return
 		end
-		
+
 		local def = self.def
 		local variation = self.variation
-		
+
 		if variation then
 			local variations = def.variations
-			
+
 			if self.isEnd and variations[variation] and variations[variation].endSprite then
 				self.sprite = def.customSprites[variations[variation].endSprite]
 			elseif self.isAttached and variations[variation] and variations[variation].attachedSprite then
@@ -12516,11 +12631,11 @@
 	renderMethod = function(self, x, y, r, g, b, ox, oy)
 		local spr
 		local ch = self.children and self.children[1]
-		
+
 		if ch then
 			local cx, cy, ca
 			local angle = self.angle
-			
+
 			if ch._category == "tile" then
 				if ch.def.nodes then
 					cx, cy, ca = ch:getNodeXYAngle()
@@ -12530,36 +12645,39 @@
 			else
 				cx, cy, ca = ch.x, ch.y, ch.angle
 			end
-			
+
 			cx, cy = cx - ox, cy - oy
-			
+
 			local wh = self.width * 0.5
 			local left_angle_c = ca - half_pi
 			local right_angle_c = ca + half_pi
 			local left_angle = angle - half_pi
 			local right_angle = angle + half_pi
-			
-			video.renderSpriteStateFreeShape(self.sprite, x + math_cos(left_angle) * wh, y + math_sin(left_angle) * wh, cx + math_cos(left_angle_c) * wh, cy + math_sin(left_angle_c) * wh, x + math_cos(right_angle) * wh, y + math_sin(right_angle) * wh, cx + math_cos(right_angle_c) * wh, cy + math_sin(right_angle_c) * wh, 255, r, g, b)
+
+			video.renderSpriteStateFreeShape(self.sprite, x + math_cos(left_angle) * wh, y + math_sin(left_angle) * wh,
+				cx + math_cos(left_angle_c) * wh, cy + math_sin(left_angle_c) * wh, x + math_cos(right_angle) * wh,
+				y + math_sin(right_angle) * wh, cx + math_cos(right_angle_c) * wh, cy + math_sin(right_angle_c) * wh, 255, r, g,
+				b)
 		end
 	end,
 	initMethod = cordBObjectInit,
 	awakeMethod = function(self, time)
 		local ch = self.children and self.children[1]
-		
+
 		if ch then
 			local x, y = self.x, self.y
 			local cx, cy = ch.x, ch.y
-			
+
 			self.length = math_max(self.minLength, math_distance(x, y, cx, cy) + 1)
 			self.angle = math_angleBetweenPoints(x, y, cx, cy)
 		end
-		
+
 		if math_abs(self.dy) > 100 then
 			self:setSpeedXY(0, 0)
 		end
-		
+
 		local motionless = self.motionless * 3
-		
+
 		self:stopSpeedXY(motionless, motionless, time)
 	end,
 	getGravity = function(self)
@@ -12599,9 +12717,9 @@
 	self.length = self.length or length or 96
 	self.variation = self.variation or math_random(1, 4)
 	self.rnd = self.rnd or math_random()
-	
+
 	self:setBounds()
-	
+
 	self.quad = self.quad or helpers.initQuad(self.x, self.y)
 end
 
@@ -12621,50 +12739,52 @@
 	},
 	renderMethod = function(self, x, y, r, g, b)
 		local spr
-		
+
 		if self.variation then
 			spr = self.def.sprites[self.variation]
 		else
 			spr = self.def.sprites[1]
 		end
-		
-		video.renderSpriteStateFreeShape(spr, self.quad.x1 - self.x + x, self.quad.y1 - self.y + y, self.quad.x2 - self.x + x, self.quad.y2 - self.y + y, self.quad.x3 - self.x + x, self.quad.y3 - self.y + y, self.quad.x4 - self.x + x, self.quad.y4 - self.y + y, 255, r, g, b)
+
+		video.renderSpriteStateFreeShape(spr, self.quad.x1 - self.x + x, self.quad.y1 - self.y + y, self.quad.x2 - self.x + x,
+			self.quad.y2 - self.y + y, self.quad.x3 - self.x + x, self.quad.y3 - self.y + y, self.quad.x4 - self.x + x,
+			self.quad.y4 - self.y + y, 255, r, g, b)
 	end,
 	initMethod = camouflageObjectInit,
 	awakeMethod = function(self, time)
 		local angleSpeed = self.map.physics:getEntityAngleSpeed(self.body)
-		
+
 		if self.map.physics:getEntityAngleSpeed(self.body) > 0 then
 			self.map.physics:setEntityAngleSpeed(self.body, math_max(0, angleSpeed - angleSpeed * time * 0.2))
 		else
 			self.map.physics:setEntityAngleSpeed(self.body, math_min(0, angleSpeed - angleSpeed * time * 0.2))
 		end
-		
+
 		self:stopSpeedXY(1, 1, time)
-		
+
 		local x, y = self.x, self.y
 		local tx, ty
 		local tAng = 0
 		local c = self.children and self.children[1]
-		
+
 		if c then
 			tx, ty = c.x, c.y
 			tAng = c.angle
 		end
-		
+
 		local rndFactor = 60
 		local h1 = 86
 		local h2 = 86
 		local length = self.length
-		
+
 		if self.rnd then
 			h1 = h1 + rndFactor * self.rnd
 		end
-		
+
 		if c and c.rnd then
 			h2 = h2 + rndFactor * c.rnd
 		end
-		
+
 		if c and c.type ~= self.type then
 			h2 = 20
 			tx = c.x
@@ -12673,9 +12793,9 @@
 			tx = x + math_cos(self.angle) * length / 2
 			ty = y + math_sin(self.angle) * length / 2
 		end
-		
+
 		local p = self.parents and self.parents[1]
-		
+
 		if p and p.type ~= self.type then
 			h1 = 20
 			x = p.x
@@ -12684,9 +12804,9 @@
 			x = p.x + math_cos(p.angle) * p.length / 2
 			y = p.y + math_sin(p.angle) * p.length / 2
 		end
-		
+
 		local overLap = 15
-		
+
 		self.quad.x1 = x + math_cos(self.angle + math_pi) * overLap / 2
 		self.quad.x2 = tx + math_cos(tAng) * overLap / 2
 		self.quad.x3 = x + math_cos(self.angle + half_pi) * h1 + math_cos(self.angle + math_pi) * overLap / 2
@@ -12695,8 +12815,11 @@
 		self.quad.y2 = ty + math_sin(tAng) * overLap / 2
 		self.quad.y3 = y + math_sin(self.angle + half_pi) * h1 + math_sin(self.angle + math_pi) * overLap / 2
 		self.quad.y4 = ty + math_sin(tAng + half_pi) * h2 + math_sin(tAng) * overLap / 2
-		
-		self:setBounds(math_min(math_min(self.quad.x1, self.quad.x2), math_min(self.quad.x3, self.quad.x4)), math_min(math_min(self.quad.y1, self.quad.y2), math_min(self.quad.y3, self.quad.y4)), math_max(math_max(self.quad.x1, self.quad.x2), math_max(self.quad.x3, self.quad.x4)), math_max(math_max(self.quad.y1, self.quad.y2), math_max(self.quad.y3, self.quad.y4)))
+
+		self:setBounds(math_min(math_min(self.quad.x1, self.quad.x2), math_min(self.quad.x3, self.quad.x4)),
+			math_min(math_min(self.quad.y1, self.quad.y2), math_min(self.quad.y3, self.quad.y4)),
+			math_max(math_max(self.quad.x1, self.quad.x2), math_max(self.quad.x3, self.quad.x4)),
+			math_max(math_max(self.quad.y1, self.quad.y2), math_max(self.quad.y3, self.quad.y4)))
 	end,
 	render = {
 		oy = 0,
@@ -12740,37 +12863,37 @@
 	end,
 	updateMethod = function(self, time)
 		self.time = self.time + time
-		
+
 		if self.colliding then
 			self.time = self.time + time * 10
 		end
-		
+
 		self:stopSpeedXY(3, 3, time)
-		
+
 		if self.lifeTime and self.time > self.lifeTime then
 			self:remove()
 		end
-		
+
 		local vol = 1 - math_max(0, math_min(1, self.time)) / 2
-		
+
 		self:emitLoop("flame", vol, -math_max(0, math_min(1, self.time)) * 0.55 + 1.5, vol * RANGES.long)
-		
+
 		if self:isInView(200) and math_random() < time * 185 / (1 + math_max(0, 10 * self.time)) then
 			local ang = math_pi * 2 * math_random()
 			local dist = math_random() * 5
-			
+
 			if self.fluidType and DEFS.FLUIDS[self.fluidType].onExplosion then
 				if math_random() < 0.2 then
 					DEFS.FLUIDS[self.fluidType].onExplosion(self, 0.2)
 				end
 			else
 				local fx = self:emitFxAt("shrapnelFireSmoke", self.x + math_cos(ang) * dist, self.y + math_sin(ang) * dist)
-				
+
 				fx:setSpeed(math_random() * math_pi * 2, math_random(20))
 			end
-			
+
 			local fx = self:emitFxAt("shrapnelFire", self.x + math_cos(ang) * dist, self.y + math_sin(ang) * dist)
-			
+
 			fx:setSpeed(math_random() * math_pi * 2, math_random(200))
 		end
 	end,
@@ -12821,35 +12944,35 @@
 	end,
 	updateMethod = function(self, time)
 		self.time = self.time + time
-		
+
 		if self.colliding then
 			self.time = self.time + time * 10
 		end
-		
+
 		self:stopSpeedXY(3, 3, time)
-		
+
 		if self.lifeTime and self.time > self.lifeTime then
 			self:remove()
 		end
-		
+
 		local vol = 1 - math_max(0, math_min(1, self.time)) / 2
-		
+
 		if self:isInView(200) and math_random() < time * 185 / (1 + math_max(0, 10 * self.time)) then
 			local ang = math_pi * 2 * math_random()
 			local dist = math_random() * 5
-			
+
 			if self.fluidType and DEFS.FLUIDS[self.fluidType].onExplosion then
 				if math_random() < 0.2 then
 					DEFS.FLUIDS[self.fluidType].onExplosion(self, 0.2)
 				end
 			else
 				local fx = self:emitFxAt("shrapnelFireSmoke", self.x + math_cos(ang) * dist, self.y + math_sin(ang) * dist)
-				
+
 				fx:setSpeed(math_random() * math_pi * 2, math_random(20))
 			end
-			
+
 			local fx = self:emitFxAt("shrapnelFire", self.x + math_cos(ang) * dist, self.y + math_sin(ang) * dist)
-			
+
 			fx:setSpeed(math_random() * math_pi * 2, math_random(200))
 		end
 	end,
@@ -12901,10 +13024,10 @@
 		self.totalTime = 0
 		self.bounces = 0
 		self.myFx = self:emitFx(fxType or "purpSpark")
-		
+
 		if not self.lifeTime then
 			local lt = self.myFx.lifeTime or self.myFx.def.lifeTime
-			
+
 			if lt then
 				self:setLifeTime(lt)
 			end
@@ -12913,23 +13036,23 @@
 	onRemovedMethod = function(self)
 		if self.myFx then
 			self.myFx:remove()
-			
+
 			self.myFx = nil
 		end
-		
+
 		if self.dieSound and math_random() > 0.75 then
 			self:emitSound(self.dieSound, 1, 1)
 		end
-		
+
 		if self.deathFxName then
 			self:emitFx(self.deathFxName)
 		end
 	end,
 	updateMethod = function(self, time)
 		self.totalTime = self.totalTime + time
-		
+
 		local myfx = self.myFx
-		
+
 		if myfx then
 			if myfx._remove then
 				self:remove()
@@ -12938,36 +13061,36 @@
 					self.time = self.time + time
 				elseif self.onGround or self.totalTime > 5 then
 					self.time = self.time + time * 2
-					
+
 					self:stopSpeedXY(6.5, 6.5, time)
 				end
-				
+
 				if self.collisionTimeFactor and self.onGround then
 					self.time = self.time + time * self.collisionTimeFactor
 				end
-				
+
 				myfx:setPosition(self.x, self.y)
 				myfx:setTime(math_max(0, self.time))
 				myfx:setAngle(self.angle)
 			end
 		end
-		
+
 		if self.target then
 			local angle = self:getAngleTo(self.target)
 			local dist = self:getDistanceTo(self.target)
-			
+
 			self:addSpeed(angle, dist * time * 0.5 + 100 * time)
-			
+
 			if dist <= 2 then
 				self:remove()
 			end
 		end
-		
+
 		local airFriction = self.airFriction or 0.5
 		local speed = self:getSpeed()
-		
+
 		self:stopSpeedXY(airFriction * speed * 0.05, airFriction * speed * 0.05, time)
-		
+
 		if self.lifeTime and self.time > self.lifeTime then
 			self:remove()
 		end
@@ -12975,16 +13098,16 @@
 	collisionMethod = function(self, impact)
 		if self.collisionSound then
 			local vol = self:getImpactVolume(impact, 6)
-			
+
 			if vol > 0.1 then
 				if math_random() > 0.75 then
 					self:emitSound(self.collisionSound, vol, 1)
 				end
-				
+
 				self.collisionSound = nil
 			end
 		end
-		
+
 		if self.dieOnCollision then
 			self:remove()
 		end
@@ -13037,11 +13160,12 @@
 		"bubble5"
 	},
 	renderMethod = function(self, x, y, r, g, b)
-		video.renderSpriteState(self.def.sprites[self.variation], x, y, self.scale, self.angle, self.alpha * 255, r, g, b, self.flipped)
+		video.renderSpriteState(self.def.sprites[self.variation], x, y, self.scale, self.angle, self.alpha * 255, r, g, b,
+			self.flipped)
 	end,
 	initMethod = function(self, scale)
 		self:setLifeTime(self.def.minLifeTime + (self.def.maxLifeTime - self.def.minLifeTime) * math_random() * math_random())
-		
+
 		self.sway = 0
 		self.swayV = math_random() - math_random()
 		self.alpha = 1
@@ -13053,53 +13177,53 @@
 		self.swayV = self.swayV + math_random() * time - math_random() * time
 		self.sway = self.sway + self.swayV * time * 2
 		self.dx = self.dx + math_cos(self.sway * math_pi) * time * 2
-		
+
 		local gravity = -10
-		
+
 		self.dy = self.dy + gravity * time + math_sin(self.sway * 3 * math_pi) * time * 4
-		
+
 		self:stopSpeedXY(math_abs(self.dx * self.dx) / 20, math_abs(self.dy * self.dy) / 20, time)
-		
+
 		self.alpha = math_min(1, math_max(0, 12 - 12 * self.time / self.lifeTime))
-		
+
 		if not self.doFade and math_random() < math_max(0, self.scale - 0.2) * self.time / 100 then
 			local divs = math_random(2, 3)
-			
+
 			for i = 1, divs do
 				local nScale = self.scale / (divs + math_random() * self.scale)
 				local ang = math_randomAngle()
 				local dist = math_random() * (self.scale - nScale) * 20
-				
+
 				if nScale > 0.01 then
 					local a = self:emitBubbleAt(self.x + math_cos(ang) * dist, self.y + math_sin(ang) * dist, nScale)
-					
+
 					a:addSpeed(ang, nScale * dist * 2)
-					
+
 					a.lifeTime = a.lifeTime / divs
 				end
 			end
-			
+
 			self.doFade = true
 		end
-		
+
 		self.scale = self.scale - self.scale * time * 0.25 - time * 0.1
-		
+
 		if self.scale <= 0 then
 			self:remove()
 		end
-		
+
 		if self.lifeTime and self.time > self.lifeTime then
 			self:remove()
 		end
-		
+
 		if self.doFade then
 			self.scale = self.scale * (1 - time * 4) + self.scale * 0.5 * time * 4
-			
+
 			if self.scale <= 0.01 then
 				self:remove()
 			end
 		end
-		
+
 		if self.fluidType ~= "water" then
 			self:destroy()
 		end
@@ -13138,7 +13262,7 @@
 	debris = true,
 	initRuntimeMethod = function(self)
 		self:setLifeTime(3)
-		
+
 		self.fade = 1
 	end,
 	classifications = {
@@ -13146,10 +13270,10 @@
 	},
 	updateVisualMethod = function(self, time)
 		local prg = self.time / self.lifeTime
-		
+
 		self.fade = 1 - prg
 		self.time = self.time + time
-		
+
 		if self.time > self.lifeTime then
 			self:remove()
 		end
@@ -13163,7 +13287,7 @@
 	debris = true,
 	initRuntimeMethod = function(self)
 		self:setLifeTime(3)
-		
+
 		self.fade = 1
 	end,
 	classifications = {
@@ -13171,10 +13295,10 @@
 	},
 	updateVisualMethod = function(self, time)
 		local prg = self.time / self.lifeTime
-		
+
 		self.fade = 1 - prg
 		self.time = self.time + time
-		
+
 		if self.time > self.lifeTime then
 			self:remove()
 		end
@@ -13203,39 +13327,45 @@
 	},
 	renderMethod = function(self, x, y, r, g, b)
 		local a, r, g, b = self.parent.layer:getColors()
-		
+
 		if self.parent.lightReferences ~= nil then
 			r, g, b = self.parent:getLitColor(r, g, b)
 		end
-		
+
 		local spr
 		local top = self.def.customSprites.elevatorPistonTop
 		local bot = self.def.customSprites.elevatorPistonBottom
-		
+
 		if self.variation then
 			spr = self.def.sprites[self.variation]
 		else
 			spr = self.def.sprites[1]
 		end
-		
+
 		if self.bobo then
 			r = 0
 		end
-		
-		video.renderSpriteStateFreeShape(spr, self.quad.x1 - self.x + x, self.quad.y1 - self.y + y, self.quad.x2 - self.x + x, self.quad.y2 - self.y + y, self.quad.x3 - self.x + x, self.quad.y3 - self.y + y, self.quad.x4 - self.x + x, self.quad.y4 - self.y + y, 255, r, g, b)
-		
+
+		video.renderSpriteStateFreeShape(spr, self.quad.x1 - self.x + x, self.quad.y1 - self.y + y, self.quad.x2 - self.x + x,
+			self.quad.y2 - self.y + y, self.quad.x3 - self.x + x, self.quad.y3 - self.y + y, self.quad.x4 - self.x + x,
+			self.quad.y4 - self.y + y, 255, r, g, b)
+
 		if top then
-			video.renderSpriteStateFreeShape(top, self.quadTop.x1 - self.x + x, self.quadTop.y1 - self.y + y, self.quadTop.x2 - self.x + x, self.quadTop.y2 - self.y + y, self.quadTop.x3 - self.x + x, self.quadTop.y3 - self.y + y, self.quadTop.x4 - self.x + x, self.quadTop.y4 - self.y + y, 255, r, g, b)
+			video.renderSpriteStateFreeShape(top, self.quadTop.x1 - self.x + x, self.quadTop.y1 - self.y + y,
+				self.quadTop.x2 - self.x + x, self.quadTop.y2 - self.y + y, self.quadTop.x3 - self.x + x,
+				self.quadTop.y3 - self.y + y, self.quadTop.x4 - self.x + x, self.quadTop.y4 - self.y + y, 255, r, g, b)
 		end
-		
+
 		if bot then
-			video.renderSpriteStateFreeShape(bot, self.quadBottom.x1 - self.x + x, self.quadBottom.y1 - self.y + y, self.quadBottom.x2 - self.x + x, self.quadBottom.y2 - self.y + y, self.quadBottom.x3 - self.x + x, self.quadBottom.y3 - self.y + y, self.quadBottom.x4 - self.x + x, self.quadBottom.y4 - self.y + y, 255, r, g, b)
+			video.renderSpriteStateFreeShape(bot, self.quadBottom.x1 - self.x + x, self.quadBottom.y1 - self.y + y,
+				self.quadBottom.x2 - self.x + x, self.quadBottom.y2 - self.y + y, self.quadBottom.x3 - self.x + x,
+				self.quadBottom.y3 - self.y + y, self.quadBottom.x4 - self.x + x, self.quadBottom.y4 - self.y + y, 255, r, g, b)
 		end
 	end,
 	initMethod = pistonObjectInit,
 	initRuntimeMethod = function(self)
 		self:setBounds()
-		
+
 		self.quad = helpers.initQuad(self.x, self.y)
 		self.quadTop = helpers.initQuad(self.x, self.y)
 		self.quadBottom = helpers.initQuad(self.x, self.y)
@@ -13248,13 +13378,13 @@
 			local htop = 36
 			local tAng = self.angle
 			local tx, ty = self.x, self.y
-			
+
 			if self.child then
 				tx, ty = self.child.x, self.child.y
 			elseif self.children and #self.children > 0 then
 				tx, ty = self.children[1]:getNodeXY()
 			end
-			
+
 			local totalLen = math_distance(x, y, tx, ty)
 			local topSize = 18
 			local bottomSize = math_min(totalLen / 2, 32)
@@ -13265,7 +13395,7 @@
 			local half_overlap = overLap / 2
 			local inv_angle = self.angle + math_pi
 			local side_angle = self.angle + half_pi
-			
+
 			quad.x1 = x + math_cos(inv_angle) * overLap / 2 - math_cos(self.angle + half_pi) * h1 / 2
 			quad.x2 = tx + math_cos(tAng) * half_overlap - math_cos(tAng + half_pi) * h1 / 2
 			quad.x3 = x + math_cos(side_angle) * h1 / 2 + math_cos(inv_angle) * half_overlap
@@ -13274,9 +13404,9 @@
 			quad.y2 = ty + math_sin(tAng) * half_overlap - math_sin(tAng + half_pi) * h1 / 2
 			quad.y3 = y + math_sin(side_angle) * h1 / 2 + math_sin(inv_angle) * half_overlap
 			quad.y4 = ty + math_sin(tAng + half_pi) * h1 / 2 + math_sin(tAng) * half_overlap
-			
+
 			local quadTop = self.quadTop
-			
+
 			quadTop.x1 = topX + math_cos(inv_angle) * half_overlap - math_cos(side_angle) * htop / 2
 			quadTop.x2 = tx + math_cos(tAng) * half_overlap - math_cos(tAng + half_pi) * htop / 2
 			quadTop.x3 = topX + math_cos(side_angle) * htop / 2 + math_cos(inv_angle) * half_overlap
@@ -13285,9 +13415,9 @@
 			quadTop.y2 = ty + math_sin(tAng) * half_overlap - math_sin(tAng + half_pi) * htop / 2
 			quadTop.y3 = topY + math_sin(side_angle) * htop / 2 + math_sin(inv_angle) * half_overlap
 			quadTop.y4 = ty + math_sin(tAng + half_pi) * htop / 2 + math_sin(tAng) * half_overlap
-			
+
 			local quadBottom = self.quadBottom
-			
+
 			quadBottom.x1 = x + math_cos(inv_angle) * half_overlap - math_cos(side_angle) * h1 / 2
 			quadBottom.x2 = botX + math_cos(tAng) * half_overlap - math_cos(tAng + half_pi) * h1 / 2
 			quadBottom.x3 = x + math_cos(side_angle) * h1 / 2 + math_cos(inv_angle) * half_overlap
@@ -13296,8 +13426,11 @@
 			quadBottom.y2 = botY + math_sin(tAng) * half_overlap - math_sin(tAng + half_pi) * h1 / 2
 			quadBottom.y3 = y + math_sin(side_angle) * h1 / 2 + math_sin(inv_angle) * half_overlap
 			quadBottom.y4 = botY + math_sin(tAng + half_pi) * h1 / 2 + math_sin(tAng) * half_overlap
-			
-			self:setBounds(math_min(math_min(quad.x1, quad.x2), math_min(quad.x3, quad.x4)), math_min(math_min(quad.y1, quad.y2), math_min(quad.y3, quad.y4)), math_max(math_max(quad.x1, quad.x2), math_max(quad.x3, quad.x4)), math_max(math_max(quad.y1, quad.y2), math_max(quad.y3, quad.y4)))
+
+			self:setBounds(math_min(math_min(quad.x1, quad.x2), math_min(quad.x3, quad.x4)),
+				math_min(math_min(quad.y1, quad.y2), math_min(quad.y3, quad.y4)),
+				math_max(math_max(quad.x1, quad.x2), math_max(quad.x3, quad.x4)),
+				math_max(math_max(quad.y1, quad.y2), math_max(quad.y3, quad.y4)))
 		end
 	end,
 	render = {
@@ -13329,7 +13462,7 @@
 	if not def.render_classifications then
 		def.render_classifications = {}
 	end
-	
+
 	assert(not table.contains(def.render_classifications, classi), "duplicate render_classifications", classi)
 	table.insert(def.render_classifications, classi)
 end
@@ -13338,7 +13471,7 @@
 	if not def.classifications then
 		def.classifications = {}
 	end
-	
+
 	assert(not table.contains(def.classifications, classi), "duplicate classifications", classi)
 	table.insert(def.classifications, classi)
 end
@@ -13363,156 +13496,158 @@
 
 function defs_objects.init()
 	processItemDefs()
-	
+
 	for index, obj in pairs(OBJECTS) do
-		def_logic.defs_apply_key(OBJECTS, index)
-		
-		obj.index = index
-		obj.bounds = Bounds:new(0, 0, 0, 0)
-		
-		if obj.isTarget == nil then
-			obj.isTarget = true
-		end
-		
-		if not obj.localizedId then
-			obj.localizedId = "object_" .. index
-		end
-		
-		if obj.explosive then
-			obj.omniThreat = true
-			obj.isObject = true
-		end
-		
-		if obj.hitable == nil then
-			obj.hitable = true
-		end
-		
-		obj.getBulletTimeFactor = obj.getBulletTimeFactor or defaultGetBulletTimeFactor
-		obj.getBulletTimeDistanceFactor = obj.getBulletTimeDistanceFactor or defaultGetBulletTimeDistanceFactor
-		obj.bulletTimeFactor = obj.bulletTimeFactor or 1
-		obj.bulletTimeMultiplier = obj.bulletTimeMultiplier or 1
-		obj.bulletTimeDistanceFactor = obj.bulletTimeDistanceFactor or 1
-		
-		local physics_def = obj.physics
-		
-		if physics_def then
-			definitions.verifyPhysics(physics_def)
-			
-			obj.prediction_physics = definitions.generatePredictionPhysics(physics_def, index)
-			obj.idle_physics = definitions.generateIdlePhysics(physics_def, index)
-			obj.debris_physics = definitions.generateDebrisPhysics(physics_def, index)
-			
-			obj.bounds:matchPhysics(physics_def)
-		else
-			obj.bounds:expand(-8, -8, 8, 8)
-		end
-		
-		local itemDef = obj.itemRefIndex and ITEMS[obj.itemRefIndex]
-		
-		if itemDef and itemDef.explosive or obj.explosive then
-			addClassification(obj, "explosive")
-		end
-		
-		if itemDef and itemDef.carried and not itemDef.safeWeaponSize then
-			local safeRadius = obj.bounds:getRadius()
-			
-			itemDef.safeWeaponSize = safeRadius
-		end
-		
-		if obj.attack then
-			local attack_def = ATTACKS[obj.attack]
-			
-			obj.fxScale = attack_def.fxScale
-		elseif itemDef and itemDef.attack then
-			local attack_def = ATTACKS[itemDef.attack]
-			
-			obj.fxScale = attack_def.fxScale
-		end
-		
-		obj.markerScale = math.min(1, 0.5 + 0.5 * (obj.fxScale or 1))
-		
-		if obj.magnetic ~= false then
-			obj.magnetic = true
-		end
-		
-		if obj.isBullet then
-			obj.magnetic_factor = 1
-		else
-			obj.magnetic_factor = 0.25
-		end
-		
-		if obj.renderMethod then
-			if obj.foreground then
-				addRenderClassification(obj, "foreground")
-			elseif obj.background then
-				addRenderClassification(obj, "background")
-				addRenderClassification(obj, "pushable")
-			elseif not obj.beam then
-				addRenderClassification(obj, "middleground")
-			end
-		end
-		
-		if obj.sensorMethod then
-			addClassification(obj, "sensor")
-		end
-		
-		if obj.beam then
-			addClassification(obj, "beam")
-			addClassification(obj, "pushable")
-		end
-		
-		if obj.updateRenderMethod then
-			addClassification(obj, "updateRender")
-		end
-		
-		if obj.hitable then
-			addClassification(obj, "hitable")
-		end
-		
-		if obj.extinguishable then
-			addClassification(obj, "extinguishable")
-		end
-		
-		if obj.hackable then
-			addClassification(obj, "hackable")
-		end
-		
-		if obj.updateMethod then
-			addClassification(obj, "update")
-		end
-		
-		if obj.updateVisualMethod then
-			addClassification(obj, "updateVisual")
-		end
-		
-		if itemDef and itemDef.lightMapRenderMethod or obj.lightMapRenderMethod then
-			addClassification(obj, "light")
-		end
-		
-		if itemDef then
-			if itemDef.huge then
+		if not obj.index then
+			def_logic.defs_apply_key(OBJECTS, index)
+
+			obj.index = index
+			obj.bounds = Bounds:new(0, 0, 0, 0)
+
+			if obj.isTarget == nil then
+				obj.isTarget = true
+			end
+
+			if not obj.localizedId then
+				obj.localizedId = "object_" .. index
+			end
+
+			if obj.explosive then
+				obj.omniThreat = true
+				obj.isObject = true
+			end
+
+			if obj.hitable == nil then
+				obj.hitable = true
+			end
+
+			obj.getBulletTimeFactor = obj.getBulletTimeFactor or defaultGetBulletTimeFactor
+			obj.getBulletTimeDistanceFactor = obj.getBulletTimeDistanceFactor or defaultGetBulletTimeDistanceFactor
+			obj.bulletTimeFactor = obj.bulletTimeFactor or 1
+			obj.bulletTimeMultiplier = obj.bulletTimeMultiplier or 1
+			obj.bulletTimeDistanceFactor = obj.bulletTimeDistanceFactor or 1
+
+			local physics_def = obj.physics
+
+			if physics_def then
+				definitions.verifyPhysics(physics_def)
+
+				obj.prediction_physics = definitions.generatePredictionPhysics(physics_def, index)
+				obj.idle_physics = definitions.generateIdlePhysics(physics_def, index)
+				obj.debris_physics = definitions.generateDebrisPhysics(physics_def, index)
+
+				obj.bounds:matchPhysics(physics_def)
+			else
+				obj.bounds:expand(-8, -8, 8, 8)
+			end
+
+			local itemDef = obj.itemRefIndex and ITEMS[obj.itemRefIndex]
+
+			if itemDef and itemDef.explosive or obj.explosive then
+				addClassification(obj, "explosive")
+			end
+
+			if itemDef and itemDef.carried and not itemDef.safeWeaponSize then
+				local safeRadius = obj.bounds:getRadius()
+
+				itemDef.safeWeaponSize = safeRadius
+			end
+
+			if obj.attack then
+				local attack_def = ATTACKS[obj.attack]
+
+				obj.fxScale = attack_def.fxScale
+			elseif itemDef and itemDef.attack then
+				local attack_def = ATTACKS[itemDef.attack]
+
+				obj.fxScale = attack_def.fxScale
+			end
+
+			obj.markerScale = math.min(1, 0.5 + 0.5 * (obj.fxScale or 1))
+
+			if obj.magnetic ~= false then
+				obj.magnetic = true
+			end
+
+			if obj.isBullet then
+				obj.magnetic_factor = 1
+			else
+				obj.magnetic_factor = 0.25
+			end
+
+			if obj.renderMethod then
+				if obj.foreground then
+					addRenderClassification(obj, "foreground")
+				elseif obj.background then
+					addRenderClassification(obj, "background")
+					addRenderClassification(obj, "pushable")
+				elseif not obj.beam then
+					addRenderClassification(obj, "middleground")
+				end
+			end
+
+			if obj.sensorMethod then
+				addClassification(obj, "sensor")
+			end
+
+			if obj.beam then
+				addClassification(obj, "beam")
 				addClassification(obj, "pushable")
 			end
-			
-			if itemDef.crate then
-				addClassification(obj, "crate")
-			end
-		end
-		
-		obj.noPhysics = not obj.physics or #obj.physics <= 0
-		
-		if BITSQUID and obj.renderMethod ~= nil then
-			local renderMethod = obj.renderMethod
-			
-			function obj.renderMethod(...)
-				local r1, r2, r3, r4, r5, r6 = renderMethod(...)
-				
-				return r1, r2, r3, r4, r5, r6
-			end
-		end
-		
-		if not obj.fuzzySize then
-			obj.fuzzySize = obj.bounds:getRadius()
+
+			if obj.updateRenderMethod then
+				addClassification(obj, "updateRender")
+			end
+
+			if obj.hitable then
+				addClassification(obj, "hitable")
+			end
+
+			if obj.extinguishable then
+				addClassification(obj, "extinguishable")
+			end
+
+			if obj.hackable then
+				addClassification(obj, "hackable")
+			end
+
+			if obj.updateMethod then
+				addClassification(obj, "update")
+			end
+
+			if obj.updateVisualMethod then
+				addClassification(obj, "updateVisual")
+			end
+
+			if itemDef and itemDef.lightMapRenderMethod or obj.lightMapRenderMethod then
+				addClassification(obj, "light")
+			end
+
+			if itemDef then
+				if itemDef.huge then
+					addClassification(obj, "pushable")
+				end
+
+				if itemDef.crate then
+					addClassification(obj, "crate")
+				end
+			end
+
+			obj.noPhysics = not obj.physics or #obj.physics <= 0
+
+			if BITSQUID and obj.renderMethod ~= nil then
+				local renderMethod = obj.renderMethod
+
+				function obj.renderMethod(...)
+					local r1, r2, r3, r4, r5, r6 = renderMethod(...)
+
+					return r1, r2, r3, r4, r5, r6
+				end
+			end
+
+			if not obj.fuzzySize then
+				obj.fuzzySize = obj.bounds:getRadius()
+			end
 		end
 	end
 end
@@ -13531,18 +13666,18 @@
 
 function Object:returnToOwner()
 	local owner = self:getHelperOwner()
-	
+
 	if owner then
 		owner:emitHelperErrorAt(self.x, self.y)
-		
+
 		local tfx = self:emitPpFxAt("rewardItem", self.x, self.y)
-		
+
 		tfx.itemRef = self.itemRef
 		tfx.target = owner
 		tfx.husk = self.husk
 		tfx.duration = 0.25 + math_distance(self.x, self.y, owner.x, owner.y) / 500
 	end
-	
+
 	self:disarm()
 	self:remove()
 end
diff -X exclude -ruN daisyMoon/quickmenu.lua moddedDaisyMoon/quickmenu.lua
--- daisyMoon/quickmenu.lua	2023-11-30 02:17:06.621108483 +0100
+++ moddedDaisyMoon/quickmenu.lua	2023-12-06 20:40:43.536099515 +0100
@@ -33,7 +33,6 @@
 
 local FTexts = {
 	"hub",
-	"adventure",
 	"mode",
 	"asset",
 	"set",
@@ -43,9 +42,19 @@
 	"world",
 	"mod"
 }
+local FCtrlTexts = {
+	"adventure",
+	"",
+	"alloy",
+	"",
+	"",
+	"",
+	"",
+	"team",
+	"talk"
+}
 local Fbuttons = {
 	"F1",
-	"CTRL+F1",
 	"F2",
 	"F3",
 	"F4",
@@ -58,9 +67,9 @@
 local buttons = {
 	public = {
 		1,
-		6,
-		8,
-		10
+		7,
+		9,
+		11
 	},
 	dev = {
 		1,
@@ -72,8 +81,18 @@
 		7,
 		8,
 		9,
-		10
-	}
+	},
+}
+local keys = {
+		112,
+		113,
+		114,
+		115,
+		116,
+		117,
+		118,
+		119,
+		120,
 }
 
 function QuickMenu:render()
@@ -82,11 +101,13 @@
 		
 		for b = 1, #buttons[self.fmenu] do
 			local i = buttons[self.fmenu][b]
+			local k = keys[b]
 			local x = (canvas.w - wi) * 0.5 + (b - 0.75) * wi / #buttons[self.fmenu]
-			local a = daisy.isKeyPressed(111 + i) and 255 or 80
+			local a = daisy.isKeyPressed(k) and 255 or 80
 			
-			video.renderShadowedTextSprites(Fbuttons[i], x, canvas.h - 30, 1, "small", a, 196, 196, 196, nil, 0.75)
-			video.renderShadowedTextSprites(FTexts[i], x, canvas.h - 15, 1, "small", a, 255, 255, 255, nil, 0.75)
+			video.renderShadowedTextSprites(Fbuttons[i], x, canvas.h - 45, 1, "small", a, 196, 196, 196, nil, 0.75)
+			video.renderShadowedTextSprites(FTexts[i], x, canvas.h - 30, 1, "small", a, 255, 255, 255, nil, 0.75)
+			video.renderShadowedTextSprites(FCtrlTexts[i], x, canvas.h - 15, 1, "small", a, 255, 255, 255, nil, 0.75)
 		end
 	end
 end
Binary files daisyMoon/replaced/main.lua and moddedDaisyMoon/replaced/main.lua differ
